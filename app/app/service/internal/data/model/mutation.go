// Code generated by entc, DO NOT EDIT.

package model

import (
	"context"
	"fmt"
	"mall-go/app/app/service/internal/data/ent/schema"
	"mall-go/app/app/service/internal/data/model/activity"
	"mall-go/app/app/service/internal/data/model/banner"
	"mall-go/app/app/service/internal/data/model/banneritem"
	"mall-go/app/app/service/internal/data/model/brand"
	"mall-go/app/app/service/internal/data/model/category"
	"mall-go/app/app/service/internal/data/model/charge"
	"mall-go/app/app/service/internal/data/model/coupon"
	"mall-go/app/app/service/internal/data/model/coupontemplate"
	"mall-go/app/app/service/internal/data/model/coupontype"
	"mall-go/app/app/service/internal/data/model/gridcategory"
	"mall-go/app/app/service/internal/data/model/order"
	"mall-go/app/app/service/internal/data/model/orderdetail"
	"mall-go/app/app/service/internal/data/model/ordersnap"
	"mall-go/app/app/service/internal/data/model/ordersub"
	"mall-go/app/app/service/internal/data/model/predicate"
	"mall-go/app/app/service/internal/data/model/refund"
	"mall-go/app/app/service/internal/data/model/saleexplain"
	"mall-go/app/app/service/internal/data/model/sku"
	"mall-go/app/app/service/internal/data/model/skuspec"
	"mall-go/app/app/service/internal/data/model/speckey"
	"mall-go/app/app/service/internal/data/model/specvalue"
	"mall-go/app/app/service/internal/data/model/spu"
	"mall-go/app/app/service/internal/data/model/spudetailimg"
	"mall-go/app/app/service/internal/data/model/spuimg"
	"mall-go/app/app/service/internal/data/model/tag"
	"mall-go/app/app/service/internal/data/model/theme"
	"mall-go/app/app/service/internal/data/model/user"
	"mall-go/app/app/service/internal/data/model/usercoupon"
	"mall-go/app/app/service/internal/data/model/userfavor"
	"mall-go/app/app/service/internal/data/model/userinfo"
	"mall-go/app/app/service/internal/data/model/userpoint"
	"mall-go/app/app/service/internal/data/model/userpointdetail"
	"mall-go/app/app/service/internal/data/model/userwallet"
	"mall-go/app/app/service/internal/data/model/userwalletdetail"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity         = "Activity"
	TypeBanner           = "Banner"
	TypeBannerItem       = "BannerItem"
	TypeBrand            = "Brand"
	TypeCategory         = "Category"
	TypeCharge           = "Charge"
	TypeCoupon           = "Coupon"
	TypeCouponTemplate   = "CouponTemplate"
	TypeCouponType       = "CouponType"
	TypeGridCategory     = "GridCategory"
	TypeOrder            = "Order"
	TypeOrderDetail      = "OrderDetail"
	TypeOrderSnap        = "OrderSnap"
	TypeOrderSub         = "OrderSub"
	TypeRefund           = "Refund"
	TypeSaleExplain      = "SaleExplain"
	TypeSku              = "Sku"
	TypeSkuSpec          = "SkuSpec"
	TypeSpecKey          = "SpecKey"
	TypeSpecValue        = "SpecValue"
	TypeSpu              = "Spu"
	TypeSpuDetailImg     = "SpuDetailImg"
	TypeSpuImg           = "SpuImg"
	TypeTag              = "Tag"
	TypeTheme            = "Theme"
	TypeUser             = "User"
	TypeUserCoupon       = "UserCoupon"
	TypeUserFavor        = "UserFavor"
	TypeUserInfo         = "UserInfo"
	TypeUserPoint        = "UserPoint"
	TypeUserPointDetail  = "UserPointDetail"
	TypeUserWallet       = "UserWallet"
	TypeUserWalletDetail = "UserWalletDetail"
)

// ActivityMutation represents an operation that mutates the Activity nodes in the graph.
type ActivityMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	create_time      *time.Time
	update_time      *time.Time
	delete_time      *time.Time
	title            *string
	description      *string
	start_time       *time.Time
	end_time         *time.Time
	remark           *string
	online           *int
	addonline        *int
	entrance_img     *string
	internal_top_img *string
	name             *string
	clearedFields    map[string]struct{}
	spu              map[int64]struct{}
	removedspu       map[int64]struct{}
	clearedspu       bool
	coupon           map[int64]struct{}
	removedcoupon    map[int64]struct{}
	clearedcoupon    bool
	done             bool
	oldValue         func(context.Context) (*Activity, error)
	predicates       []predicate.Activity
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows management of the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for the Activity entity.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the ID field of the mutation.
func withActivityID(id int64) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ActivityMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ActivityMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ActivityMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ActivityMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ActivityMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ActivityMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *ActivityMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *ActivityMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *ActivityMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[activity.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *ActivityMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[activity.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *ActivityMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, activity.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *ActivityMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ActivityMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ActivityMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ActivityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ActivityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ActivityMutation) ResetDescription() {
	m.description = nil
}

// SetStartTime sets the "start_time" field.
func (m *ActivityMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ActivityMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ActivityMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ActivityMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ActivityMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ActivityMutation) ResetEndTime() {
	m.end_time = nil
}

// SetRemark sets the "remark" field.
func (m *ActivityMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ActivityMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *ActivityMutation) ResetRemark() {
	m.remark = nil
}

// SetOnline sets the "online" field.
func (m *ActivityMutation) SetOnline(i int) {
	m.online = &i
	m.addonline = nil
}

// Online returns the value of the "online" field in the mutation.
func (m *ActivityMutation) Online() (r int, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldOnline(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// AddOnline adds i to the "online" field.
func (m *ActivityMutation) AddOnline(i int) {
	if m.addonline != nil {
		*m.addonline += i
	} else {
		m.addonline = &i
	}
}

// AddedOnline returns the value that was added to the "online" field in this mutation.
func (m *ActivityMutation) AddedOnline() (r int, exists bool) {
	v := m.addonline
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnline resets all changes to the "online" field.
func (m *ActivityMutation) ResetOnline() {
	m.online = nil
	m.addonline = nil
}

// SetEntranceImg sets the "entrance_img" field.
func (m *ActivityMutation) SetEntranceImg(s string) {
	m.entrance_img = &s
}

// EntranceImg returns the value of the "entrance_img" field in the mutation.
func (m *ActivityMutation) EntranceImg() (r string, exists bool) {
	v := m.entrance_img
	if v == nil {
		return
	}
	return *v, true
}

// OldEntranceImg returns the old "entrance_img" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldEntranceImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEntranceImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEntranceImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntranceImg: %w", err)
	}
	return oldValue.EntranceImg, nil
}

// ResetEntranceImg resets all changes to the "entrance_img" field.
func (m *ActivityMutation) ResetEntranceImg() {
	m.entrance_img = nil
}

// SetInternalTopImg sets the "internal_top_img" field.
func (m *ActivityMutation) SetInternalTopImg(s string) {
	m.internal_top_img = &s
}

// InternalTopImg returns the value of the "internal_top_img" field in the mutation.
func (m *ActivityMutation) InternalTopImg() (r string, exists bool) {
	v := m.internal_top_img
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalTopImg returns the old "internal_top_img" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldInternalTopImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInternalTopImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInternalTopImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalTopImg: %w", err)
	}
	return oldValue.InternalTopImg, nil
}

// ResetInternalTopImg resets all changes to the "internal_top_img" field.
func (m *ActivityMutation) ResetInternalTopImg() {
	m.internal_top_img = nil
}

// SetName sets the "name" field.
func (m *ActivityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActivityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActivityMutation) ResetName() {
	m.name = nil
}

// AddSpuIDs adds the "spu" edge to the Spu entity by ids.
func (m *ActivityMutation) AddSpuIDs(ids ...int64) {
	if m.spu == nil {
		m.spu = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu[ids[i]] = struct{}{}
	}
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *ActivityMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *ActivityMutation) SpuCleared() bool {
	return m.clearedspu
}

// RemoveSpuIDs removes the "spu" edge to the Spu entity by IDs.
func (m *ActivityMutation) RemoveSpuIDs(ids ...int64) {
	if m.removedspu == nil {
		m.removedspu = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu, ids[i])
		m.removedspu[ids[i]] = struct{}{}
	}
}

// RemovedSpu returns the removed IDs of the "spu" edge to the Spu entity.
func (m *ActivityMutation) RemovedSpuIDs() (ids []int64) {
	for id := range m.removedspu {
		ids = append(ids, id)
	}
	return
}

// SpuIDs returns the "spu" edge IDs in the mutation.
func (m *ActivityMutation) SpuIDs() (ids []int64) {
	for id := range m.spu {
		ids = append(ids, id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *ActivityMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
	m.removedspu = nil
}

// AddCouponIDs adds the "coupon" edge to the Coupon entity by ids.
func (m *ActivityMutation) AddCouponIDs(ids ...int64) {
	if m.coupon == nil {
		m.coupon = make(map[int64]struct{})
	}
	for i := range ids {
		m.coupon[ids[i]] = struct{}{}
	}
}

// ClearCoupon clears the "coupon" edge to the Coupon entity.
func (m *ActivityMutation) ClearCoupon() {
	m.clearedcoupon = true
}

// CouponCleared reports if the "coupon" edge to the Coupon entity was cleared.
func (m *ActivityMutation) CouponCleared() bool {
	return m.clearedcoupon
}

// RemoveCouponIDs removes the "coupon" edge to the Coupon entity by IDs.
func (m *ActivityMutation) RemoveCouponIDs(ids ...int64) {
	if m.removedcoupon == nil {
		m.removedcoupon = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.coupon, ids[i])
		m.removedcoupon[ids[i]] = struct{}{}
	}
}

// RemovedCoupon returns the removed IDs of the "coupon" edge to the Coupon entity.
func (m *ActivityMutation) RemovedCouponIDs() (ids []int64) {
	for id := range m.removedcoupon {
		ids = append(ids, id)
	}
	return
}

// CouponIDs returns the "coupon" edge IDs in the mutation.
func (m *ActivityMutation) CouponIDs() (ids []int64) {
	for id := range m.coupon {
		ids = append(ids, id)
	}
	return
}

// ResetCoupon resets all changes to the "coupon" edge.
func (m *ActivityMutation) ResetCoupon() {
	m.coupon = nil
	m.clearedcoupon = false
	m.removedcoupon = nil
}

// Where appends a list predicates to the ActivityMutation builder.
func (m *ActivityMutation) Where(ps ...predicate.Activity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, activity.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, activity.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, activity.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, activity.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, activity.FieldDescription)
	}
	if m.start_time != nil {
		fields = append(fields, activity.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, activity.FieldEndTime)
	}
	if m.remark != nil {
		fields = append(fields, activity.FieldRemark)
	}
	if m.online != nil {
		fields = append(fields, activity.FieldOnline)
	}
	if m.entrance_img != nil {
		fields = append(fields, activity.FieldEntranceImg)
	}
	if m.internal_top_img != nil {
		fields = append(fields, activity.FieldInternalTopImg)
	}
	if m.name != nil {
		fields = append(fields, activity.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldCreateTime:
		return m.CreateTime()
	case activity.FieldUpdateTime:
		return m.UpdateTime()
	case activity.FieldDeleteTime:
		return m.DeleteTime()
	case activity.FieldTitle:
		return m.Title()
	case activity.FieldDescription:
		return m.Description()
	case activity.FieldStartTime:
		return m.StartTime()
	case activity.FieldEndTime:
		return m.EndTime()
	case activity.FieldRemark:
		return m.Remark()
	case activity.FieldOnline:
		return m.Online()
	case activity.FieldEntranceImg:
		return m.EntranceImg()
	case activity.FieldInternalTopImg:
		return m.InternalTopImg()
	case activity.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case activity.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case activity.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case activity.FieldTitle:
		return m.OldTitle(ctx)
	case activity.FieldDescription:
		return m.OldDescription(ctx)
	case activity.FieldStartTime:
		return m.OldStartTime(ctx)
	case activity.FieldEndTime:
		return m.OldEndTime(ctx)
	case activity.FieldRemark:
		return m.OldRemark(ctx)
	case activity.FieldOnline:
		return m.OldOnline(ctx)
	case activity.FieldEntranceImg:
		return m.OldEntranceImg(ctx)
	case activity.FieldInternalTopImg:
		return m.OldInternalTopImg(ctx)
	case activity.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case activity.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case activity.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case activity.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case activity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case activity.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case activity.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case activity.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case activity.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case activity.FieldEntranceImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntranceImg(v)
		return nil
	case activity.FieldInternalTopImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalTopImg(v)
		return nil
	case activity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityMutation) AddedFields() []string {
	var fields []string
	if m.addonline != nil {
		fields = append(fields, activity.FieldOnline)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldOnline:
		return m.AddedOnline()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activity.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnline(v)
		return nil
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activity.FieldDeleteTime) {
		fields = append(fields, activity.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	switch name {
	case activity.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case activity.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case activity.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case activity.FieldTitle:
		m.ResetTitle()
		return nil
	case activity.FieldDescription:
		m.ResetDescription()
		return nil
	case activity.FieldStartTime:
		m.ResetStartTime()
		return nil
	case activity.FieldEndTime:
		m.ResetEndTime()
		return nil
	case activity.FieldRemark:
		m.ResetRemark()
		return nil
	case activity.FieldOnline:
		m.ResetOnline()
		return nil
	case activity.FieldEntranceImg:
		m.ResetEntranceImg()
		return nil
	case activity.FieldInternalTopImg:
		m.ResetInternalTopImg()
		return nil
	case activity.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.spu != nil {
		edges = append(edges, activity.EdgeSpu)
	}
	if m.coupon != nil {
		edges = append(edges, activity.EdgeCoupon)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.spu))
		for id := range m.spu {
			ids = append(ids, id)
		}
		return ids
	case activity.EdgeCoupon:
		ids := make([]ent.Value, 0, len(m.coupon))
		for id := range m.coupon {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedspu != nil {
		edges = append(edges, activity.EdgeSpu)
	}
	if m.removedcoupon != nil {
		edges = append(edges, activity.EdgeCoupon)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.removedspu))
		for id := range m.removedspu {
			ids = append(ids, id)
		}
		return ids
	case activity.EdgeCoupon:
		ids := make([]ent.Value, 0, len(m.removedcoupon))
		for id := range m.removedcoupon {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedspu {
		edges = append(edges, activity.EdgeSpu)
	}
	if m.clearedcoupon {
		edges = append(edges, activity.EdgeCoupon)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case activity.EdgeSpu:
		return m.clearedspu
	case activity.EdgeCoupon:
		return m.clearedcoupon
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	switch name {
	case activity.EdgeSpu:
		m.ResetSpu()
		return nil
	case activity.EdgeCoupon:
		m.ResetCoupon()
		return nil
	}
	return fmt.Errorf("unknown Activity edge %s", name)
}

// BannerMutation represents an operation that mutates the Banner nodes in the graph.
type BannerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	create_time        *time.Time
	update_time        *time.Time
	delete_time        *time.Time
	name               *string
	description        *string
	title              *string
	img                *string
	clearedFields      map[string]struct{}
	banner_item        map[int64]struct{}
	removedbanner_item map[int64]struct{}
	clearedbanner_item bool
	done               bool
	oldValue           func(context.Context) (*Banner, error)
	predicates         []predicate.Banner
}

var _ ent.Mutation = (*BannerMutation)(nil)

// bannerOption allows management of the mutation configuration using functional options.
type bannerOption func(*BannerMutation)

// newBannerMutation creates new mutation for the Banner entity.
func newBannerMutation(c config, op Op, opts ...bannerOption) *BannerMutation {
	m := &BannerMutation{
		config:        c,
		op:            op,
		typ:           TypeBanner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerID sets the ID field of the mutation.
func withBannerID(id int64) bannerOption {
	return func(m *BannerMutation) {
		var (
			err   error
			once  sync.Once
			value *Banner
		)
		m.oldValue = func(ctx context.Context) (*Banner, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Banner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanner sets the old Banner of the mutation.
func withBanner(node *Banner) bannerOption {
	return func(m *BannerMutation) {
		m.oldValue = func(context.Context) (*Banner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *BannerMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BannerMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BannerMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BannerMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BannerMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BannerMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *BannerMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *BannerMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *BannerMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[banner.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *BannerMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[banner.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *BannerMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, banner.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *BannerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BannerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BannerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BannerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BannerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BannerMutation) ResetDescription() {
	m.description = nil
}

// SetTitle sets the "title" field.
func (m *BannerMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BannerMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BannerMutation) ResetTitle() {
	m.title = nil
}

// SetImg sets the "img" field.
func (m *BannerMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *BannerMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *BannerMutation) ResetImg() {
	m.img = nil
}

// AddBannerItemIDs adds the "banner_item" edge to the BannerItem entity by ids.
func (m *BannerMutation) AddBannerItemIDs(ids ...int64) {
	if m.banner_item == nil {
		m.banner_item = make(map[int64]struct{})
	}
	for i := range ids {
		m.banner_item[ids[i]] = struct{}{}
	}
}

// ClearBannerItem clears the "banner_item" edge to the BannerItem entity.
func (m *BannerMutation) ClearBannerItem() {
	m.clearedbanner_item = true
}

// BannerItemCleared reports if the "banner_item" edge to the BannerItem entity was cleared.
func (m *BannerMutation) BannerItemCleared() bool {
	return m.clearedbanner_item
}

// RemoveBannerItemIDs removes the "banner_item" edge to the BannerItem entity by IDs.
func (m *BannerMutation) RemoveBannerItemIDs(ids ...int64) {
	if m.removedbanner_item == nil {
		m.removedbanner_item = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.banner_item, ids[i])
		m.removedbanner_item[ids[i]] = struct{}{}
	}
}

// RemovedBannerItem returns the removed IDs of the "banner_item" edge to the BannerItem entity.
func (m *BannerMutation) RemovedBannerItemIDs() (ids []int64) {
	for id := range m.removedbanner_item {
		ids = append(ids, id)
	}
	return
}

// BannerItemIDs returns the "banner_item" edge IDs in the mutation.
func (m *BannerMutation) BannerItemIDs() (ids []int64) {
	for id := range m.banner_item {
		ids = append(ids, id)
	}
	return
}

// ResetBannerItem resets all changes to the "banner_item" edge.
func (m *BannerMutation) ResetBannerItem() {
	m.banner_item = nil
	m.clearedbanner_item = false
	m.removedbanner_item = nil
}

// Where appends a list predicates to the BannerMutation builder.
func (m *BannerMutation) Where(ps ...predicate.Banner) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BannerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Banner).
func (m *BannerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, banner.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, banner.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, banner.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, banner.FieldName)
	}
	if m.description != nil {
		fields = append(fields, banner.FieldDescription)
	}
	if m.title != nil {
		fields = append(fields, banner.FieldTitle)
	}
	if m.img != nil {
		fields = append(fields, banner.FieldImg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldCreateTime:
		return m.CreateTime()
	case banner.FieldUpdateTime:
		return m.UpdateTime()
	case banner.FieldDeleteTime:
		return m.DeleteTime()
	case banner.FieldName:
		return m.Name()
	case banner.FieldDescription:
		return m.Description()
	case banner.FieldTitle:
		return m.Title()
	case banner.FieldImg:
		return m.Img()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banner.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case banner.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case banner.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case banner.FieldName:
		return m.OldName(ctx)
	case banner.FieldDescription:
		return m.OldDescription(ctx)
	case banner.FieldTitle:
		return m.OldTitle(ctx)
	case banner.FieldImg:
		return m.OldImg(ctx)
	}
	return nil, fmt.Errorf("unknown Banner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banner.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case banner.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case banner.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case banner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case banner.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case banner.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case banner.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Banner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(banner.FieldDeleteTime) {
		fields = append(fields, banner.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerMutation) ClearField(name string) error {
	switch name {
	case banner.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Banner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerMutation) ResetField(name string) error {
	switch name {
	case banner.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case banner.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case banner.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case banner.FieldName:
		m.ResetName()
		return nil
	case banner.FieldDescription:
		m.ResetDescription()
		return nil
	case banner.FieldTitle:
		m.ResetTitle()
		return nil
	case banner.FieldImg:
		m.ResetImg()
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.banner_item != nil {
		edges = append(edges, banner.EdgeBannerItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case banner.EdgeBannerItem:
		ids := make([]ent.Value, 0, len(m.banner_item))
		for id := range m.banner_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbanner_item != nil {
		edges = append(edges, banner.EdgeBannerItem)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case banner.EdgeBannerItem:
		ids := make([]ent.Value, 0, len(m.removedbanner_item))
		for id := range m.removedbanner_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbanner_item {
		edges = append(edges, banner.EdgeBannerItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerMutation) EdgeCleared(name string) bool {
	switch name {
	case banner.EdgeBannerItem:
		return m.clearedbanner_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Banner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerMutation) ResetEdge(name string) error {
	switch name {
	case banner.EdgeBannerItem:
		m.ResetBannerItem()
		return nil
	}
	return fmt.Errorf("unknown Banner edge %s", name)
}

// BannerItemMutation represents an operation that mutates the BannerItem nodes in the graph.
type BannerItemMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	img           *string
	keyword       *string
	_type         *int
	add_type      *int
	name          *string
	clearedFields map[string]struct{}
	banner        *int64
	clearedbanner bool
	done          bool
	oldValue      func(context.Context) (*BannerItem, error)
	predicates    []predicate.BannerItem
}

var _ ent.Mutation = (*BannerItemMutation)(nil)

// banneritemOption allows management of the mutation configuration using functional options.
type banneritemOption func(*BannerItemMutation)

// newBannerItemMutation creates new mutation for the BannerItem entity.
func newBannerItemMutation(c config, op Op, opts ...banneritemOption) *BannerItemMutation {
	m := &BannerItemMutation{
		config:        c,
		op:            op,
		typ:           TypeBannerItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerItemID sets the ID field of the mutation.
func withBannerItemID(id int64) banneritemOption {
	return func(m *BannerItemMutation) {
		var (
			err   error
			once  sync.Once
			value *BannerItem
		)
		m.oldValue = func(ctx context.Context) (*BannerItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BannerItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBannerItem sets the old BannerItem of the mutation.
func withBannerItem(node *BannerItem) banneritemOption {
	return func(m *BannerItemMutation) {
		m.oldValue = func(context.Context) (*BannerItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerItemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *BannerItemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BannerItemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BannerItemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BannerItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BannerItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BannerItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *BannerItemMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *BannerItemMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *BannerItemMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[banneritem.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *BannerItemMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[banneritem.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *BannerItemMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, banneritem.FieldDeleteTime)
}

// SetImg sets the "img" field.
func (m *BannerItemMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *BannerItemMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *BannerItemMutation) ResetImg() {
	m.img = nil
}

// SetKeyword sets the "keyword" field.
func (m *BannerItemMutation) SetKeyword(s string) {
	m.keyword = &s
}

// Keyword returns the value of the "keyword" field in the mutation.
func (m *BannerItemMutation) Keyword() (r string, exists bool) {
	v := m.keyword
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyword returns the old "keyword" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldKeyword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKeyword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKeyword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyword: %w", err)
	}
	return oldValue.Keyword, nil
}

// ResetKeyword resets all changes to the "keyword" field.
func (m *BannerItemMutation) ResetKeyword() {
	m.keyword = nil
}

// SetType sets the "type" field.
func (m *BannerItemMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *BannerItemMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *BannerItemMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *BannerItemMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *BannerItemMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetBannerID sets the "banner_id" field.
func (m *BannerItemMutation) SetBannerID(i int64) {
	m.banner = &i
}

// BannerID returns the value of the "banner_id" field in the mutation.
func (m *BannerItemMutation) BannerID() (r int64, exists bool) {
	v := m.banner
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerID returns the old "banner_id" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldBannerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBannerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBannerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerID: %w", err)
	}
	return oldValue.BannerID, nil
}

// ClearBannerID clears the value of the "banner_id" field.
func (m *BannerItemMutation) ClearBannerID() {
	m.banner = nil
	m.clearedFields[banneritem.FieldBannerID] = struct{}{}
}

// BannerIDCleared returns if the "banner_id" field was cleared in this mutation.
func (m *BannerItemMutation) BannerIDCleared() bool {
	_, ok := m.clearedFields[banneritem.FieldBannerID]
	return ok
}

// ResetBannerID resets all changes to the "banner_id" field.
func (m *BannerItemMutation) ResetBannerID() {
	m.banner = nil
	delete(m.clearedFields, banneritem.FieldBannerID)
}

// SetName sets the "name" field.
func (m *BannerItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BannerItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BannerItemMutation) ResetName() {
	m.name = nil
}

// ClearBanner clears the "banner" edge to the Banner entity.
func (m *BannerItemMutation) ClearBanner() {
	m.clearedbanner = true
}

// BannerCleared reports if the "banner" edge to the Banner entity was cleared.
func (m *BannerItemMutation) BannerCleared() bool {
	return m.BannerIDCleared() || m.clearedbanner
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *BannerItemMutation) BannerIDs() (ids []int64) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *BannerItemMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// Where appends a list predicates to the BannerItemMutation builder.
func (m *BannerItemMutation) Where(ps ...predicate.BannerItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BannerItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BannerItem).
func (m *BannerItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, banneritem.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, banneritem.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, banneritem.FieldDeleteTime)
	}
	if m.img != nil {
		fields = append(fields, banneritem.FieldImg)
	}
	if m.keyword != nil {
		fields = append(fields, banneritem.FieldKeyword)
	}
	if m._type != nil {
		fields = append(fields, banneritem.FieldType)
	}
	if m.banner != nil {
		fields = append(fields, banneritem.FieldBannerID)
	}
	if m.name != nil {
		fields = append(fields, banneritem.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banneritem.FieldCreateTime:
		return m.CreateTime()
	case banneritem.FieldUpdateTime:
		return m.UpdateTime()
	case banneritem.FieldDeleteTime:
		return m.DeleteTime()
	case banneritem.FieldImg:
		return m.Img()
	case banneritem.FieldKeyword:
		return m.Keyword()
	case banneritem.FieldType:
		return m.GetType()
	case banneritem.FieldBannerID:
		return m.BannerID()
	case banneritem.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banneritem.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case banneritem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case banneritem.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case banneritem.FieldImg:
		return m.OldImg(ctx)
	case banneritem.FieldKeyword:
		return m.OldKeyword(ctx)
	case banneritem.FieldType:
		return m.OldType(ctx)
	case banneritem.FieldBannerID:
		return m.OldBannerID(ctx)
	case banneritem.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown BannerItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banneritem.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case banneritem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case banneritem.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case banneritem.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case banneritem.FieldKeyword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyword(v)
		return nil
	case banneritem.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case banneritem.FieldBannerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerID(v)
		return nil
	case banneritem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown BannerItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerItemMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, banneritem.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banneritem.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banneritem.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown BannerItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(banneritem.FieldDeleteTime) {
		fields = append(fields, banneritem.FieldDeleteTime)
	}
	if m.FieldCleared(banneritem.FieldBannerID) {
		fields = append(fields, banneritem.FieldBannerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerItemMutation) ClearField(name string) error {
	switch name {
	case banneritem.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case banneritem.FieldBannerID:
		m.ClearBannerID()
		return nil
	}
	return fmt.Errorf("unknown BannerItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerItemMutation) ResetField(name string) error {
	switch name {
	case banneritem.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case banneritem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case banneritem.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case banneritem.FieldImg:
		m.ResetImg()
		return nil
	case banneritem.FieldKeyword:
		m.ResetKeyword()
		return nil
	case banneritem.FieldType:
		m.ResetType()
		return nil
	case banneritem.FieldBannerID:
		m.ResetBannerID()
		return nil
	case banneritem.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown BannerItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.banner != nil {
		edges = append(edges, banneritem.EdgeBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case banneritem.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbanner {
		edges = append(edges, banneritem.EdgeBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerItemMutation) EdgeCleared(name string) bool {
	switch name {
	case banneritem.EdgeBanner:
		return m.clearedbanner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerItemMutation) ClearEdge(name string) error {
	switch name {
	case banneritem.EdgeBanner:
		m.ClearBanner()
		return nil
	}
	return fmt.Errorf("unknown BannerItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerItemMutation) ResetEdge(name string) error {
	switch name {
	case banneritem.EdgeBanner:
		m.ResetBanner()
		return nil
	}
	return fmt.Errorf("unknown BannerItem edge %s", name)
}

// BrandMutation represents an operation that mutates the Brand nodes in the graph.
type BrandMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	name          *string
	description   *string
	clearedFields map[string]struct{}
	spu           map[int64]struct{}
	removedspu    map[int64]struct{}
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*Brand, error)
	predicates    []predicate.Brand
}

var _ ent.Mutation = (*BrandMutation)(nil)

// brandOption allows management of the mutation configuration using functional options.
type brandOption func(*BrandMutation)

// newBrandMutation creates new mutation for the Brand entity.
func newBrandMutation(c config, op Op, opts ...brandOption) *BrandMutation {
	m := &BrandMutation{
		config:        c,
		op:            op,
		typ:           TypeBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBrandID sets the ID field of the mutation.
func withBrandID(id int64) brandOption {
	return func(m *BrandMutation) {
		var (
			err   error
			once  sync.Once
			value *Brand
		)
		m.oldValue = func(ctx context.Context) (*Brand, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Brand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBrand sets the old Brand of the mutation.
func withBrand(node *Brand) brandOption {
	return func(m *BrandMutation) {
		m.oldValue = func(context.Context) (*Brand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BrandMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *BrandMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BrandMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BrandMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BrandMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BrandMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BrandMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *BrandMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *BrandMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *BrandMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[brand.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *BrandMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[brand.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *BrandMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, brand.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *BrandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BrandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BrandMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BrandMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BrandMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BrandMutation) ResetDescription() {
	m.description = nil
}

// AddSpuIDs adds the "spu" edge to the Spu entity by ids.
func (m *BrandMutation) AddSpuIDs(ids ...int64) {
	if m.spu == nil {
		m.spu = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu[ids[i]] = struct{}{}
	}
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *BrandMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *BrandMutation) SpuCleared() bool {
	return m.clearedspu
}

// RemoveSpuIDs removes the "spu" edge to the Spu entity by IDs.
func (m *BrandMutation) RemoveSpuIDs(ids ...int64) {
	if m.removedspu == nil {
		m.removedspu = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu, ids[i])
		m.removedspu[ids[i]] = struct{}{}
	}
}

// RemovedSpu returns the removed IDs of the "spu" edge to the Spu entity.
func (m *BrandMutation) RemovedSpuIDs() (ids []int64) {
	for id := range m.removedspu {
		ids = append(ids, id)
	}
	return
}

// SpuIDs returns the "spu" edge IDs in the mutation.
func (m *BrandMutation) SpuIDs() (ids []int64) {
	for id := range m.spu {
		ids = append(ids, id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *BrandMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
	m.removedspu = nil
}

// Where appends a list predicates to the BrandMutation builder.
func (m *BrandMutation) Where(ps ...predicate.Brand) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BrandMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Brand).
func (m *BrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BrandMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, brand.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, brand.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, brand.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, brand.FieldName)
	}
	if m.description != nil {
		fields = append(fields, brand.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case brand.FieldCreateTime:
		return m.CreateTime()
	case brand.FieldUpdateTime:
		return m.UpdateTime()
	case brand.FieldDeleteTime:
		return m.DeleteTime()
	case brand.FieldName:
		return m.Name()
	case brand.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case brand.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case brand.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case brand.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case brand.FieldName:
		return m.OldName(ctx)
	case brand.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Brand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case brand.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case brand.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case brand.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case brand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case brand.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BrandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BrandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BrandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(brand.FieldDeleteTime) {
		fields = append(fields, brand.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BrandMutation) ClearField(name string) error {
	switch name {
	case brand.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Brand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BrandMutation) ResetField(name string) error {
	switch name {
	case brand.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case brand.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case brand.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case brand.FieldName:
		m.ResetName()
		return nil
	case brand.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, brand.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BrandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.spu))
		for id := range m.spu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedspu != nil {
		edges = append(edges, brand.EdgeSpu)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BrandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.removedspu))
		for id := range m.removedspu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, brand.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BrandMutation) EdgeCleared(name string) bool {
	switch name {
	case brand.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BrandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BrandMutation) ResetEdge(name string) error {
	switch name {
	case brand.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown Brand edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	create_time     *time.Time
	update_time     *time.Time
	delete_time     *time.Time
	name            *string
	description     *string
	is_root         *int
	addis_root      *int
	img             *string
	index           *int
	addindex        *int
	online          *int
	addonline       *int
	level           *int
	addlevel        *int
	clearedFields   map[string]struct{}
	coupon          map[int64]struct{}
	removedcoupon   map[int64]struct{}
	clearedcoupon   bool
	parent          *int64
	clearedparent   bool
	children        map[int64]struct{}
	removedchildren map[int64]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*Category, error)
	predicates      []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int64) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *CategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *CategoryMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CategoryMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CategoryMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[category.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CategoryMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[category.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CategoryMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, category.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
}

// SetIsRoot sets the "is_root" field.
func (m *CategoryMutation) SetIsRoot(i int) {
	m.is_root = &i
	m.addis_root = nil
}

// IsRoot returns the value of the "is_root" field in the mutation.
func (m *CategoryMutation) IsRoot() (r int, exists bool) {
	v := m.is_root
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRoot returns the old "is_root" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldIsRoot(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRoot: %w", err)
	}
	return oldValue.IsRoot, nil
}

// AddIsRoot adds i to the "is_root" field.
func (m *CategoryMutation) AddIsRoot(i int) {
	if m.addis_root != nil {
		*m.addis_root += i
	} else {
		m.addis_root = &i
	}
}

// AddedIsRoot returns the value that was added to the "is_root" field in this mutation.
func (m *CategoryMutation) AddedIsRoot() (r int, exists bool) {
	v := m.addis_root
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsRoot resets all changes to the "is_root" field.
func (m *CategoryMutation) ResetIsRoot() {
	m.is_root = nil
	m.addis_root = nil
}

// SetParentID sets the "parent_id" field.
func (m *CategoryMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CategoryMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CategoryMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[category.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CategoryMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, category.FieldParentID)
}

// SetImg sets the "img" field.
func (m *CategoryMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *CategoryMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *CategoryMutation) ResetImg() {
	m.img = nil
}

// SetIndex sets the "index" field.
func (m *CategoryMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *CategoryMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *CategoryMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *CategoryMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *CategoryMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetOnline sets the "online" field.
func (m *CategoryMutation) SetOnline(i int) {
	m.online = &i
	m.addonline = nil
}

// Online returns the value of the "online" field in the mutation.
func (m *CategoryMutation) Online() (r int, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldOnline(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// AddOnline adds i to the "online" field.
func (m *CategoryMutation) AddOnline(i int) {
	if m.addonline != nil {
		*m.addonline += i
	} else {
		m.addonline = &i
	}
}

// AddedOnline returns the value that was added to the "online" field in this mutation.
func (m *CategoryMutation) AddedOnline() (r int, exists bool) {
	v := m.addonline
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnline resets all changes to the "online" field.
func (m *CategoryMutation) ResetOnline() {
	m.online = nil
	m.addonline = nil
}

// SetLevel sets the "level" field.
func (m *CategoryMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CategoryMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *CategoryMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CategoryMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *CategoryMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// AddCouponIDs adds the "coupon" edge to the Coupon entity by ids.
func (m *CategoryMutation) AddCouponIDs(ids ...int64) {
	if m.coupon == nil {
		m.coupon = make(map[int64]struct{})
	}
	for i := range ids {
		m.coupon[ids[i]] = struct{}{}
	}
}

// ClearCoupon clears the "coupon" edge to the Coupon entity.
func (m *CategoryMutation) ClearCoupon() {
	m.clearedcoupon = true
}

// CouponCleared reports if the "coupon" edge to the Coupon entity was cleared.
func (m *CategoryMutation) CouponCleared() bool {
	return m.clearedcoupon
}

// RemoveCouponIDs removes the "coupon" edge to the Coupon entity by IDs.
func (m *CategoryMutation) RemoveCouponIDs(ids ...int64) {
	if m.removedcoupon == nil {
		m.removedcoupon = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.coupon, ids[i])
		m.removedcoupon[ids[i]] = struct{}{}
	}
}

// RemovedCoupon returns the removed IDs of the "coupon" edge to the Coupon entity.
func (m *CategoryMutation) RemovedCouponIDs() (ids []int64) {
	for id := range m.removedcoupon {
		ids = append(ids, id)
	}
	return
}

// CouponIDs returns the "coupon" edge IDs in the mutation.
func (m *CategoryMutation) CouponIDs() (ids []int64) {
	for id := range m.coupon {
		ids = append(ids, id)
	}
	return
}

// ResetCoupon resets all changes to the "coupon" edge.
func (m *CategoryMutation) ResetCoupon() {
	m.coupon = nil
	m.clearedcoupon = false
	m.removedcoupon = nil
}

// ClearParent clears the "parent" edge to the Category entity.
func (m *CategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Category entity was cleared.
func (m *CategoryMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Category entity by ids.
func (m *CategoryMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Category entity.
func (m *CategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Category entity was cleared.
func (m *CategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Category entity by IDs.
func (m *CategoryMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Category entity.
func (m *CategoryMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CategoryMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, category.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, category.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, category.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.is_root != nil {
		fields = append(fields, category.FieldIsRoot)
	}
	if m.parent != nil {
		fields = append(fields, category.FieldParentID)
	}
	if m.img != nil {
		fields = append(fields, category.FieldImg)
	}
	if m.index != nil {
		fields = append(fields, category.FieldIndex)
	}
	if m.online != nil {
		fields = append(fields, category.FieldOnline)
	}
	if m.level != nil {
		fields = append(fields, category.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreateTime:
		return m.CreateTime()
	case category.FieldUpdateTime:
		return m.UpdateTime()
	case category.FieldDeleteTime:
		return m.DeleteTime()
	case category.FieldName:
		return m.Name()
	case category.FieldDescription:
		return m.Description()
	case category.FieldIsRoot:
		return m.IsRoot()
	case category.FieldParentID:
		return m.ParentID()
	case category.FieldImg:
		return m.Img()
	case category.FieldIndex:
		return m.Index()
	case category.FieldOnline:
		return m.Online()
	case category.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case category.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case category.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldIsRoot:
		return m.OldIsRoot(ctx)
	case category.FieldParentID:
		return m.OldParentID(ctx)
	case category.FieldImg:
		return m.OldImg(ctx)
	case category.FieldIndex:
		return m.OldIndex(ctx)
	case category.FieldOnline:
		return m.OldOnline(ctx)
	case category.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case category.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case category.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldIsRoot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRoot(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case category.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case category.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case category.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case category.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addis_root != nil {
		fields = append(fields, category.FieldIsRoot)
	}
	if m.addindex != nil {
		fields = append(fields, category.FieldIndex)
	}
	if m.addonline != nil {
		fields = append(fields, category.FieldOnline)
	}
	if m.addlevel != nil {
		fields = append(fields, category.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldIsRoot:
		return m.AddedIsRoot()
	case category.FieldIndex:
		return m.AddedIndex()
	case category.FieldOnline:
		return m.AddedOnline()
	case category.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldIsRoot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsRoot(v)
		return nil
	case category.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case category.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnline(v)
		return nil
	case category.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldDeleteTime) {
		fields = append(fields, category.FieldDeleteTime)
	}
	if m.FieldCleared(category.FieldParentID) {
		fields = append(fields, category.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case category.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case category.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case category.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldIsRoot:
		m.ResetIsRoot()
		return nil
	case category.FieldParentID:
		m.ResetParentID()
		return nil
	case category.FieldImg:
		m.ResetImg()
		return nil
	case category.FieldIndex:
		m.ResetIndex()
		return nil
	case category.FieldOnline:
		m.ResetOnline()
		return nil
	case category.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.coupon != nil {
		edges = append(edges, category.EdgeCoupon)
	}
	if m.parent != nil {
		edges = append(edges, category.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCoupon:
		ids := make([]ent.Value, 0, len(m.coupon))
		for id := range m.coupon {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcoupon != nil {
		edges = append(edges, category.EdgeCoupon)
	}
	if m.removedchildren != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCoupon:
		ids := make([]ent.Value, 0, len(m.removedcoupon))
		for id := range m.removedcoupon {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcoupon {
		edges = append(edges, category.EdgeCoupon)
	}
	if m.clearedparent {
		edges = append(edges, category.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeCoupon:
		return m.clearedcoupon
	case category.EdgeParent:
		return m.clearedparent
	case category.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeCoupon:
		m.ResetCoupon()
		return nil
	case category.EdgeParent:
		m.ResetParent()
		return nil
	case category.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// ChargeMutation represents an operation that mutates the Charge nodes in the graph.
type ChargeMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	create_time    *time.Time
	update_time    *time.Time
	delete_time    *time.Time
	user_id        *int64
	adduser_id     *int64
	amount         *string
	charge_no      *string
	transaction_id *string
	pay_way        *int
	addpay_way     *int
	client_type    *int
	addclient_type *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Charge, error)
	predicates     []predicate.Charge
}

var _ ent.Mutation = (*ChargeMutation)(nil)

// chargeOption allows management of the mutation configuration using functional options.
type chargeOption func(*ChargeMutation)

// newChargeMutation creates new mutation for the Charge entity.
func newChargeMutation(c config, op Op, opts ...chargeOption) *ChargeMutation {
	m := &ChargeMutation{
		config:        c,
		op:            op,
		typ:           TypeCharge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChargeID sets the ID field of the mutation.
func withChargeID(id int64) chargeOption {
	return func(m *ChargeMutation) {
		var (
			err   error
			once  sync.Once
			value *Charge
		)
		m.oldValue = func(ctx context.Context) (*Charge, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Charge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharge sets the old Charge of the mutation.
func withCharge(node *Charge) chargeOption {
	return func(m *ChargeMutation) {
		m.oldValue = func(context.Context) (*Charge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChargeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChargeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChargeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ChargeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ChargeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ChargeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ChargeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ChargeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ChargeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *ChargeMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *ChargeMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *ChargeMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[charge.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *ChargeMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[charge.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *ChargeMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, charge.FieldDeleteTime)
}

// SetUserID sets the "user_id" field.
func (m *ChargeMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ChargeMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ChargeMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ChargeMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ChargeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetAmount sets the "amount" field.
func (m *ChargeMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ChargeMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *ChargeMutation) ResetAmount() {
	m.amount = nil
}

// SetChargeNo sets the "charge_no" field.
func (m *ChargeMutation) SetChargeNo(s string) {
	m.charge_no = &s
}

// ChargeNo returns the value of the "charge_no" field in the mutation.
func (m *ChargeMutation) ChargeNo() (r string, exists bool) {
	v := m.charge_no
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeNo returns the old "charge_no" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldChargeNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChargeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChargeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeNo: %w", err)
	}
	return oldValue.ChargeNo, nil
}

// ResetChargeNo resets all changes to the "charge_no" field.
func (m *ChargeMutation) ResetChargeNo() {
	m.charge_no = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *ChargeMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *ChargeMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *ChargeMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// SetPayWay sets the "pay_way" field.
func (m *ChargeMutation) SetPayWay(i int) {
	m.pay_way = &i
	m.addpay_way = nil
}

// PayWay returns the value of the "pay_way" field in the mutation.
func (m *ChargeMutation) PayWay() (r int, exists bool) {
	v := m.pay_way
	if v == nil {
		return
	}
	return *v, true
}

// OldPayWay returns the old "pay_way" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldPayWay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayWay: %w", err)
	}
	return oldValue.PayWay, nil
}

// AddPayWay adds i to the "pay_way" field.
func (m *ChargeMutation) AddPayWay(i int) {
	if m.addpay_way != nil {
		*m.addpay_way += i
	} else {
		m.addpay_way = &i
	}
}

// AddedPayWay returns the value that was added to the "pay_way" field in this mutation.
func (m *ChargeMutation) AddedPayWay() (r int, exists bool) {
	v := m.addpay_way
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayWay resets all changes to the "pay_way" field.
func (m *ChargeMutation) ResetPayWay() {
	m.pay_way = nil
	m.addpay_way = nil
}

// SetClientType sets the "client_type" field.
func (m *ChargeMutation) SetClientType(i int) {
	m.client_type = &i
	m.addclient_type = nil
}

// ClientType returns the value of the "client_type" field in the mutation.
func (m *ChargeMutation) ClientType() (r int, exists bool) {
	v := m.client_type
	if v == nil {
		return
	}
	return *v, true
}

// OldClientType returns the old "client_type" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldClientType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClientType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClientType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientType: %w", err)
	}
	return oldValue.ClientType, nil
}

// AddClientType adds i to the "client_type" field.
func (m *ChargeMutation) AddClientType(i int) {
	if m.addclient_type != nil {
		*m.addclient_type += i
	} else {
		m.addclient_type = &i
	}
}

// AddedClientType returns the value that was added to the "client_type" field in this mutation.
func (m *ChargeMutation) AddedClientType() (r int, exists bool) {
	v := m.addclient_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientType resets all changes to the "client_type" field.
func (m *ChargeMutation) ResetClientType() {
	m.client_type = nil
	m.addclient_type = nil
}

// Where appends a list predicates to the ChargeMutation builder.
func (m *ChargeMutation) Where(ps ...predicate.Charge) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChargeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Charge).
func (m *ChargeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChargeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, charge.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, charge.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, charge.FieldDeleteTime)
	}
	if m.user_id != nil {
		fields = append(fields, charge.FieldUserID)
	}
	if m.amount != nil {
		fields = append(fields, charge.FieldAmount)
	}
	if m.charge_no != nil {
		fields = append(fields, charge.FieldChargeNo)
	}
	if m.transaction_id != nil {
		fields = append(fields, charge.FieldTransactionID)
	}
	if m.pay_way != nil {
		fields = append(fields, charge.FieldPayWay)
	}
	if m.client_type != nil {
		fields = append(fields, charge.FieldClientType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChargeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case charge.FieldCreateTime:
		return m.CreateTime()
	case charge.FieldUpdateTime:
		return m.UpdateTime()
	case charge.FieldDeleteTime:
		return m.DeleteTime()
	case charge.FieldUserID:
		return m.UserID()
	case charge.FieldAmount:
		return m.Amount()
	case charge.FieldChargeNo:
		return m.ChargeNo()
	case charge.FieldTransactionID:
		return m.TransactionID()
	case charge.FieldPayWay:
		return m.PayWay()
	case charge.FieldClientType:
		return m.ClientType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChargeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case charge.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case charge.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case charge.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case charge.FieldUserID:
		return m.OldUserID(ctx)
	case charge.FieldAmount:
		return m.OldAmount(ctx)
	case charge.FieldChargeNo:
		return m.OldChargeNo(ctx)
	case charge.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case charge.FieldPayWay:
		return m.OldPayWay(ctx)
	case charge.FieldClientType:
		return m.OldClientType(ctx)
	}
	return nil, fmt.Errorf("unknown Charge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChargeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case charge.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case charge.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case charge.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case charge.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case charge.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case charge.FieldChargeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeNo(v)
		return nil
	case charge.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case charge.FieldPayWay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayWay(v)
		return nil
	case charge.FieldClientType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientType(v)
		return nil
	}
	return fmt.Errorf("unknown Charge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChargeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, charge.FieldUserID)
	}
	if m.addpay_way != nil {
		fields = append(fields, charge.FieldPayWay)
	}
	if m.addclient_type != nil {
		fields = append(fields, charge.FieldClientType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChargeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case charge.FieldUserID:
		return m.AddedUserID()
	case charge.FieldPayWay:
		return m.AddedPayWay()
	case charge.FieldClientType:
		return m.AddedClientType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChargeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case charge.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case charge.FieldPayWay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayWay(v)
		return nil
	case charge.FieldClientType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientType(v)
		return nil
	}
	return fmt.Errorf("unknown Charge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChargeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(charge.FieldDeleteTime) {
		fields = append(fields, charge.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChargeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChargeMutation) ClearField(name string) error {
	switch name {
	case charge.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Charge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChargeMutation) ResetField(name string) error {
	switch name {
	case charge.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case charge.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case charge.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case charge.FieldUserID:
		m.ResetUserID()
		return nil
	case charge.FieldAmount:
		m.ResetAmount()
		return nil
	case charge.FieldChargeNo:
		m.ResetChargeNo()
		return nil
	case charge.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case charge.FieldPayWay:
		m.ResetPayWay()
		return nil
	case charge.FieldClientType:
		m.ResetClientType()
		return nil
	}
	return fmt.Errorf("unknown Charge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChargeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChargeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChargeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChargeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChargeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChargeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChargeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Charge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChargeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Charge edge %s", name)
}

// CouponMutation represents an operation that mutates the Coupon nodes in the graph.
type CouponMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	create_time     *time.Time
	update_time     *time.Time
	delete_time     *time.Time
	title           *string
	start_time      *time.Time
	end_time        *time.Time
	description     *string
	full_money      *float64
	addfull_money   *float64
	minus           *float64
	addminus        *float64
	rate            *float64
	addrate         *float64
	_type           *int
	add_type        *int
	valitiy         *int
	addvalitiy      *int
	activity_id     *int64
	addactivity_id  *int64
	remark          *string
	whole_store     *int
	addwhole_store  *int
	clearedFields   map[string]struct{}
	category        map[int64]struct{}
	removedcategory map[int64]struct{}
	clearedcategory bool
	activity        map[int64]struct{}
	removedactivity map[int64]struct{}
	clearedactivity bool
	done            bool
	oldValue        func(context.Context) (*Coupon, error)
	predicates      []predicate.Coupon
}

var _ ent.Mutation = (*CouponMutation)(nil)

// couponOption allows management of the mutation configuration using functional options.
type couponOption func(*CouponMutation)

// newCouponMutation creates new mutation for the Coupon entity.
func newCouponMutation(c config, op Op, opts ...couponOption) *CouponMutation {
	m := &CouponMutation{
		config:        c,
		op:            op,
		typ:           TypeCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponID sets the ID field of the mutation.
func withCouponID(id int64) couponOption {
	return func(m *CouponMutation) {
		var (
			err   error
			once  sync.Once
			value *Coupon
		)
		m.oldValue = func(ctx context.Context) (*Coupon, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoupon sets the old Coupon of the mutation.
func withCoupon(node *Coupon) couponOption {
	return func(m *CouponMutation) {
		m.oldValue = func(context.Context) (*Coupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *CouponMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CouponMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CouponMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CouponMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CouponMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CouponMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *CouponMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CouponMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CouponMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[coupon.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CouponMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[coupon.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CouponMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, coupon.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *CouponMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CouponMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CouponMutation) ResetTitle() {
	m.title = nil
}

// SetStartTime sets the "start_time" field.
func (m *CouponMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CouponMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CouponMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *CouponMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *CouponMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *CouponMutation) ResetEndTime() {
	m.end_time = nil
}

// SetDescription sets the "description" field.
func (m *CouponMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CouponMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CouponMutation) ResetDescription() {
	m.description = nil
}

// SetFullMoney sets the "full_money" field.
func (m *CouponMutation) SetFullMoney(f float64) {
	m.full_money = &f
	m.addfull_money = nil
}

// FullMoney returns the value of the "full_money" field in the mutation.
func (m *CouponMutation) FullMoney() (r float64, exists bool) {
	v := m.full_money
	if v == nil {
		return
	}
	return *v, true
}

// OldFullMoney returns the old "full_money" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldFullMoney(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFullMoney is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFullMoney requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullMoney: %w", err)
	}
	return oldValue.FullMoney, nil
}

// AddFullMoney adds f to the "full_money" field.
func (m *CouponMutation) AddFullMoney(f float64) {
	if m.addfull_money != nil {
		*m.addfull_money += f
	} else {
		m.addfull_money = &f
	}
}

// AddedFullMoney returns the value that was added to the "full_money" field in this mutation.
func (m *CouponMutation) AddedFullMoney() (r float64, exists bool) {
	v := m.addfull_money
	if v == nil {
		return
	}
	return *v, true
}

// ResetFullMoney resets all changes to the "full_money" field.
func (m *CouponMutation) ResetFullMoney() {
	m.full_money = nil
	m.addfull_money = nil
}

// SetMinus sets the "minus" field.
func (m *CouponMutation) SetMinus(f float64) {
	m.minus = &f
	m.addminus = nil
}

// Minus returns the value of the "minus" field in the mutation.
func (m *CouponMutation) Minus() (r float64, exists bool) {
	v := m.minus
	if v == nil {
		return
	}
	return *v, true
}

// OldMinus returns the old "minus" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldMinus(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMinus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMinus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinus: %w", err)
	}
	return oldValue.Minus, nil
}

// AddMinus adds f to the "minus" field.
func (m *CouponMutation) AddMinus(f float64) {
	if m.addminus != nil {
		*m.addminus += f
	} else {
		m.addminus = &f
	}
}

// AddedMinus returns the value that was added to the "minus" field in this mutation.
func (m *CouponMutation) AddedMinus() (r float64, exists bool) {
	v := m.addminus
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinus resets all changes to the "minus" field.
func (m *CouponMutation) ResetMinus() {
	m.minus = nil
	m.addminus = nil
}

// SetRate sets the "rate" field.
func (m *CouponMutation) SetRate(f float64) {
	m.rate = &f
	m.addrate = nil
}

// Rate returns the value of the "rate" field in the mutation.
func (m *CouponMutation) Rate() (r float64, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// AddRate adds f to the "rate" field.
func (m *CouponMutation) AddRate(f float64) {
	if m.addrate != nil {
		*m.addrate += f
	} else {
		m.addrate = &f
	}
}

// AddedRate returns the value that was added to the "rate" field in this mutation.
func (m *CouponMutation) AddedRate() (r float64, exists bool) {
	v := m.addrate
	if v == nil {
		return
	}
	return *v, true
}

// ResetRate resets all changes to the "rate" field.
func (m *CouponMutation) ResetRate() {
	m.rate = nil
	m.addrate = nil
}

// SetType sets the "type" field.
func (m *CouponMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *CouponMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *CouponMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *CouponMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *CouponMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetValitiy sets the "valitiy" field.
func (m *CouponMutation) SetValitiy(i int) {
	m.valitiy = &i
	m.addvalitiy = nil
}

// Valitiy returns the value of the "valitiy" field in the mutation.
func (m *CouponMutation) Valitiy() (r int, exists bool) {
	v := m.valitiy
	if v == nil {
		return
	}
	return *v, true
}

// OldValitiy returns the old "valitiy" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldValitiy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValitiy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValitiy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValitiy: %w", err)
	}
	return oldValue.Valitiy, nil
}

// AddValitiy adds i to the "valitiy" field.
func (m *CouponMutation) AddValitiy(i int) {
	if m.addvalitiy != nil {
		*m.addvalitiy += i
	} else {
		m.addvalitiy = &i
	}
}

// AddedValitiy returns the value that was added to the "valitiy" field in this mutation.
func (m *CouponMutation) AddedValitiy() (r int, exists bool) {
	v := m.addvalitiy
	if v == nil {
		return
	}
	return *v, true
}

// ResetValitiy resets all changes to the "valitiy" field.
func (m *CouponMutation) ResetValitiy() {
	m.valitiy = nil
	m.addvalitiy = nil
}

// SetActivityID sets the "activity_id" field.
func (m *CouponMutation) SetActivityID(i int64) {
	m.activity_id = &i
	m.addactivity_id = nil
}

// ActivityID returns the value of the "activity_id" field in the mutation.
func (m *CouponMutation) ActivityID() (r int64, exists bool) {
	v := m.activity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityID returns the old "activity_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldActivityID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityID: %w", err)
	}
	return oldValue.ActivityID, nil
}

// AddActivityID adds i to the "activity_id" field.
func (m *CouponMutation) AddActivityID(i int64) {
	if m.addactivity_id != nil {
		*m.addactivity_id += i
	} else {
		m.addactivity_id = &i
	}
}

// AddedActivityID returns the value that was added to the "activity_id" field in this mutation.
func (m *CouponMutation) AddedActivityID() (r int64, exists bool) {
	v := m.addactivity_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearActivityID clears the value of the "activity_id" field.
func (m *CouponMutation) ClearActivityID() {
	m.activity_id = nil
	m.addactivity_id = nil
	m.clearedFields[coupon.FieldActivityID] = struct{}{}
}

// ActivityIDCleared returns if the "activity_id" field was cleared in this mutation.
func (m *CouponMutation) ActivityIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldActivityID]
	return ok
}

// ResetActivityID resets all changes to the "activity_id" field.
func (m *CouponMutation) ResetActivityID() {
	m.activity_id = nil
	m.addactivity_id = nil
	delete(m.clearedFields, coupon.FieldActivityID)
}

// SetRemark sets the "remark" field.
func (m *CouponMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CouponMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *CouponMutation) ResetRemark() {
	m.remark = nil
}

// SetWholeStore sets the "whole_store" field.
func (m *CouponMutation) SetWholeStore(i int) {
	m.whole_store = &i
	m.addwhole_store = nil
}

// WholeStore returns the value of the "whole_store" field in the mutation.
func (m *CouponMutation) WholeStore() (r int, exists bool) {
	v := m.whole_store
	if v == nil {
		return
	}
	return *v, true
}

// OldWholeStore returns the old "whole_store" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldWholeStore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWholeStore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWholeStore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWholeStore: %w", err)
	}
	return oldValue.WholeStore, nil
}

// AddWholeStore adds i to the "whole_store" field.
func (m *CouponMutation) AddWholeStore(i int) {
	if m.addwhole_store != nil {
		*m.addwhole_store += i
	} else {
		m.addwhole_store = &i
	}
}

// AddedWholeStore returns the value that was added to the "whole_store" field in this mutation.
func (m *CouponMutation) AddedWholeStore() (r int, exists bool) {
	v := m.addwhole_store
	if v == nil {
		return
	}
	return *v, true
}

// ResetWholeStore resets all changes to the "whole_store" field.
func (m *CouponMutation) ResetWholeStore() {
	m.whole_store = nil
	m.addwhole_store = nil
}

// AddCategoryIDs adds the "category" edge to the Category entity by ids.
func (m *CouponMutation) AddCategoryIDs(ids ...int64) {
	if m.category == nil {
		m.category = make(map[int64]struct{})
	}
	for i := range ids {
		m.category[ids[i]] = struct{}{}
	}
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *CouponMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *CouponMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// RemoveCategoryIDs removes the "category" edge to the Category entity by IDs.
func (m *CouponMutation) RemoveCategoryIDs(ids ...int64) {
	if m.removedcategory == nil {
		m.removedcategory = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.category, ids[i])
		m.removedcategory[ids[i]] = struct{}{}
	}
}

// RemovedCategory returns the removed IDs of the "category" edge to the Category entity.
func (m *CouponMutation) RemovedCategoryIDs() (ids []int64) {
	for id := range m.removedcategory {
		ids = append(ids, id)
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
func (m *CouponMutation) CategoryIDs() (ids []int64) {
	for id := range m.category {
		ids = append(ids, id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *CouponMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
	m.removedcategory = nil
}

// AddActivityIDs adds the "activity" edge to the Activity entity by ids.
func (m *CouponMutation) AddActivityIDs(ids ...int64) {
	if m.activity == nil {
		m.activity = make(map[int64]struct{})
	}
	for i := range ids {
		m.activity[ids[i]] = struct{}{}
	}
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *CouponMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *CouponMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// RemoveActivityIDs removes the "activity" edge to the Activity entity by IDs.
func (m *CouponMutation) RemoveActivityIDs(ids ...int64) {
	if m.removedactivity == nil {
		m.removedactivity = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.activity, ids[i])
		m.removedactivity[ids[i]] = struct{}{}
	}
}

// RemovedActivity returns the removed IDs of the "activity" edge to the Activity entity.
func (m *CouponMutation) RemovedActivityIDs() (ids []int64) {
	for id := range m.removedactivity {
		ids = append(ids, id)
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
func (m *CouponMutation) ActivityIDs() (ids []int64) {
	for id := range m.activity {
		ids = append(ids, id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *CouponMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
	m.removedactivity = nil
}

// Where appends a list predicates to the CouponMutation builder.
func (m *CouponMutation) Where(ps ...predicate.Coupon) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Coupon).
func (m *CouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.create_time != nil {
		fields = append(fields, coupon.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, coupon.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, coupon.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, coupon.FieldTitle)
	}
	if m.start_time != nil {
		fields = append(fields, coupon.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, coupon.FieldEndTime)
	}
	if m.description != nil {
		fields = append(fields, coupon.FieldDescription)
	}
	if m.full_money != nil {
		fields = append(fields, coupon.FieldFullMoney)
	}
	if m.minus != nil {
		fields = append(fields, coupon.FieldMinus)
	}
	if m.rate != nil {
		fields = append(fields, coupon.FieldRate)
	}
	if m._type != nil {
		fields = append(fields, coupon.FieldType)
	}
	if m.valitiy != nil {
		fields = append(fields, coupon.FieldValitiy)
	}
	if m.activity_id != nil {
		fields = append(fields, coupon.FieldActivityID)
	}
	if m.remark != nil {
		fields = append(fields, coupon.FieldRemark)
	}
	if m.whole_store != nil {
		fields = append(fields, coupon.FieldWholeStore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldCreateTime:
		return m.CreateTime()
	case coupon.FieldUpdateTime:
		return m.UpdateTime()
	case coupon.FieldDeleteTime:
		return m.DeleteTime()
	case coupon.FieldTitle:
		return m.Title()
	case coupon.FieldStartTime:
		return m.StartTime()
	case coupon.FieldEndTime:
		return m.EndTime()
	case coupon.FieldDescription:
		return m.Description()
	case coupon.FieldFullMoney:
		return m.FullMoney()
	case coupon.FieldMinus:
		return m.Minus()
	case coupon.FieldRate:
		return m.Rate()
	case coupon.FieldType:
		return m.GetType()
	case coupon.FieldValitiy:
		return m.Valitiy()
	case coupon.FieldActivityID:
		return m.ActivityID()
	case coupon.FieldRemark:
		return m.Remark()
	case coupon.FieldWholeStore:
		return m.WholeStore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupon.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case coupon.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case coupon.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case coupon.FieldTitle:
		return m.OldTitle(ctx)
	case coupon.FieldStartTime:
		return m.OldStartTime(ctx)
	case coupon.FieldEndTime:
		return m.OldEndTime(ctx)
	case coupon.FieldDescription:
		return m.OldDescription(ctx)
	case coupon.FieldFullMoney:
		return m.OldFullMoney(ctx)
	case coupon.FieldMinus:
		return m.OldMinus(ctx)
	case coupon.FieldRate:
		return m.OldRate(ctx)
	case coupon.FieldType:
		return m.OldType(ctx)
	case coupon.FieldValitiy:
		return m.OldValitiy(ctx)
	case coupon.FieldActivityID:
		return m.OldActivityID(ctx)
	case coupon.FieldRemark:
		return m.OldRemark(ctx)
	case coupon.FieldWholeStore:
		return m.OldWholeStore(ctx)
	}
	return nil, fmt.Errorf("unknown Coupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case coupon.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case coupon.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case coupon.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case coupon.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case coupon.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case coupon.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case coupon.FieldFullMoney:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullMoney(v)
		return nil
	case coupon.FieldMinus:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinus(v)
		return nil
	case coupon.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case coupon.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case coupon.FieldValitiy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValitiy(v)
		return nil
	case coupon.FieldActivityID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityID(v)
		return nil
	case coupon.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case coupon.FieldWholeStore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWholeStore(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponMutation) AddedFields() []string {
	var fields []string
	if m.addfull_money != nil {
		fields = append(fields, coupon.FieldFullMoney)
	}
	if m.addminus != nil {
		fields = append(fields, coupon.FieldMinus)
	}
	if m.addrate != nil {
		fields = append(fields, coupon.FieldRate)
	}
	if m.add_type != nil {
		fields = append(fields, coupon.FieldType)
	}
	if m.addvalitiy != nil {
		fields = append(fields, coupon.FieldValitiy)
	}
	if m.addactivity_id != nil {
		fields = append(fields, coupon.FieldActivityID)
	}
	if m.addwhole_store != nil {
		fields = append(fields, coupon.FieldWholeStore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldFullMoney:
		return m.AddedFullMoney()
	case coupon.FieldMinus:
		return m.AddedMinus()
	case coupon.FieldRate:
		return m.AddedRate()
	case coupon.FieldType:
		return m.AddedType()
	case coupon.FieldValitiy:
		return m.AddedValitiy()
	case coupon.FieldActivityID:
		return m.AddedActivityID()
	case coupon.FieldWholeStore:
		return m.AddedWholeStore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldFullMoney:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFullMoney(v)
		return nil
	case coupon.FieldMinus:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinus(v)
		return nil
	case coupon.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRate(v)
		return nil
	case coupon.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case coupon.FieldValitiy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValitiy(v)
		return nil
	case coupon.FieldActivityID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActivityID(v)
		return nil
	case coupon.FieldWholeStore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWholeStore(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupon.FieldDeleteTime) {
		fields = append(fields, coupon.FieldDeleteTime)
	}
	if m.FieldCleared(coupon.FieldActivityID) {
		fields = append(fields, coupon.FieldActivityID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponMutation) ClearField(name string) error {
	switch name {
	case coupon.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case coupon.FieldActivityID:
		m.ClearActivityID()
		return nil
	}
	return fmt.Errorf("unknown Coupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponMutation) ResetField(name string) error {
	switch name {
	case coupon.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case coupon.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case coupon.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case coupon.FieldTitle:
		m.ResetTitle()
		return nil
	case coupon.FieldStartTime:
		m.ResetStartTime()
		return nil
	case coupon.FieldEndTime:
		m.ResetEndTime()
		return nil
	case coupon.FieldDescription:
		m.ResetDescription()
		return nil
	case coupon.FieldFullMoney:
		m.ResetFullMoney()
		return nil
	case coupon.FieldMinus:
		m.ResetMinus()
		return nil
	case coupon.FieldRate:
		m.ResetRate()
		return nil
	case coupon.FieldType:
		m.ResetType()
		return nil
	case coupon.FieldValitiy:
		m.ResetValitiy()
		return nil
	case coupon.FieldActivityID:
		m.ResetActivityID()
		return nil
	case coupon.FieldRemark:
		m.ResetRemark()
		return nil
	case coupon.FieldWholeStore:
		m.ResetWholeStore()
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.category != nil {
		edges = append(edges, coupon.EdgeCategory)
	}
	if m.activity != nil {
		edges = append(edges, coupon.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coupon.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.category))
		for id := range m.category {
			ids = append(ids, id)
		}
		return ids
	case coupon.EdgeActivity:
		ids := make([]ent.Value, 0, len(m.activity))
		for id := range m.activity {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcategory != nil {
		edges = append(edges, coupon.EdgeCategory)
	}
	if m.removedactivity != nil {
		edges = append(edges, coupon.EdgeActivity)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case coupon.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.removedcategory))
		for id := range m.removedcategory {
			ids = append(ids, id)
		}
		return ids
	case coupon.EdgeActivity:
		ids := make([]ent.Value, 0, len(m.removedactivity))
		for id := range m.removedactivity {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcategory {
		edges = append(edges, coupon.EdgeCategory)
	}
	if m.clearedactivity {
		edges = append(edges, coupon.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponMutation) EdgeCleared(name string) bool {
	switch name {
	case coupon.EdgeCategory:
		return m.clearedcategory
	case coupon.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Coupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponMutation) ResetEdge(name string) error {
	switch name {
	case coupon.EdgeCategory:
		m.ResetCategory()
		return nil
	case coupon.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown Coupon edge %s", name)
}

// CouponTemplateMutation represents an operation that mutates the CouponTemplate nodes in the graph.
type CouponTemplateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	title         *string
	description   *string
	full_money    *float64
	addfull_money *float64
	minus         *float64
	addminus      *float64
	discount      *float64
	adddiscount   *float64
	_type         *int
	add_type      *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CouponTemplate, error)
	predicates    []predicate.CouponTemplate
}

var _ ent.Mutation = (*CouponTemplateMutation)(nil)

// coupontemplateOption allows management of the mutation configuration using functional options.
type coupontemplateOption func(*CouponTemplateMutation)

// newCouponTemplateMutation creates new mutation for the CouponTemplate entity.
func newCouponTemplateMutation(c config, op Op, opts ...coupontemplateOption) *CouponTemplateMutation {
	m := &CouponTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponTemplateID sets the ID field of the mutation.
func withCouponTemplateID(id int64) coupontemplateOption {
	return func(m *CouponTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponTemplate
		)
		m.oldValue = func(ctx context.Context) (*CouponTemplate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponTemplate sets the old CouponTemplate of the mutation.
func withCouponTemplate(node *CouponTemplate) coupontemplateOption {
	return func(m *CouponTemplateMutation) {
		m.oldValue = func(context.Context) (*CouponTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponTemplateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *CouponTemplateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CouponTemplateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CouponTemplateMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CouponTemplateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CouponTemplateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CouponTemplateMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *CouponTemplateMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CouponTemplateMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CouponTemplateMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[coupontemplate.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CouponTemplateMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[coupontemplate.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CouponTemplateMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, coupontemplate.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *CouponTemplateMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CouponTemplateMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CouponTemplateMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *CouponTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CouponTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CouponTemplateMutation) ResetDescription() {
	m.description = nil
}

// SetFullMoney sets the "full_money" field.
func (m *CouponTemplateMutation) SetFullMoney(f float64) {
	m.full_money = &f
	m.addfull_money = nil
}

// FullMoney returns the value of the "full_money" field in the mutation.
func (m *CouponTemplateMutation) FullMoney() (r float64, exists bool) {
	v := m.full_money
	if v == nil {
		return
	}
	return *v, true
}

// OldFullMoney returns the old "full_money" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldFullMoney(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFullMoney is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFullMoney requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullMoney: %w", err)
	}
	return oldValue.FullMoney, nil
}

// AddFullMoney adds f to the "full_money" field.
func (m *CouponTemplateMutation) AddFullMoney(f float64) {
	if m.addfull_money != nil {
		*m.addfull_money += f
	} else {
		m.addfull_money = &f
	}
}

// AddedFullMoney returns the value that was added to the "full_money" field in this mutation.
func (m *CouponTemplateMutation) AddedFullMoney() (r float64, exists bool) {
	v := m.addfull_money
	if v == nil {
		return
	}
	return *v, true
}

// ResetFullMoney resets all changes to the "full_money" field.
func (m *CouponTemplateMutation) ResetFullMoney() {
	m.full_money = nil
	m.addfull_money = nil
}

// SetMinus sets the "minus" field.
func (m *CouponTemplateMutation) SetMinus(f float64) {
	m.minus = &f
	m.addminus = nil
}

// Minus returns the value of the "minus" field in the mutation.
func (m *CouponTemplateMutation) Minus() (r float64, exists bool) {
	v := m.minus
	if v == nil {
		return
	}
	return *v, true
}

// OldMinus returns the old "minus" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldMinus(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMinus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMinus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinus: %w", err)
	}
	return oldValue.Minus, nil
}

// AddMinus adds f to the "minus" field.
func (m *CouponTemplateMutation) AddMinus(f float64) {
	if m.addminus != nil {
		*m.addminus += f
	} else {
		m.addminus = &f
	}
}

// AddedMinus returns the value that was added to the "minus" field in this mutation.
func (m *CouponTemplateMutation) AddedMinus() (r float64, exists bool) {
	v := m.addminus
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinus resets all changes to the "minus" field.
func (m *CouponTemplateMutation) ResetMinus() {
	m.minus = nil
	m.addminus = nil
}

// SetDiscount sets the "discount" field.
func (m *CouponTemplateMutation) SetDiscount(f float64) {
	m.discount = &f
	m.adddiscount = nil
}

// Discount returns the value of the "discount" field in the mutation.
func (m *CouponTemplateMutation) Discount() (r float64, exists bool) {
	v := m.discount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscount returns the old "discount" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldDiscount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscount: %w", err)
	}
	return oldValue.Discount, nil
}

// AddDiscount adds f to the "discount" field.
func (m *CouponTemplateMutation) AddDiscount(f float64) {
	if m.adddiscount != nil {
		*m.adddiscount += f
	} else {
		m.adddiscount = &f
	}
}

// AddedDiscount returns the value that was added to the "discount" field in this mutation.
func (m *CouponTemplateMutation) AddedDiscount() (r float64, exists bool) {
	v := m.adddiscount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscount resets all changes to the "discount" field.
func (m *CouponTemplateMutation) ResetDiscount() {
	m.discount = nil
	m.adddiscount = nil
}

// SetType sets the "type" field.
func (m *CouponTemplateMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *CouponTemplateMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *CouponTemplateMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *CouponTemplateMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *CouponTemplateMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// Where appends a list predicates to the CouponTemplateMutation builder.
func (m *CouponTemplateMutation) Where(ps ...predicate.CouponTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponTemplateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CouponTemplate).
func (m *CouponTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponTemplateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, coupontemplate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, coupontemplate.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, coupontemplate.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, coupontemplate.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, coupontemplate.FieldDescription)
	}
	if m.full_money != nil {
		fields = append(fields, coupontemplate.FieldFullMoney)
	}
	if m.minus != nil {
		fields = append(fields, coupontemplate.FieldMinus)
	}
	if m.discount != nil {
		fields = append(fields, coupontemplate.FieldDiscount)
	}
	if m._type != nil {
		fields = append(fields, coupontemplate.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupontemplate.FieldCreateTime:
		return m.CreateTime()
	case coupontemplate.FieldUpdateTime:
		return m.UpdateTime()
	case coupontemplate.FieldDeleteTime:
		return m.DeleteTime()
	case coupontemplate.FieldTitle:
		return m.Title()
	case coupontemplate.FieldDescription:
		return m.Description()
	case coupontemplate.FieldFullMoney:
		return m.FullMoney()
	case coupontemplate.FieldMinus:
		return m.Minus()
	case coupontemplate.FieldDiscount:
		return m.Discount()
	case coupontemplate.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupontemplate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case coupontemplate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case coupontemplate.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case coupontemplate.FieldTitle:
		return m.OldTitle(ctx)
	case coupontemplate.FieldDescription:
		return m.OldDescription(ctx)
	case coupontemplate.FieldFullMoney:
		return m.OldFullMoney(ctx)
	case coupontemplate.FieldMinus:
		return m.OldMinus(ctx)
	case coupontemplate.FieldDiscount:
		return m.OldDiscount(ctx)
	case coupontemplate.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown CouponTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupontemplate.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case coupontemplate.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case coupontemplate.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case coupontemplate.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case coupontemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case coupontemplate.FieldFullMoney:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullMoney(v)
		return nil
	case coupontemplate.FieldMinus:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinus(v)
		return nil
	case coupontemplate.FieldDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscount(v)
		return nil
	case coupontemplate.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponTemplateMutation) AddedFields() []string {
	var fields []string
	if m.addfull_money != nil {
		fields = append(fields, coupontemplate.FieldFullMoney)
	}
	if m.addminus != nil {
		fields = append(fields, coupontemplate.FieldMinus)
	}
	if m.adddiscount != nil {
		fields = append(fields, coupontemplate.FieldDiscount)
	}
	if m.add_type != nil {
		fields = append(fields, coupontemplate.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupontemplate.FieldFullMoney:
		return m.AddedFullMoney()
	case coupontemplate.FieldMinus:
		return m.AddedMinus()
	case coupontemplate.FieldDiscount:
		return m.AddedDiscount()
	case coupontemplate.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupontemplate.FieldFullMoney:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFullMoney(v)
		return nil
	case coupontemplate.FieldMinus:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinus(v)
		return nil
	case coupontemplate.FieldDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscount(v)
		return nil
	case coupontemplate.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupontemplate.FieldDeleteTime) {
		fields = append(fields, coupontemplate.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponTemplateMutation) ClearField(name string) error {
	switch name {
	case coupontemplate.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponTemplateMutation) ResetField(name string) error {
	switch name {
	case coupontemplate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case coupontemplate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case coupontemplate.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case coupontemplate.FieldTitle:
		m.ResetTitle()
		return nil
	case coupontemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case coupontemplate.FieldFullMoney:
		m.ResetFullMoney()
		return nil
	case coupontemplate.FieldMinus:
		m.ResetMinus()
		return nil
	case coupontemplate.FieldDiscount:
		m.ResetDiscount()
		return nil
	case coupontemplate.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponTemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponTemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponTemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponTemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponTemplate edge %s", name)
}

// CouponTypeMutation represents an operation that mutates the CouponType nodes in the graph.
type CouponTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	name          *string
	code          *int
	addcode       *int
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CouponType, error)
	predicates    []predicate.CouponType
}

var _ ent.Mutation = (*CouponTypeMutation)(nil)

// coupontypeOption allows management of the mutation configuration using functional options.
type coupontypeOption func(*CouponTypeMutation)

// newCouponTypeMutation creates new mutation for the CouponType entity.
func newCouponTypeMutation(c config, op Op, opts ...coupontypeOption) *CouponTypeMutation {
	m := &CouponTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponTypeID sets the ID field of the mutation.
func withCouponTypeID(id int64) coupontypeOption {
	return func(m *CouponTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponType
		)
		m.oldValue = func(ctx context.Context) (*CouponType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponType sets the old CouponType of the mutation.
func withCouponType(node *CouponType) coupontypeOption {
	return func(m *CouponTypeMutation) {
		m.oldValue = func(context.Context) (*CouponType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *CouponTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CouponTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CouponTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CouponTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CouponTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CouponTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *CouponTypeMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CouponTypeMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CouponTypeMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[coupontype.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CouponTypeMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[coupontype.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CouponTypeMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, coupontype.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *CouponTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CouponTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CouponTypeMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *CouponTypeMutation) SetCode(i int) {
	m.code = &i
	m.addcode = nil
}

// Code returns the value of the "code" field in the mutation.
func (m *CouponTypeMutation) Code() (r int, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// AddCode adds i to the "code" field.
func (m *CouponTypeMutation) AddCode(i int) {
	if m.addcode != nil {
		*m.addcode += i
	} else {
		m.addcode = &i
	}
}

// AddedCode returns the value that was added to the "code" field in this mutation.
func (m *CouponTypeMutation) AddedCode() (r int, exists bool) {
	v := m.addcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetCode resets all changes to the "code" field.
func (m *CouponTypeMutation) ResetCode() {
	m.code = nil
	m.addcode = nil
}

// SetDescription sets the "description" field.
func (m *CouponTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CouponTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CouponTypeMutation) ResetDescription() {
	m.description = nil
}

// Where appends a list predicates to the CouponTypeMutation builder.
func (m *CouponTypeMutation) Where(ps ...predicate.CouponType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CouponType).
func (m *CouponTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, coupontype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, coupontype.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, coupontype.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, coupontype.FieldName)
	}
	if m.code != nil {
		fields = append(fields, coupontype.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, coupontype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupontype.FieldCreateTime:
		return m.CreateTime()
	case coupontype.FieldUpdateTime:
		return m.UpdateTime()
	case coupontype.FieldDeleteTime:
		return m.DeleteTime()
	case coupontype.FieldName:
		return m.Name()
	case coupontype.FieldCode:
		return m.Code()
	case coupontype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupontype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case coupontype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case coupontype.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case coupontype.FieldName:
		return m.OldName(ctx)
	case coupontype.FieldCode:
		return m.OldCode(ctx)
	case coupontype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CouponType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupontype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case coupontype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case coupontype.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case coupontype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coupontype.FieldCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case coupontype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CouponType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponTypeMutation) AddedFields() []string {
	var fields []string
	if m.addcode != nil {
		fields = append(fields, coupontype.FieldCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupontype.FieldCode:
		return m.AddedCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupontype.FieldCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCode(v)
		return nil
	}
	return fmt.Errorf("unknown CouponType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupontype.FieldDeleteTime) {
		fields = append(fields, coupontype.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponTypeMutation) ClearField(name string) error {
	switch name {
	case coupontype.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown CouponType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponTypeMutation) ResetField(name string) error {
	switch name {
	case coupontype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case coupontype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case coupontype.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case coupontype.FieldName:
		m.ResetName()
		return nil
	case coupontype.FieldCode:
		m.ResetCode()
		return nil
	case coupontype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CouponType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponType edge %s", name)
}

// GridCategoryMutation represents an operation that mutates the GridCategory nodes in the graph.
type GridCategoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	create_time         *time.Time
	update_time         *time.Time
	delete_time         *time.Time
	title               *string
	img                 *string
	name                *string
	category_id         *int
	addcategory_id      *int
	root_category_id    *int
	addroot_category_id *int
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*GridCategory, error)
	predicates          []predicate.GridCategory
}

var _ ent.Mutation = (*GridCategoryMutation)(nil)

// gridcategoryOption allows management of the mutation configuration using functional options.
type gridcategoryOption func(*GridCategoryMutation)

// newGridCategoryMutation creates new mutation for the GridCategory entity.
func newGridCategoryMutation(c config, op Op, opts ...gridcategoryOption) *GridCategoryMutation {
	m := &GridCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGridCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGridCategoryID sets the ID field of the mutation.
func withGridCategoryID(id int64) gridcategoryOption {
	return func(m *GridCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GridCategory
		)
		m.oldValue = func(ctx context.Context) (*GridCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GridCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGridCategory sets the old GridCategory of the mutation.
func withGridCategory(node *GridCategory) gridcategoryOption {
	return func(m *GridCategoryMutation) {
		m.oldValue = func(context.Context) (*GridCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GridCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GridCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GridCategoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *GridCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *GridCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *GridCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *GridCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *GridCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *GridCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *GridCategoryMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *GridCategoryMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *GridCategoryMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[gridcategory.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *GridCategoryMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[gridcategory.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *GridCategoryMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, gridcategory.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *GridCategoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GridCategoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *GridCategoryMutation) ResetTitle() {
	m.title = nil
}

// SetImg sets the "img" field.
func (m *GridCategoryMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *GridCategoryMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *GridCategoryMutation) ResetImg() {
	m.img = nil
}

// SetName sets the "name" field.
func (m *GridCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GridCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GridCategoryMutation) ResetName() {
	m.name = nil
}

// SetCategoryID sets the "category_id" field.
func (m *GridCategoryMutation) SetCategoryID(i int) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *GridCategoryMutation) CategoryID() (r int, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *GridCategoryMutation) AddCategoryID(i int) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *GridCategoryMutation) AddedCategoryID() (r int, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *GridCategoryMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// SetRootCategoryID sets the "root_category_id" field.
func (m *GridCategoryMutation) SetRootCategoryID(i int) {
	m.root_category_id = &i
	m.addroot_category_id = nil
}

// RootCategoryID returns the value of the "root_category_id" field in the mutation.
func (m *GridCategoryMutation) RootCategoryID() (r int, exists bool) {
	v := m.root_category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootCategoryID returns the old "root_category_id" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldRootCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRootCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRootCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootCategoryID: %w", err)
	}
	return oldValue.RootCategoryID, nil
}

// AddRootCategoryID adds i to the "root_category_id" field.
func (m *GridCategoryMutation) AddRootCategoryID(i int) {
	if m.addroot_category_id != nil {
		*m.addroot_category_id += i
	} else {
		m.addroot_category_id = &i
	}
}

// AddedRootCategoryID returns the value that was added to the "root_category_id" field in this mutation.
func (m *GridCategoryMutation) AddedRootCategoryID() (r int, exists bool) {
	v := m.addroot_category_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRootCategoryID resets all changes to the "root_category_id" field.
func (m *GridCategoryMutation) ResetRootCategoryID() {
	m.root_category_id = nil
	m.addroot_category_id = nil
}

// Where appends a list predicates to the GridCategoryMutation builder.
func (m *GridCategoryMutation) Where(ps ...predicate.GridCategory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GridCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GridCategory).
func (m *GridCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GridCategoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, gridcategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, gridcategory.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, gridcategory.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, gridcategory.FieldTitle)
	}
	if m.img != nil {
		fields = append(fields, gridcategory.FieldImg)
	}
	if m.name != nil {
		fields = append(fields, gridcategory.FieldName)
	}
	if m.category_id != nil {
		fields = append(fields, gridcategory.FieldCategoryID)
	}
	if m.root_category_id != nil {
		fields = append(fields, gridcategory.FieldRootCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GridCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gridcategory.FieldCreateTime:
		return m.CreateTime()
	case gridcategory.FieldUpdateTime:
		return m.UpdateTime()
	case gridcategory.FieldDeleteTime:
		return m.DeleteTime()
	case gridcategory.FieldTitle:
		return m.Title()
	case gridcategory.FieldImg:
		return m.Img()
	case gridcategory.FieldName:
		return m.Name()
	case gridcategory.FieldCategoryID:
		return m.CategoryID()
	case gridcategory.FieldRootCategoryID:
		return m.RootCategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GridCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gridcategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case gridcategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case gridcategory.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case gridcategory.FieldTitle:
		return m.OldTitle(ctx)
	case gridcategory.FieldImg:
		return m.OldImg(ctx)
	case gridcategory.FieldName:
		return m.OldName(ctx)
	case gridcategory.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case gridcategory.FieldRootCategoryID:
		return m.OldRootCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown GridCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GridCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gridcategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case gridcategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case gridcategory.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case gridcategory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case gridcategory.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case gridcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case gridcategory.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case gridcategory.FieldRootCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown GridCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GridCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addcategory_id != nil {
		fields = append(fields, gridcategory.FieldCategoryID)
	}
	if m.addroot_category_id != nil {
		fields = append(fields, gridcategory.FieldRootCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GridCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gridcategory.FieldCategoryID:
		return m.AddedCategoryID()
	case gridcategory.FieldRootCategoryID:
		return m.AddedRootCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GridCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gridcategory.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	case gridcategory.FieldRootCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRootCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown GridCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GridCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gridcategory.FieldDeleteTime) {
		fields = append(fields, gridcategory.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GridCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GridCategoryMutation) ClearField(name string) error {
	switch name {
	case gridcategory.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown GridCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GridCategoryMutation) ResetField(name string) error {
	switch name {
	case gridcategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case gridcategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case gridcategory.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case gridcategory.FieldTitle:
		m.ResetTitle()
		return nil
	case gridcategory.FieldImg:
		m.ResetImg()
		return nil
	case gridcategory.FieldName:
		m.ResetName()
		return nil
	case gridcategory.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case gridcategory.FieldRootCategoryID:
		m.ResetRootCategoryID()
		return nil
	}
	return fmt.Errorf("unknown GridCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GridCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GridCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GridCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GridCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GridCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GridCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GridCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GridCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GridCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GridCategory edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	create_time          *time.Time
	update_time          *time.Time
	delete_time          *time.Time
	order_no             *string
	transaction_id       *string
	total_price          *float64
	addtotal_price       *float64
	total_count          *int
	addtotal_count       *int
	final_total_price    *float64
	addfinal_total_price *float64
	status               *int
	addstatus            *int
	clearedFields        map[string]struct{}
	user                 *int64
	cleareduser          bool
	order_snap           map[int64]struct{}
	removedorder_snap    map[int64]struct{}
	clearedorder_snap    bool
	order_sub            map[int64]struct{}
	removedorder_sub     map[int64]struct{}
	clearedorder_sub     bool
	done                 bool
	oldValue             func(context.Context) (*Order, error)
	predicates           []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int64) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *OrderMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *OrderMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *OrderMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[order.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *OrderMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[order.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *OrderMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, order.FieldDeleteTime)
}

// SetOrderNo sets the "order_no" field.
func (m *OrderMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *OrderMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *OrderMutation) ResetOrderNo() {
	m.order_no = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *OrderMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *OrderMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *OrderMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// SetUserID sets the "user_id" field.
func (m *OrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *OrderMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[order.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *OrderMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[order.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, order.FieldUserID)
}

// SetTotalPrice sets the "total_price" field.
func (m *OrderMutation) SetTotalPrice(f float64) {
	m.total_price = &f
	m.addtotal_price = nil
}

// TotalPrice returns the value of the "total_price" field in the mutation.
func (m *OrderMutation) TotalPrice() (r float64, exists bool) {
	v := m.total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalPrice returns the old "total_price" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTotalPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalPrice: %w", err)
	}
	return oldValue.TotalPrice, nil
}

// AddTotalPrice adds f to the "total_price" field.
func (m *OrderMutation) AddTotalPrice(f float64) {
	if m.addtotal_price != nil {
		*m.addtotal_price += f
	} else {
		m.addtotal_price = &f
	}
}

// AddedTotalPrice returns the value that was added to the "total_price" field in this mutation.
func (m *OrderMutation) AddedTotalPrice() (r float64, exists bool) {
	v := m.addtotal_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalPrice resets all changes to the "total_price" field.
func (m *OrderMutation) ResetTotalPrice() {
	m.total_price = nil
	m.addtotal_price = nil
}

// SetTotalCount sets the "total_count" field.
func (m *OrderMutation) SetTotalCount(i int) {
	m.total_count = &i
	m.addtotal_count = nil
}

// TotalCount returns the value of the "total_count" field in the mutation.
func (m *OrderMutation) TotalCount() (r int, exists bool) {
	v := m.total_count
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCount returns the old "total_count" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTotalCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCount: %w", err)
	}
	return oldValue.TotalCount, nil
}

// AddTotalCount adds i to the "total_count" field.
func (m *OrderMutation) AddTotalCount(i int) {
	if m.addtotal_count != nil {
		*m.addtotal_count += i
	} else {
		m.addtotal_count = &i
	}
}

// AddedTotalCount returns the value that was added to the "total_count" field in this mutation.
func (m *OrderMutation) AddedTotalCount() (r int, exists bool) {
	v := m.addtotal_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCount resets all changes to the "total_count" field.
func (m *OrderMutation) ResetTotalCount() {
	m.total_count = nil
	m.addtotal_count = nil
}

// SetFinalTotalPrice sets the "final_total_price" field.
func (m *OrderMutation) SetFinalTotalPrice(f float64) {
	m.final_total_price = &f
	m.addfinal_total_price = nil
}

// FinalTotalPrice returns the value of the "final_total_price" field in the mutation.
func (m *OrderMutation) FinalTotalPrice() (r float64, exists bool) {
	v := m.final_total_price
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalTotalPrice returns the old "final_total_price" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldFinalTotalPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFinalTotalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFinalTotalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalTotalPrice: %w", err)
	}
	return oldValue.FinalTotalPrice, nil
}

// AddFinalTotalPrice adds f to the "final_total_price" field.
func (m *OrderMutation) AddFinalTotalPrice(f float64) {
	if m.addfinal_total_price != nil {
		*m.addfinal_total_price += f
	} else {
		m.addfinal_total_price = &f
	}
}

// AddedFinalTotalPrice returns the value that was added to the "final_total_price" field in this mutation.
func (m *OrderMutation) AddedFinalTotalPrice() (r float64, exists bool) {
	v := m.addfinal_total_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetFinalTotalPrice resets all changes to the "final_total_price" field.
func (m *OrderMutation) ResetFinalTotalPrice() {
	m.final_total_price = nil
	m.addfinal_total_price = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrderMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrderMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddOrderSnapIDs adds the "order_snap" edge to the OrderSnap entity by ids.
func (m *OrderMutation) AddOrderSnapIDs(ids ...int64) {
	if m.order_snap == nil {
		m.order_snap = make(map[int64]struct{})
	}
	for i := range ids {
		m.order_snap[ids[i]] = struct{}{}
	}
}

// ClearOrderSnap clears the "order_snap" edge to the OrderSnap entity.
func (m *OrderMutation) ClearOrderSnap() {
	m.clearedorder_snap = true
}

// OrderSnapCleared reports if the "order_snap" edge to the OrderSnap entity was cleared.
func (m *OrderMutation) OrderSnapCleared() bool {
	return m.clearedorder_snap
}

// RemoveOrderSnapIDs removes the "order_snap" edge to the OrderSnap entity by IDs.
func (m *OrderMutation) RemoveOrderSnapIDs(ids ...int64) {
	if m.removedorder_snap == nil {
		m.removedorder_snap = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.order_snap, ids[i])
		m.removedorder_snap[ids[i]] = struct{}{}
	}
}

// RemovedOrderSnap returns the removed IDs of the "order_snap" edge to the OrderSnap entity.
func (m *OrderMutation) RemovedOrderSnapIDs() (ids []int64) {
	for id := range m.removedorder_snap {
		ids = append(ids, id)
	}
	return
}

// OrderSnapIDs returns the "order_snap" edge IDs in the mutation.
func (m *OrderMutation) OrderSnapIDs() (ids []int64) {
	for id := range m.order_snap {
		ids = append(ids, id)
	}
	return
}

// ResetOrderSnap resets all changes to the "order_snap" edge.
func (m *OrderMutation) ResetOrderSnap() {
	m.order_snap = nil
	m.clearedorder_snap = false
	m.removedorder_snap = nil
}

// AddOrderSubIDs adds the "order_sub" edge to the OrderSub entity by ids.
func (m *OrderMutation) AddOrderSubIDs(ids ...int64) {
	if m.order_sub == nil {
		m.order_sub = make(map[int64]struct{})
	}
	for i := range ids {
		m.order_sub[ids[i]] = struct{}{}
	}
}

// ClearOrderSub clears the "order_sub" edge to the OrderSub entity.
func (m *OrderMutation) ClearOrderSub() {
	m.clearedorder_sub = true
}

// OrderSubCleared reports if the "order_sub" edge to the OrderSub entity was cleared.
func (m *OrderMutation) OrderSubCleared() bool {
	return m.clearedorder_sub
}

// RemoveOrderSubIDs removes the "order_sub" edge to the OrderSub entity by IDs.
func (m *OrderMutation) RemoveOrderSubIDs(ids ...int64) {
	if m.removedorder_sub == nil {
		m.removedorder_sub = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.order_sub, ids[i])
		m.removedorder_sub[ids[i]] = struct{}{}
	}
}

// RemovedOrderSub returns the removed IDs of the "order_sub" edge to the OrderSub entity.
func (m *OrderMutation) RemovedOrderSubIDs() (ids []int64) {
	for id := range m.removedorder_sub {
		ids = append(ids, id)
	}
	return
}

// OrderSubIDs returns the "order_sub" edge IDs in the mutation.
func (m *OrderMutation) OrderSubIDs() (ids []int64) {
	for id := range m.order_sub {
		ids = append(ids, id)
	}
	return
}

// ResetOrderSub resets all changes to the "order_sub" edge.
func (m *OrderMutation) ResetOrderSub() {
	m.order_sub = nil
	m.clearedorder_sub = false
	m.removedorder_sub = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, order.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, order.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, order.FieldDeleteTime)
	}
	if m.order_no != nil {
		fields = append(fields, order.FieldOrderNo)
	}
	if m.transaction_id != nil {
		fields = append(fields, order.FieldTransactionID)
	}
	if m.user != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.total_price != nil {
		fields = append(fields, order.FieldTotalPrice)
	}
	if m.total_count != nil {
		fields = append(fields, order.FieldTotalCount)
	}
	if m.final_total_price != nil {
		fields = append(fields, order.FieldFinalTotalPrice)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreateTime:
		return m.CreateTime()
	case order.FieldUpdateTime:
		return m.UpdateTime()
	case order.FieldDeleteTime:
		return m.DeleteTime()
	case order.FieldOrderNo:
		return m.OrderNo()
	case order.FieldTransactionID:
		return m.TransactionID()
	case order.FieldUserID:
		return m.UserID()
	case order.FieldTotalPrice:
		return m.TotalPrice()
	case order.FieldTotalCount:
		return m.TotalCount()
	case order.FieldFinalTotalPrice:
		return m.FinalTotalPrice()
	case order.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case order.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case order.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case order.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case order.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case order.FieldUserID:
		return m.OldUserID(ctx)
	case order.FieldTotalPrice:
		return m.OldTotalPrice(ctx)
	case order.FieldTotalCount:
		return m.OldTotalCount(ctx)
	case order.FieldFinalTotalPrice:
		return m.OldFinalTotalPrice(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case order.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case order.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case order.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case order.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case order.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case order.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalPrice(v)
		return nil
	case order.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCount(v)
		return nil
	case order.FieldFinalTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalTotalPrice(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_price != nil {
		fields = append(fields, order.FieldTotalPrice)
	}
	if m.addtotal_count != nil {
		fields = append(fields, order.FieldTotalCount)
	}
	if m.addfinal_total_price != nil {
		fields = append(fields, order.FieldFinalTotalPrice)
	}
	if m.addstatus != nil {
		fields = append(fields, order.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldTotalPrice:
		return m.AddedTotalPrice()
	case order.FieldTotalCount:
		return m.AddedTotalCount()
	case order.FieldFinalTotalPrice:
		return m.AddedFinalTotalPrice()
	case order.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalPrice(v)
		return nil
	case order.FieldTotalCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCount(v)
		return nil
	case order.FieldFinalTotalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinalTotalPrice(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldDeleteTime) {
		fields = append(fields, order.FieldDeleteTime)
	}
	if m.FieldCleared(order.FieldUserID) {
		fields = append(fields, order.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case order.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case order.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case order.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case order.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case order.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case order.FieldUserID:
		m.ResetUserID()
		return nil
	case order.FieldTotalPrice:
		m.ResetTotalPrice()
		return nil
	case order.FieldTotalCount:
		m.ResetTotalCount()
		return nil
	case order.FieldFinalTotalPrice:
		m.ResetFinalTotalPrice()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, order.EdgeUser)
	}
	if m.order_snap != nil {
		edges = append(edges, order.EdgeOrderSnap)
	}
	if m.order_sub != nil {
		edges = append(edges, order.EdgeOrderSub)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderSnap:
		ids := make([]ent.Value, 0, len(m.order_snap))
		for id := range m.order_snap {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderSub:
		ids := make([]ent.Value, 0, len(m.order_sub))
		for id := range m.order_sub {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedorder_snap != nil {
		edges = append(edges, order.EdgeOrderSnap)
	}
	if m.removedorder_sub != nil {
		edges = append(edges, order.EdgeOrderSub)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrderSnap:
		ids := make([]ent.Value, 0, len(m.removedorder_snap))
		for id := range m.removedorder_snap {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeOrderSub:
		ids := make([]ent.Value, 0, len(m.removedorder_sub))
		for id := range m.removedorder_sub {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, order.EdgeUser)
	}
	if m.clearedorder_snap {
		edges = append(edges, order.EdgeOrderSnap)
	}
	if m.clearedorder_sub {
		edges = append(edges, order.EdgeOrderSub)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeUser:
		return m.cleareduser
	case order.EdgeOrderSnap:
		return m.clearedorder_snap
	case order.EdgeOrderSub:
		return m.clearedorder_sub
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeUser:
		m.ResetUser()
		return nil
	case order.EdgeOrderSnap:
		m.ResetOrderSnap()
		return nil
	case order.EdgeOrderSub:
		m.ResetOrderSub()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderDetailMutation represents an operation that mutates the OrderDetail nodes in the graph.
type OrderDetailMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	create_time    *time.Time
	update_time    *time.Time
	delete_time    *time.Time
	user_id        *int64
	adduser_id     *int64
	pay_way        *int
	addpay_way     *int
	client_type    *int
	addclient_type *int
	ship_no        *string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*OrderDetail, error)
	predicates     []predicate.OrderDetail
}

var _ ent.Mutation = (*OrderDetailMutation)(nil)

// orderdetailOption allows management of the mutation configuration using functional options.
type orderdetailOption func(*OrderDetailMutation)

// newOrderDetailMutation creates new mutation for the OrderDetail entity.
func newOrderDetailMutation(c config, op Op, opts ...orderdetailOption) *OrderDetailMutation {
	m := &OrderDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderDetailID sets the ID field of the mutation.
func withOrderDetailID(id int64) orderdetailOption {
	return func(m *OrderDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderDetail
		)
		m.oldValue = func(ctx context.Context) (*OrderDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderDetail sets the old OrderDetail of the mutation.
func withOrderDetail(node *OrderDetail) orderdetailOption {
	return func(m *OrderDetailMutation) {
		m.oldValue = func(context.Context) (*OrderDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderDetailMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderDetailMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderDetailMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderDetailMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderDetailMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderDetailMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *OrderDetailMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *OrderDetailMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *OrderDetailMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[orderdetail.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *OrderDetailMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[orderdetail.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *OrderDetailMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, orderdetail.FieldDeleteTime)
}

// SetUserID sets the "user_id" field.
func (m *OrderDetailMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderDetailMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OrderDetailMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OrderDetailMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderDetailMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetPayWay sets the "pay_way" field.
func (m *OrderDetailMutation) SetPayWay(i int) {
	m.pay_way = &i
	m.addpay_way = nil
}

// PayWay returns the value of the "pay_way" field in the mutation.
func (m *OrderDetailMutation) PayWay() (r int, exists bool) {
	v := m.pay_way
	if v == nil {
		return
	}
	return *v, true
}

// OldPayWay returns the old "pay_way" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldPayWay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayWay: %w", err)
	}
	return oldValue.PayWay, nil
}

// AddPayWay adds i to the "pay_way" field.
func (m *OrderDetailMutation) AddPayWay(i int) {
	if m.addpay_way != nil {
		*m.addpay_way += i
	} else {
		m.addpay_way = &i
	}
}

// AddedPayWay returns the value that was added to the "pay_way" field in this mutation.
func (m *OrderDetailMutation) AddedPayWay() (r int, exists bool) {
	v := m.addpay_way
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayWay resets all changes to the "pay_way" field.
func (m *OrderDetailMutation) ResetPayWay() {
	m.pay_way = nil
	m.addpay_way = nil
}

// SetClientType sets the "client_type" field.
func (m *OrderDetailMutation) SetClientType(i int) {
	m.client_type = &i
	m.addclient_type = nil
}

// ClientType returns the value of the "client_type" field in the mutation.
func (m *OrderDetailMutation) ClientType() (r int, exists bool) {
	v := m.client_type
	if v == nil {
		return
	}
	return *v, true
}

// OldClientType returns the old "client_type" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldClientType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClientType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClientType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientType: %w", err)
	}
	return oldValue.ClientType, nil
}

// AddClientType adds i to the "client_type" field.
func (m *OrderDetailMutation) AddClientType(i int) {
	if m.addclient_type != nil {
		*m.addclient_type += i
	} else {
		m.addclient_type = &i
	}
}

// AddedClientType returns the value that was added to the "client_type" field in this mutation.
func (m *OrderDetailMutation) AddedClientType() (r int, exists bool) {
	v := m.addclient_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientType resets all changes to the "client_type" field.
func (m *OrderDetailMutation) ResetClientType() {
	m.client_type = nil
	m.addclient_type = nil
}

// SetShipNo sets the "ship_no" field.
func (m *OrderDetailMutation) SetShipNo(s string) {
	m.ship_no = &s
}

// ShipNo returns the value of the "ship_no" field in the mutation.
func (m *OrderDetailMutation) ShipNo() (r string, exists bool) {
	v := m.ship_no
	if v == nil {
		return
	}
	return *v, true
}

// OldShipNo returns the old "ship_no" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldShipNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldShipNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldShipNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipNo: %w", err)
	}
	return oldValue.ShipNo, nil
}

// ResetShipNo resets all changes to the "ship_no" field.
func (m *OrderDetailMutation) ResetShipNo() {
	m.ship_no = nil
}

// Where appends a list predicates to the OrderDetailMutation builder.
func (m *OrderDetailMutation) Where(ps ...predicate.OrderDetail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderDetail).
func (m *OrderDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderDetailMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, orderdetail.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderdetail.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, orderdetail.FieldDeleteTime)
	}
	if m.user_id != nil {
		fields = append(fields, orderdetail.FieldUserID)
	}
	if m.pay_way != nil {
		fields = append(fields, orderdetail.FieldPayWay)
	}
	if m.client_type != nil {
		fields = append(fields, orderdetail.FieldClientType)
	}
	if m.ship_no != nil {
		fields = append(fields, orderdetail.FieldShipNo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderdetail.FieldCreateTime:
		return m.CreateTime()
	case orderdetail.FieldUpdateTime:
		return m.UpdateTime()
	case orderdetail.FieldDeleteTime:
		return m.DeleteTime()
	case orderdetail.FieldUserID:
		return m.UserID()
	case orderdetail.FieldPayWay:
		return m.PayWay()
	case orderdetail.FieldClientType:
		return m.ClientType()
	case orderdetail.FieldShipNo:
		return m.ShipNo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderdetail.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderdetail.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case orderdetail.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case orderdetail.FieldUserID:
		return m.OldUserID(ctx)
	case orderdetail.FieldPayWay:
		return m.OldPayWay(ctx)
	case orderdetail.FieldClientType:
		return m.OldClientType(ctx)
	case orderdetail.FieldShipNo:
		return m.OldShipNo(ctx)
	}
	return nil, fmt.Errorf("unknown OrderDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderdetail.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderdetail.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case orderdetail.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case orderdetail.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orderdetail.FieldPayWay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayWay(v)
		return nil
	case orderdetail.FieldClientType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientType(v)
		return nil
	case orderdetail.FieldShipNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipNo(v)
		return nil
	}
	return fmt.Errorf("unknown OrderDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderDetailMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, orderdetail.FieldUserID)
	}
	if m.addpay_way != nil {
		fields = append(fields, orderdetail.FieldPayWay)
	}
	if m.addclient_type != nil {
		fields = append(fields, orderdetail.FieldClientType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderdetail.FieldUserID:
		return m.AddedUserID()
	case orderdetail.FieldPayWay:
		return m.AddedPayWay()
	case orderdetail.FieldClientType:
		return m.AddedClientType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderdetail.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case orderdetail.FieldPayWay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayWay(v)
		return nil
	case orderdetail.FieldClientType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientType(v)
		return nil
	}
	return fmt.Errorf("unknown OrderDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderdetail.FieldDeleteTime) {
		fields = append(fields, orderdetail.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderDetailMutation) ClearField(name string) error {
	switch name {
	case orderdetail.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown OrderDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderDetailMutation) ResetField(name string) error {
	switch name {
	case orderdetail.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderdetail.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case orderdetail.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case orderdetail.FieldUserID:
		m.ResetUserID()
		return nil
	case orderdetail.FieldPayWay:
		m.ResetPayWay()
		return nil
	case orderdetail.FieldClientType:
		m.ResetClientType()
		return nil
	case orderdetail.FieldShipNo:
		m.ResetShipNo()
		return nil
	}
	return fmt.Errorf("unknown OrderDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderDetailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderDetailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderDetailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderDetailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderDetail edge %s", name)
}

// OrderSnapMutation represents an operation that mutates the OrderSnap nodes in the graph.
type OrderSnapMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	snap_img      *string
	snap_title    *string
	snap_items    *string
	snap_address  *string
	clearedFields map[string]struct{}
	_order        *int64
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderSnap, error)
	predicates    []predicate.OrderSnap
}

var _ ent.Mutation = (*OrderSnapMutation)(nil)

// ordersnapOption allows management of the mutation configuration using functional options.
type ordersnapOption func(*OrderSnapMutation)

// newOrderSnapMutation creates new mutation for the OrderSnap entity.
func newOrderSnapMutation(c config, op Op, opts ...ordersnapOption) *OrderSnapMutation {
	m := &OrderSnapMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderSnap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderSnapID sets the ID field of the mutation.
func withOrderSnapID(id int64) ordersnapOption {
	return func(m *OrderSnapMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderSnap
		)
		m.oldValue = func(ctx context.Context) (*OrderSnap, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderSnap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderSnap sets the old OrderSnap of the mutation.
func withOrderSnap(node *OrderSnap) ordersnapOption {
	return func(m *OrderSnapMutation) {
		m.oldValue = func(context.Context) (*OrderSnap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderSnapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderSnapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderSnapMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSnapImg sets the "snap_img" field.
func (m *OrderSnapMutation) SetSnapImg(s string) {
	m.snap_img = &s
}

// SnapImg returns the value of the "snap_img" field in the mutation.
func (m *OrderSnapMutation) SnapImg() (r string, exists bool) {
	v := m.snap_img
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapImg returns the old "snap_img" field's value of the OrderSnap entity.
// If the OrderSnap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSnapMutation) OldSnapImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSnapImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSnapImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapImg: %w", err)
	}
	return oldValue.SnapImg, nil
}

// ResetSnapImg resets all changes to the "snap_img" field.
func (m *OrderSnapMutation) ResetSnapImg() {
	m.snap_img = nil
}

// SetSnapTitle sets the "snap_title" field.
func (m *OrderSnapMutation) SetSnapTitle(s string) {
	m.snap_title = &s
}

// SnapTitle returns the value of the "snap_title" field in the mutation.
func (m *OrderSnapMutation) SnapTitle() (r string, exists bool) {
	v := m.snap_title
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapTitle returns the old "snap_title" field's value of the OrderSnap entity.
// If the OrderSnap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSnapMutation) OldSnapTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSnapTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSnapTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapTitle: %w", err)
	}
	return oldValue.SnapTitle, nil
}

// ResetSnapTitle resets all changes to the "snap_title" field.
func (m *OrderSnapMutation) ResetSnapTitle() {
	m.snap_title = nil
}

// SetSnapItems sets the "snap_items" field.
func (m *OrderSnapMutation) SetSnapItems(s string) {
	m.snap_items = &s
}

// SnapItems returns the value of the "snap_items" field in the mutation.
func (m *OrderSnapMutation) SnapItems() (r string, exists bool) {
	v := m.snap_items
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapItems returns the old "snap_items" field's value of the OrderSnap entity.
// If the OrderSnap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSnapMutation) OldSnapItems(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSnapItems is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSnapItems requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapItems: %w", err)
	}
	return oldValue.SnapItems, nil
}

// ResetSnapItems resets all changes to the "snap_items" field.
func (m *OrderSnapMutation) ResetSnapItems() {
	m.snap_items = nil
}

// SetSnapAddress sets the "snap_address" field.
func (m *OrderSnapMutation) SetSnapAddress(s string) {
	m.snap_address = &s
}

// SnapAddress returns the value of the "snap_address" field in the mutation.
func (m *OrderSnapMutation) SnapAddress() (r string, exists bool) {
	v := m.snap_address
	if v == nil {
		return
	}
	return *v, true
}

// OldSnapAddress returns the old "snap_address" field's value of the OrderSnap entity.
// If the OrderSnap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSnapMutation) OldSnapAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSnapAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSnapAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSnapAddress: %w", err)
	}
	return oldValue.SnapAddress, nil
}

// ResetSnapAddress resets all changes to the "snap_address" field.
func (m *OrderSnapMutation) ResetSnapAddress() {
	m.snap_address = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderSnapMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderSnapMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderSnap entity.
// If the OrderSnap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSnapMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderSnapMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[ordersnap.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderSnapMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[ordersnap.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderSnapMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, ordersnap.FieldOrderID)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderSnapMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderSnapMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderSnapMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderSnapMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderSnapMutation builder.
func (m *OrderSnapMutation) Where(ps ...predicate.OrderSnap) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderSnapMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderSnap).
func (m *OrderSnapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderSnapMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.snap_img != nil {
		fields = append(fields, ordersnap.FieldSnapImg)
	}
	if m.snap_title != nil {
		fields = append(fields, ordersnap.FieldSnapTitle)
	}
	if m.snap_items != nil {
		fields = append(fields, ordersnap.FieldSnapItems)
	}
	if m.snap_address != nil {
		fields = append(fields, ordersnap.FieldSnapAddress)
	}
	if m._order != nil {
		fields = append(fields, ordersnap.FieldOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderSnapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordersnap.FieldSnapImg:
		return m.SnapImg()
	case ordersnap.FieldSnapTitle:
		return m.SnapTitle()
	case ordersnap.FieldSnapItems:
		return m.SnapItems()
	case ordersnap.FieldSnapAddress:
		return m.SnapAddress()
	case ordersnap.FieldOrderID:
		return m.OrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderSnapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordersnap.FieldSnapImg:
		return m.OldSnapImg(ctx)
	case ordersnap.FieldSnapTitle:
		return m.OldSnapTitle(ctx)
	case ordersnap.FieldSnapItems:
		return m.OldSnapItems(ctx)
	case ordersnap.FieldSnapAddress:
		return m.OldSnapAddress(ctx)
	case ordersnap.FieldOrderID:
		return m.OldOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderSnap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSnapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordersnap.FieldSnapImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapImg(v)
		return nil
	case ordersnap.FieldSnapTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapTitle(v)
		return nil
	case ordersnap.FieldSnapItems:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapItems(v)
		return nil
	case ordersnap.FieldSnapAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSnapAddress(v)
		return nil
	case ordersnap.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSnap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderSnapMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderSnapMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSnapMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderSnap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderSnapMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordersnap.FieldOrderID) {
		fields = append(fields, ordersnap.FieldOrderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderSnapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderSnapMutation) ClearField(name string) error {
	switch name {
	case ordersnap.FieldOrderID:
		m.ClearOrderID()
		return nil
	}
	return fmt.Errorf("unknown OrderSnap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderSnapMutation) ResetField(name string) error {
	switch name {
	case ordersnap.FieldSnapImg:
		m.ResetSnapImg()
		return nil
	case ordersnap.FieldSnapTitle:
		m.ResetSnapTitle()
		return nil
	case ordersnap.FieldSnapItems:
		m.ResetSnapItems()
		return nil
	case ordersnap.FieldSnapAddress:
		m.ResetSnapAddress()
		return nil
	case ordersnap.FieldOrderID:
		m.ResetOrderID()
		return nil
	}
	return fmt.Errorf("unknown OrderSnap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderSnapMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, ordersnap.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderSnapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordersnap.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderSnapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderSnapMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderSnapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, ordersnap.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderSnapMutation) EdgeCleared(name string) bool {
	switch name {
	case ordersnap.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderSnapMutation) ClearEdge(name string) error {
	switch name {
	case ordersnap.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSnap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderSnapMutation) ResetEdge(name string) error {
	switch name {
	case ordersnap.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSnap edge %s", name)
}

// OrderSubMutation represents an operation that mutates the OrderSub nodes in the graph.
type OrderSubMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	create_time    *time.Time
	update_time    *time.Time
	delete_time    *time.Time
	order_no       *string
	user_id        *int64
	adduser_id     *int64
	price          *float64
	addprice       *float64
	count          *int
	addcount       *int
	final_price    *float64
	addfinal_price *float64
	status         *int
	addstatus      *int
	clearedFields  map[string]struct{}
	_order         *int64
	cleared_order  bool
	done           bool
	oldValue       func(context.Context) (*OrderSub, error)
	predicates     []predicate.OrderSub
}

var _ ent.Mutation = (*OrderSubMutation)(nil)

// ordersubOption allows management of the mutation configuration using functional options.
type ordersubOption func(*OrderSubMutation)

// newOrderSubMutation creates new mutation for the OrderSub entity.
func newOrderSubMutation(c config, op Op, opts ...ordersubOption) *OrderSubMutation {
	m := &OrderSubMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderSub,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderSubID sets the ID field of the mutation.
func withOrderSubID(id int64) ordersubOption {
	return func(m *OrderSubMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderSub
		)
		m.oldValue = func(ctx context.Context) (*OrderSub, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderSub.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderSub sets the old OrderSub of the mutation.
func withOrderSub(node *OrderSub) ordersubOption {
	return func(m *OrderSubMutation) {
		m.oldValue = func(context.Context) (*OrderSub, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderSubMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderSubMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderSubMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *OrderSubMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderSubMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderSub entity.
// If the OrderSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSubMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderSubMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderSubMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderSubMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderSub entity.
// If the OrderSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSubMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderSubMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *OrderSubMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *OrderSubMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the OrderSub entity.
// If the OrderSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSubMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *OrderSubMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[ordersub.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *OrderSubMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[ordersub.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *OrderSubMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, ordersub.FieldDeleteTime)
}

// SetOrderNo sets the "order_no" field.
func (m *OrderSubMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *OrderSubMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the OrderSub entity.
// If the OrderSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSubMutation) OldOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *OrderSubMutation) ResetOrderNo() {
	m.order_no = nil
}

// SetUserID sets the "user_id" field.
func (m *OrderSubMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderSubMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the OrderSub entity.
// If the OrderSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSubMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OrderSubMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OrderSubMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *OrderSubMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[ordersub.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *OrderSubMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[ordersub.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderSubMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, ordersub.FieldUserID)
}

// SetPrice sets the "price" field.
func (m *OrderSubMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *OrderSubMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the OrderSub entity.
// If the OrderSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSubMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *OrderSubMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *OrderSubMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *OrderSubMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetCount sets the "count" field.
func (m *OrderSubMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *OrderSubMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the OrderSub entity.
// If the OrderSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSubMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *OrderSubMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *OrderSubMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *OrderSubMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetFinalPrice sets the "final_price" field.
func (m *OrderSubMutation) SetFinalPrice(f float64) {
	m.final_price = &f
	m.addfinal_price = nil
}

// FinalPrice returns the value of the "final_price" field in the mutation.
func (m *OrderSubMutation) FinalPrice() (r float64, exists bool) {
	v := m.final_price
	if v == nil {
		return
	}
	return *v, true
}

// OldFinalPrice returns the old "final_price" field's value of the OrderSub entity.
// If the OrderSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSubMutation) OldFinalPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFinalPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFinalPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinalPrice: %w", err)
	}
	return oldValue.FinalPrice, nil
}

// AddFinalPrice adds f to the "final_price" field.
func (m *OrderSubMutation) AddFinalPrice(f float64) {
	if m.addfinal_price != nil {
		*m.addfinal_price += f
	} else {
		m.addfinal_price = &f
	}
}

// AddedFinalPrice returns the value that was added to the "final_price" field in this mutation.
func (m *OrderSubMutation) AddedFinalPrice() (r float64, exists bool) {
	v := m.addfinal_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetFinalPrice resets all changes to the "final_price" field.
func (m *OrderSubMutation) ResetFinalPrice() {
	m.final_price = nil
	m.addfinal_price = nil
}

// SetStatus sets the "status" field.
func (m *OrderSubMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderSubMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderSub entity.
// If the OrderSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSubMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *OrderSubMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderSubMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderSubMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetOrderID sets the "order_id" field.
func (m *OrderSubMutation) SetOrderID(i int64) {
	m._order = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderSubMutation) OrderID() (r int64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderSub entity.
// If the OrderSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSubMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderSubMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[ordersub.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderSubMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[ordersub.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderSubMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, ordersub.FieldOrderID)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderSubMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderSubMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderSubMutation) OrderIDs() (ids []int64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderSubMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderSubMutation builder.
func (m *OrderSubMutation) Where(ps ...predicate.OrderSub) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderSubMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderSub).
func (m *OrderSubMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderSubMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, ordersub.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, ordersub.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, ordersub.FieldDeleteTime)
	}
	if m.order_no != nil {
		fields = append(fields, ordersub.FieldOrderNo)
	}
	if m.user_id != nil {
		fields = append(fields, ordersub.FieldUserID)
	}
	if m.price != nil {
		fields = append(fields, ordersub.FieldPrice)
	}
	if m.count != nil {
		fields = append(fields, ordersub.FieldCount)
	}
	if m.final_price != nil {
		fields = append(fields, ordersub.FieldFinalPrice)
	}
	if m.status != nil {
		fields = append(fields, ordersub.FieldStatus)
	}
	if m._order != nil {
		fields = append(fields, ordersub.FieldOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderSubMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordersub.FieldCreateTime:
		return m.CreateTime()
	case ordersub.FieldUpdateTime:
		return m.UpdateTime()
	case ordersub.FieldDeleteTime:
		return m.DeleteTime()
	case ordersub.FieldOrderNo:
		return m.OrderNo()
	case ordersub.FieldUserID:
		return m.UserID()
	case ordersub.FieldPrice:
		return m.Price()
	case ordersub.FieldCount:
		return m.Count()
	case ordersub.FieldFinalPrice:
		return m.FinalPrice()
	case ordersub.FieldStatus:
		return m.Status()
	case ordersub.FieldOrderID:
		return m.OrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderSubMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordersub.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ordersub.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case ordersub.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case ordersub.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case ordersub.FieldUserID:
		return m.OldUserID(ctx)
	case ordersub.FieldPrice:
		return m.OldPrice(ctx)
	case ordersub.FieldCount:
		return m.OldCount(ctx)
	case ordersub.FieldFinalPrice:
		return m.OldFinalPrice(ctx)
	case ordersub.FieldStatus:
		return m.OldStatus(ctx)
	case ordersub.FieldOrderID:
		return m.OldOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderSub field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSubMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordersub.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ordersub.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case ordersub.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case ordersub.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case ordersub.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case ordersub.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case ordersub.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case ordersub.FieldFinalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinalPrice(v)
		return nil
	case ordersub.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ordersub.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSub field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderSubMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, ordersub.FieldUserID)
	}
	if m.addprice != nil {
		fields = append(fields, ordersub.FieldPrice)
	}
	if m.addcount != nil {
		fields = append(fields, ordersub.FieldCount)
	}
	if m.addfinal_price != nil {
		fields = append(fields, ordersub.FieldFinalPrice)
	}
	if m.addstatus != nil {
		fields = append(fields, ordersub.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderSubMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ordersub.FieldUserID:
		return m.AddedUserID()
	case ordersub.FieldPrice:
		return m.AddedPrice()
	case ordersub.FieldCount:
		return m.AddedCount()
	case ordersub.FieldFinalPrice:
		return m.AddedFinalPrice()
	case ordersub.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSubMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ordersub.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case ordersub.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case ordersub.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	case ordersub.FieldFinalPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFinalPrice(v)
		return nil
	case ordersub.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSub numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderSubMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordersub.FieldDeleteTime) {
		fields = append(fields, ordersub.FieldDeleteTime)
	}
	if m.FieldCleared(ordersub.FieldUserID) {
		fields = append(fields, ordersub.FieldUserID)
	}
	if m.FieldCleared(ordersub.FieldOrderID) {
		fields = append(fields, ordersub.FieldOrderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderSubMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderSubMutation) ClearField(name string) error {
	switch name {
	case ordersub.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case ordersub.FieldUserID:
		m.ClearUserID()
		return nil
	case ordersub.FieldOrderID:
		m.ClearOrderID()
		return nil
	}
	return fmt.Errorf("unknown OrderSub nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderSubMutation) ResetField(name string) error {
	switch name {
	case ordersub.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ordersub.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case ordersub.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case ordersub.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case ordersub.FieldUserID:
		m.ResetUserID()
		return nil
	case ordersub.FieldPrice:
		m.ResetPrice()
		return nil
	case ordersub.FieldCount:
		m.ResetCount()
		return nil
	case ordersub.FieldFinalPrice:
		m.ResetFinalPrice()
		return nil
	case ordersub.FieldStatus:
		m.ResetStatus()
		return nil
	case ordersub.FieldOrderID:
		m.ResetOrderID()
		return nil
	}
	return fmt.Errorf("unknown OrderSub field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderSubMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, ordersub.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderSubMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordersub.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderSubMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderSubMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderSubMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, ordersub.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderSubMutation) EdgeCleared(name string) bool {
	switch name {
	case ordersub.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderSubMutation) ClearEdge(name string) error {
	switch name {
	case ordersub.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSub unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderSubMutation) ResetEdge(name string) error {
	switch name {
	case ordersub.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderSub edge %s", name)
}

// RefundMutation represents an operation that mutates the Refund nodes in the graph.
type RefundMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	create_time     *time.Time
	update_time     *time.Time
	delete_time     *time.Time
	refund_no       *string
	transaction_id  *string
	reason          *string
	order_id        *int64
	addorder_id     *int64
	order_sub_id    *int64
	addorder_sub_id *int64
	status          *int
	addstatus       *int
	clearedFields   map[string]struct{}
	user            *int64
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Refund, error)
	predicates      []predicate.Refund
}

var _ ent.Mutation = (*RefundMutation)(nil)

// refundOption allows management of the mutation configuration using functional options.
type refundOption func(*RefundMutation)

// newRefundMutation creates new mutation for the Refund entity.
func newRefundMutation(c config, op Op, opts ...refundOption) *RefundMutation {
	m := &RefundMutation{
		config:        c,
		op:            op,
		typ:           TypeRefund,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRefundID sets the ID field of the mutation.
func withRefundID(id int64) refundOption {
	return func(m *RefundMutation) {
		var (
			err   error
			once  sync.Once
			value *Refund
		)
		m.oldValue = func(ctx context.Context) (*Refund, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Refund.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRefund sets the old Refund of the mutation.
func withRefund(node *Refund) refundOption {
	return func(m *RefundMutation) {
		m.oldValue = func(context.Context) (*Refund, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RefundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RefundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RefundMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *RefundMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RefundMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RefundMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RefundMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RefundMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RefundMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *RefundMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *RefundMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *RefundMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[refund.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *RefundMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[refund.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *RefundMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, refund.FieldDeleteTime)
}

// SetRefundNo sets the "refund_no" field.
func (m *RefundMutation) SetRefundNo(s string) {
	m.refund_no = &s
}

// RefundNo returns the value of the "refund_no" field in the mutation.
func (m *RefundMutation) RefundNo() (r string, exists bool) {
	v := m.refund_no
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundNo returns the old "refund_no" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldRefundNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRefundNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRefundNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundNo: %w", err)
	}
	return oldValue.RefundNo, nil
}

// ResetRefundNo resets all changes to the "refund_no" field.
func (m *RefundMutation) ResetRefundNo() {
	m.refund_no = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *RefundMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *RefundMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *RefundMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// SetUserID sets the "user_id" field.
func (m *RefundMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RefundMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *RefundMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[refund.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *RefundMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[refund.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RefundMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, refund.FieldUserID)
}

// SetReason sets the "reason" field.
func (m *RefundMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *RefundMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *RefundMutation) ResetReason() {
	m.reason = nil
}

// SetOrderID sets the "order_id" field.
func (m *RefundMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *RefundMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *RefundMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *RefundMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *RefundMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[refund.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *RefundMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[refund.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *RefundMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, refund.FieldOrderID)
}

// SetOrderSubID sets the "order_sub_id" field.
func (m *RefundMutation) SetOrderSubID(i int64) {
	m.order_sub_id = &i
	m.addorder_sub_id = nil
}

// OrderSubID returns the value of the "order_sub_id" field in the mutation.
func (m *RefundMutation) OrderSubID() (r int64, exists bool) {
	v := m.order_sub_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSubID returns the old "order_sub_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldOrderSubID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderSubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderSubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSubID: %w", err)
	}
	return oldValue.OrderSubID, nil
}

// AddOrderSubID adds i to the "order_sub_id" field.
func (m *RefundMutation) AddOrderSubID(i int64) {
	if m.addorder_sub_id != nil {
		*m.addorder_sub_id += i
	} else {
		m.addorder_sub_id = &i
	}
}

// AddedOrderSubID returns the value that was added to the "order_sub_id" field in this mutation.
func (m *RefundMutation) AddedOrderSubID() (r int64, exists bool) {
	v := m.addorder_sub_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderSubID clears the value of the "order_sub_id" field.
func (m *RefundMutation) ClearOrderSubID() {
	m.order_sub_id = nil
	m.addorder_sub_id = nil
	m.clearedFields[refund.FieldOrderSubID] = struct{}{}
}

// OrderSubIDCleared returns if the "order_sub_id" field was cleared in this mutation.
func (m *RefundMutation) OrderSubIDCleared() bool {
	_, ok := m.clearedFields[refund.FieldOrderSubID]
	return ok
}

// ResetOrderSubID resets all changes to the "order_sub_id" field.
func (m *RefundMutation) ResetOrderSubID() {
	m.order_sub_id = nil
	m.addorder_sub_id = nil
	delete(m.clearedFields, refund.FieldOrderSubID)
}

// SetStatus sets the "status" field.
func (m *RefundMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RefundMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RefundMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RefundMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *RefundMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *RefundMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RefundMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RefundMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RefundMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the RefundMutation builder.
func (m *RefundMutation) Where(ps ...predicate.Refund) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RefundMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Refund).
func (m *RefundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RefundMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, refund.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, refund.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, refund.FieldDeleteTime)
	}
	if m.refund_no != nil {
		fields = append(fields, refund.FieldRefundNo)
	}
	if m.transaction_id != nil {
		fields = append(fields, refund.FieldTransactionID)
	}
	if m.user != nil {
		fields = append(fields, refund.FieldUserID)
	}
	if m.reason != nil {
		fields = append(fields, refund.FieldReason)
	}
	if m.order_id != nil {
		fields = append(fields, refund.FieldOrderID)
	}
	if m.order_sub_id != nil {
		fields = append(fields, refund.FieldOrderSubID)
	}
	if m.status != nil {
		fields = append(fields, refund.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RefundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case refund.FieldCreateTime:
		return m.CreateTime()
	case refund.FieldUpdateTime:
		return m.UpdateTime()
	case refund.FieldDeleteTime:
		return m.DeleteTime()
	case refund.FieldRefundNo:
		return m.RefundNo()
	case refund.FieldTransactionID:
		return m.TransactionID()
	case refund.FieldUserID:
		return m.UserID()
	case refund.FieldReason:
		return m.Reason()
	case refund.FieldOrderID:
		return m.OrderID()
	case refund.FieldOrderSubID:
		return m.OrderSubID()
	case refund.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RefundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case refund.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case refund.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case refund.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case refund.FieldRefundNo:
		return m.OldRefundNo(ctx)
	case refund.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case refund.FieldUserID:
		return m.OldUserID(ctx)
	case refund.FieldReason:
		return m.OldReason(ctx)
	case refund.FieldOrderID:
		return m.OldOrderID(ctx)
	case refund.FieldOrderSubID:
		return m.OldOrderSubID(ctx)
	case refund.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Refund field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case refund.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case refund.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case refund.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case refund.FieldRefundNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundNo(v)
		return nil
	case refund.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case refund.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case refund.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case refund.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case refund.FieldOrderSubID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSubID(v)
		return nil
	case refund.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Refund field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RefundMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, refund.FieldOrderID)
	}
	if m.addorder_sub_id != nil {
		fields = append(fields, refund.FieldOrderSubID)
	}
	if m.addstatus != nil {
		fields = append(fields, refund.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RefundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case refund.FieldOrderID:
		return m.AddedOrderID()
	case refund.FieldOrderSubID:
		return m.AddedOrderSubID()
	case refund.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case refund.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case refund.FieldOrderSubID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderSubID(v)
		return nil
	case refund.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Refund numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RefundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(refund.FieldDeleteTime) {
		fields = append(fields, refund.FieldDeleteTime)
	}
	if m.FieldCleared(refund.FieldUserID) {
		fields = append(fields, refund.FieldUserID)
	}
	if m.FieldCleared(refund.FieldOrderID) {
		fields = append(fields, refund.FieldOrderID)
	}
	if m.FieldCleared(refund.FieldOrderSubID) {
		fields = append(fields, refund.FieldOrderSubID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RefundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RefundMutation) ClearField(name string) error {
	switch name {
	case refund.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case refund.FieldUserID:
		m.ClearUserID()
		return nil
	case refund.FieldOrderID:
		m.ClearOrderID()
		return nil
	case refund.FieldOrderSubID:
		m.ClearOrderSubID()
		return nil
	}
	return fmt.Errorf("unknown Refund nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RefundMutation) ResetField(name string) error {
	switch name {
	case refund.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case refund.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case refund.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case refund.FieldRefundNo:
		m.ResetRefundNo()
		return nil
	case refund.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case refund.FieldUserID:
		m.ResetUserID()
		return nil
	case refund.FieldReason:
		m.ResetReason()
		return nil
	case refund.FieldOrderID:
		m.ResetOrderID()
		return nil
	case refund.FieldOrderSubID:
		m.ResetOrderSubID()
		return nil
	case refund.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Refund field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RefundMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, refund.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RefundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case refund.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RefundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RefundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RefundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, refund.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RefundMutation) EdgeCleared(name string) bool {
	switch name {
	case refund.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RefundMutation) ClearEdge(name string) error {
	switch name {
	case refund.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Refund unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RefundMutation) ResetEdge(name string) error {
	switch name {
	case refund.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Refund edge %s", name)
}

// SaleExplainMutation represents an operation that mutates the SaleExplain nodes in the graph.
type SaleExplainMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	fixed         *int
	addfixed      *int
	text          *string
	index         *int
	addindex      *int
	replace_id    *int64
	addreplace_id *int64
	clearedFields map[string]struct{}
	spu           *int64
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*SaleExplain, error)
	predicates    []predicate.SaleExplain
}

var _ ent.Mutation = (*SaleExplainMutation)(nil)

// saleexplainOption allows management of the mutation configuration using functional options.
type saleexplainOption func(*SaleExplainMutation)

// newSaleExplainMutation creates new mutation for the SaleExplain entity.
func newSaleExplainMutation(c config, op Op, opts ...saleexplainOption) *SaleExplainMutation {
	m := &SaleExplainMutation{
		config:        c,
		op:            op,
		typ:           TypeSaleExplain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSaleExplainID sets the ID field of the mutation.
func withSaleExplainID(id int64) saleexplainOption {
	return func(m *SaleExplainMutation) {
		var (
			err   error
			once  sync.Once
			value *SaleExplain
		)
		m.oldValue = func(ctx context.Context) (*SaleExplain, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SaleExplain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaleExplain sets the old SaleExplain of the mutation.
func withSaleExplain(node *SaleExplain) saleexplainOption {
	return func(m *SaleExplainMutation) {
		m.oldValue = func(context.Context) (*SaleExplain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SaleExplainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SaleExplainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SaleExplainMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SaleExplainMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SaleExplainMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SaleExplainMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SaleExplainMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SaleExplainMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SaleExplainMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SaleExplainMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SaleExplainMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SaleExplainMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[saleexplain.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SaleExplainMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[saleexplain.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SaleExplainMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, saleexplain.FieldDeleteTime)
}

// SetFixed sets the "fixed" field.
func (m *SaleExplainMutation) SetFixed(i int) {
	m.fixed = &i
	m.addfixed = nil
}

// Fixed returns the value of the "fixed" field in the mutation.
func (m *SaleExplainMutation) Fixed() (r int, exists bool) {
	v := m.fixed
	if v == nil {
		return
	}
	return *v, true
}

// OldFixed returns the old "fixed" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldFixed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFixed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFixed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixed: %w", err)
	}
	return oldValue.Fixed, nil
}

// AddFixed adds i to the "fixed" field.
func (m *SaleExplainMutation) AddFixed(i int) {
	if m.addfixed != nil {
		*m.addfixed += i
	} else {
		m.addfixed = &i
	}
}

// AddedFixed returns the value that was added to the "fixed" field in this mutation.
func (m *SaleExplainMutation) AddedFixed() (r int, exists bool) {
	v := m.addfixed
	if v == nil {
		return
	}
	return *v, true
}

// ResetFixed resets all changes to the "fixed" field.
func (m *SaleExplainMutation) ResetFixed() {
	m.fixed = nil
	m.addfixed = nil
}

// SetText sets the "text" field.
func (m *SaleExplainMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *SaleExplainMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *SaleExplainMutation) ResetText() {
	m.text = nil
}

// SetSpuID sets the "spu_id" field.
func (m *SaleExplainMutation) SetSpuID(i int64) {
	m.spu = &i
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *SaleExplainMutation) SpuID() (r int64, exists bool) {
	v := m.spu
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// ClearSpuID clears the value of the "spu_id" field.
func (m *SaleExplainMutation) ClearSpuID() {
	m.spu = nil
	m.clearedFields[saleexplain.FieldSpuID] = struct{}{}
}

// SpuIDCleared returns if the "spu_id" field was cleared in this mutation.
func (m *SaleExplainMutation) SpuIDCleared() bool {
	_, ok := m.clearedFields[saleexplain.FieldSpuID]
	return ok
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *SaleExplainMutation) ResetSpuID() {
	m.spu = nil
	delete(m.clearedFields, saleexplain.FieldSpuID)
}

// SetIndex sets the "index" field.
func (m *SaleExplainMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *SaleExplainMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *SaleExplainMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *SaleExplainMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *SaleExplainMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetReplaceID sets the "replace_id" field.
func (m *SaleExplainMutation) SetReplaceID(i int64) {
	m.replace_id = &i
	m.addreplace_id = nil
}

// ReplaceID returns the value of the "replace_id" field in the mutation.
func (m *SaleExplainMutation) ReplaceID() (r int64, exists bool) {
	v := m.replace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReplaceID returns the old "replace_id" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldReplaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReplaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReplaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplaceID: %w", err)
	}
	return oldValue.ReplaceID, nil
}

// AddReplaceID adds i to the "replace_id" field.
func (m *SaleExplainMutation) AddReplaceID(i int64) {
	if m.addreplace_id != nil {
		*m.addreplace_id += i
	} else {
		m.addreplace_id = &i
	}
}

// AddedReplaceID returns the value that was added to the "replace_id" field in this mutation.
func (m *SaleExplainMutation) AddedReplaceID() (r int64, exists bool) {
	v := m.addreplace_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetReplaceID resets all changes to the "replace_id" field.
func (m *SaleExplainMutation) ResetReplaceID() {
	m.replace_id = nil
	m.addreplace_id = nil
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *SaleExplainMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *SaleExplainMutation) SpuCleared() bool {
	return m.SpuIDCleared() || m.clearedspu
}

// SpuIDs returns the "spu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpuID instead. It exists only for internal usage by the builders.
func (m *SaleExplainMutation) SpuIDs() (ids []int64) {
	if id := m.spu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *SaleExplainMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
}

// Where appends a list predicates to the SaleExplainMutation builder.
func (m *SaleExplainMutation) Where(ps ...predicate.SaleExplain) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SaleExplainMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SaleExplain).
func (m *SaleExplainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SaleExplainMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, saleexplain.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, saleexplain.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, saleexplain.FieldDeleteTime)
	}
	if m.fixed != nil {
		fields = append(fields, saleexplain.FieldFixed)
	}
	if m.text != nil {
		fields = append(fields, saleexplain.FieldText)
	}
	if m.spu != nil {
		fields = append(fields, saleexplain.FieldSpuID)
	}
	if m.index != nil {
		fields = append(fields, saleexplain.FieldIndex)
	}
	if m.replace_id != nil {
		fields = append(fields, saleexplain.FieldReplaceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SaleExplainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saleexplain.FieldCreateTime:
		return m.CreateTime()
	case saleexplain.FieldUpdateTime:
		return m.UpdateTime()
	case saleexplain.FieldDeleteTime:
		return m.DeleteTime()
	case saleexplain.FieldFixed:
		return m.Fixed()
	case saleexplain.FieldText:
		return m.Text()
	case saleexplain.FieldSpuID:
		return m.SpuID()
	case saleexplain.FieldIndex:
		return m.Index()
	case saleexplain.FieldReplaceID:
		return m.ReplaceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SaleExplainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saleexplain.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case saleexplain.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case saleexplain.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case saleexplain.FieldFixed:
		return m.OldFixed(ctx)
	case saleexplain.FieldText:
		return m.OldText(ctx)
	case saleexplain.FieldSpuID:
		return m.OldSpuID(ctx)
	case saleexplain.FieldIndex:
		return m.OldIndex(ctx)
	case saleexplain.FieldReplaceID:
		return m.OldReplaceID(ctx)
	}
	return nil, fmt.Errorf("unknown SaleExplain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaleExplainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saleexplain.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case saleexplain.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case saleexplain.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case saleexplain.FieldFixed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixed(v)
		return nil
	case saleexplain.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case saleexplain.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case saleexplain.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case saleexplain.FieldReplaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplaceID(v)
		return nil
	}
	return fmt.Errorf("unknown SaleExplain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SaleExplainMutation) AddedFields() []string {
	var fields []string
	if m.addfixed != nil {
		fields = append(fields, saleexplain.FieldFixed)
	}
	if m.addindex != nil {
		fields = append(fields, saleexplain.FieldIndex)
	}
	if m.addreplace_id != nil {
		fields = append(fields, saleexplain.FieldReplaceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SaleExplainMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case saleexplain.FieldFixed:
		return m.AddedFixed()
	case saleexplain.FieldIndex:
		return m.AddedIndex()
	case saleexplain.FieldReplaceID:
		return m.AddedReplaceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaleExplainMutation) AddField(name string, value ent.Value) error {
	switch name {
	case saleexplain.FieldFixed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixed(v)
		return nil
	case saleexplain.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case saleexplain.FieldReplaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplaceID(v)
		return nil
	}
	return fmt.Errorf("unknown SaleExplain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SaleExplainMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(saleexplain.FieldDeleteTime) {
		fields = append(fields, saleexplain.FieldDeleteTime)
	}
	if m.FieldCleared(saleexplain.FieldSpuID) {
		fields = append(fields, saleexplain.FieldSpuID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SaleExplainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SaleExplainMutation) ClearField(name string) error {
	switch name {
	case saleexplain.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case saleexplain.FieldSpuID:
		m.ClearSpuID()
		return nil
	}
	return fmt.Errorf("unknown SaleExplain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SaleExplainMutation) ResetField(name string) error {
	switch name {
	case saleexplain.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case saleexplain.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case saleexplain.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case saleexplain.FieldFixed:
		m.ResetFixed()
		return nil
	case saleexplain.FieldText:
		m.ResetText()
		return nil
	case saleexplain.FieldSpuID:
		m.ResetSpuID()
		return nil
	case saleexplain.FieldIndex:
		m.ResetIndex()
		return nil
	case saleexplain.FieldReplaceID:
		m.ResetReplaceID()
		return nil
	}
	return fmt.Errorf("unknown SaleExplain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SaleExplainMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, saleexplain.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SaleExplainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saleexplain.EdgeSpu:
		if id := m.spu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SaleExplainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SaleExplainMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SaleExplainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, saleexplain.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SaleExplainMutation) EdgeCleared(name string) bool {
	switch name {
	case saleexplain.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SaleExplainMutation) ClearEdge(name string) error {
	switch name {
	case saleexplain.EdgeSpu:
		m.ClearSpu()
		return nil
	}
	return fmt.Errorf("unknown SaleExplain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SaleExplainMutation) ResetEdge(name string) error {
	switch name {
	case saleexplain.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown SaleExplain edge %s", name)
}

// SkuMutation represents an operation that mutates the Sku nodes in the graph.
type SkuMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	create_time         *time.Time
	update_time         *time.Time
	delete_time         *time.Time
	price               *float64
	addprice            *float64
	discount_price      *float64
	adddiscount_price   *float64
	online              *int
	addonline           *int
	img                 *string
	title               *string
	spu_id              *int64
	addspu_id           *int64
	specs               *[]schema.Spec
	code                *string
	stock               *int
	addstock            *int
	category_id         *int64
	addcategory_id      *int64
	root_category_id    *int64
	addroot_category_id *int64
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Sku, error)
	predicates          []predicate.Sku
}

var _ ent.Mutation = (*SkuMutation)(nil)

// skuOption allows management of the mutation configuration using functional options.
type skuOption func(*SkuMutation)

// newSkuMutation creates new mutation for the Sku entity.
func newSkuMutation(c config, op Op, opts ...skuOption) *SkuMutation {
	m := &SkuMutation{
		config:        c,
		op:            op,
		typ:           TypeSku,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkuID sets the ID field of the mutation.
func withSkuID(id int64) skuOption {
	return func(m *SkuMutation) {
		var (
			err   error
			once  sync.Once
			value *Sku
		)
		m.oldValue = func(ctx context.Context) (*Sku, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sku.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSku sets the old Sku of the mutation.
func withSku(node *Sku) skuOption {
	return func(m *SkuMutation) {
		m.oldValue = func(context.Context) (*Sku, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SkuMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SkuMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SkuMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SkuMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SkuMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SkuMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SkuMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SkuMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SkuMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[sku.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SkuMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[sku.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SkuMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, sku.FieldDeleteTime)
}

// SetPrice sets the "price" field.
func (m *SkuMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *SkuMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *SkuMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *SkuMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *SkuMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDiscountPrice sets the "discount_price" field.
func (m *SkuMutation) SetDiscountPrice(f float64) {
	m.discount_price = &f
	m.adddiscount_price = nil
}

// DiscountPrice returns the value of the "discount_price" field in the mutation.
func (m *SkuMutation) DiscountPrice() (r float64, exists bool) {
	v := m.discount_price
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountPrice returns the old "discount_price" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldDiscountPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscountPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscountPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountPrice: %w", err)
	}
	return oldValue.DiscountPrice, nil
}

// AddDiscountPrice adds f to the "discount_price" field.
func (m *SkuMutation) AddDiscountPrice(f float64) {
	if m.adddiscount_price != nil {
		*m.adddiscount_price += f
	} else {
		m.adddiscount_price = &f
	}
}

// AddedDiscountPrice returns the value that was added to the "discount_price" field in this mutation.
func (m *SkuMutation) AddedDiscountPrice() (r float64, exists bool) {
	v := m.adddiscount_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountPrice resets all changes to the "discount_price" field.
func (m *SkuMutation) ResetDiscountPrice() {
	m.discount_price = nil
	m.adddiscount_price = nil
}

// SetOnline sets the "online" field.
func (m *SkuMutation) SetOnline(i int) {
	m.online = &i
	m.addonline = nil
}

// Online returns the value of the "online" field in the mutation.
func (m *SkuMutation) Online() (r int, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldOnline(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// AddOnline adds i to the "online" field.
func (m *SkuMutation) AddOnline(i int) {
	if m.addonline != nil {
		*m.addonline += i
	} else {
		m.addonline = &i
	}
}

// AddedOnline returns the value that was added to the "online" field in this mutation.
func (m *SkuMutation) AddedOnline() (r int, exists bool) {
	v := m.addonline
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnline resets all changes to the "online" field.
func (m *SkuMutation) ResetOnline() {
	m.online = nil
	m.addonline = nil
}

// SetImg sets the "img" field.
func (m *SkuMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *SkuMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *SkuMutation) ResetImg() {
	m.img = nil
}

// SetTitle sets the "title" field.
func (m *SkuMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SkuMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SkuMutation) ResetTitle() {
	m.title = nil
}

// SetSpuID sets the "spu_id" field.
func (m *SkuMutation) SetSpuID(i int64) {
	m.spu_id = &i
	m.addspu_id = nil
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *SkuMutation) SpuID() (r int64, exists bool) {
	v := m.spu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// AddSpuID adds i to the "spu_id" field.
func (m *SkuMutation) AddSpuID(i int64) {
	if m.addspu_id != nil {
		*m.addspu_id += i
	} else {
		m.addspu_id = &i
	}
}

// AddedSpuID returns the value that was added to the "spu_id" field in this mutation.
func (m *SkuMutation) AddedSpuID() (r int64, exists bool) {
	v := m.addspu_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpuID clears the value of the "spu_id" field.
func (m *SkuMutation) ClearSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
	m.clearedFields[sku.FieldSpuID] = struct{}{}
}

// SpuIDCleared returns if the "spu_id" field was cleared in this mutation.
func (m *SkuMutation) SpuIDCleared() bool {
	_, ok := m.clearedFields[sku.FieldSpuID]
	return ok
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *SkuMutation) ResetSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
	delete(m.clearedFields, sku.FieldSpuID)
}

// SetSpecs sets the "specs" field.
func (m *SkuMutation) SetSpecs(s []schema.Spec) {
	m.specs = &s
}

// Specs returns the value of the "specs" field in the mutation.
func (m *SkuMutation) Specs() (r []schema.Spec, exists bool) {
	v := m.specs
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecs returns the old "specs" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldSpecs(ctx context.Context) (v []schema.Spec, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecs: %w", err)
	}
	return oldValue.Specs, nil
}

// ResetSpecs resets all changes to the "specs" field.
func (m *SkuMutation) ResetSpecs() {
	m.specs = nil
}

// SetCode sets the "code" field.
func (m *SkuMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *SkuMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *SkuMutation) ResetCode() {
	m.code = nil
}

// SetStock sets the "stock" field.
func (m *SkuMutation) SetStock(i int) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *SkuMutation) Stock() (r int, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *SkuMutation) AddStock(i int) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *SkuMutation) AddedStock() (r int, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *SkuMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetCategoryID sets the "category_id" field.
func (m *SkuMutation) SetCategoryID(i int64) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *SkuMutation) CategoryID() (r int64, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldCategoryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *SkuMutation) AddCategoryID(i int64) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *SkuMutation) AddedCategoryID() (r int64, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *SkuMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// SetRootCategoryID sets the "root_category_id" field.
func (m *SkuMutation) SetRootCategoryID(i int64) {
	m.root_category_id = &i
	m.addroot_category_id = nil
}

// RootCategoryID returns the value of the "root_category_id" field in the mutation.
func (m *SkuMutation) RootCategoryID() (r int64, exists bool) {
	v := m.root_category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootCategoryID returns the old "root_category_id" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldRootCategoryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRootCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRootCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootCategoryID: %w", err)
	}
	return oldValue.RootCategoryID, nil
}

// AddRootCategoryID adds i to the "root_category_id" field.
func (m *SkuMutation) AddRootCategoryID(i int64) {
	if m.addroot_category_id != nil {
		*m.addroot_category_id += i
	} else {
		m.addroot_category_id = &i
	}
}

// AddedRootCategoryID returns the value that was added to the "root_category_id" field in this mutation.
func (m *SkuMutation) AddedRootCategoryID() (r int64, exists bool) {
	v := m.addroot_category_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRootCategoryID resets all changes to the "root_category_id" field.
func (m *SkuMutation) ResetRootCategoryID() {
	m.root_category_id = nil
	m.addroot_category_id = nil
}

// Where appends a list predicates to the SkuMutation builder.
func (m *SkuMutation) Where(ps ...predicate.Sku) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SkuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Sku).
func (m *SkuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkuMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, sku.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, sku.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, sku.FieldDeleteTime)
	}
	if m.price != nil {
		fields = append(fields, sku.FieldPrice)
	}
	if m.discount_price != nil {
		fields = append(fields, sku.FieldDiscountPrice)
	}
	if m.online != nil {
		fields = append(fields, sku.FieldOnline)
	}
	if m.img != nil {
		fields = append(fields, sku.FieldImg)
	}
	if m.title != nil {
		fields = append(fields, sku.FieldTitle)
	}
	if m.spu_id != nil {
		fields = append(fields, sku.FieldSpuID)
	}
	if m.specs != nil {
		fields = append(fields, sku.FieldSpecs)
	}
	if m.code != nil {
		fields = append(fields, sku.FieldCode)
	}
	if m.stock != nil {
		fields = append(fields, sku.FieldStock)
	}
	if m.category_id != nil {
		fields = append(fields, sku.FieldCategoryID)
	}
	if m.root_category_id != nil {
		fields = append(fields, sku.FieldRootCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sku.FieldCreateTime:
		return m.CreateTime()
	case sku.FieldUpdateTime:
		return m.UpdateTime()
	case sku.FieldDeleteTime:
		return m.DeleteTime()
	case sku.FieldPrice:
		return m.Price()
	case sku.FieldDiscountPrice:
		return m.DiscountPrice()
	case sku.FieldOnline:
		return m.Online()
	case sku.FieldImg:
		return m.Img()
	case sku.FieldTitle:
		return m.Title()
	case sku.FieldSpuID:
		return m.SpuID()
	case sku.FieldSpecs:
		return m.Specs()
	case sku.FieldCode:
		return m.Code()
	case sku.FieldStock:
		return m.Stock()
	case sku.FieldCategoryID:
		return m.CategoryID()
	case sku.FieldRootCategoryID:
		return m.RootCategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sku.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case sku.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case sku.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case sku.FieldPrice:
		return m.OldPrice(ctx)
	case sku.FieldDiscountPrice:
		return m.OldDiscountPrice(ctx)
	case sku.FieldOnline:
		return m.OldOnline(ctx)
	case sku.FieldImg:
		return m.OldImg(ctx)
	case sku.FieldTitle:
		return m.OldTitle(ctx)
	case sku.FieldSpuID:
		return m.OldSpuID(ctx)
	case sku.FieldSpecs:
		return m.OldSpecs(ctx)
	case sku.FieldCode:
		return m.OldCode(ctx)
	case sku.FieldStock:
		return m.OldStock(ctx)
	case sku.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case sku.FieldRootCategoryID:
		return m.OldRootCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown Sku field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sku.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case sku.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case sku.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case sku.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case sku.FieldDiscountPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountPrice(v)
		return nil
	case sku.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case sku.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case sku.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case sku.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case sku.FieldSpecs:
		v, ok := value.([]schema.Spec)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecs(v)
		return nil
	case sku.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case sku.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case sku.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case sku.FieldRootCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Sku field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkuMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, sku.FieldPrice)
	}
	if m.adddiscount_price != nil {
		fields = append(fields, sku.FieldDiscountPrice)
	}
	if m.addonline != nil {
		fields = append(fields, sku.FieldOnline)
	}
	if m.addspu_id != nil {
		fields = append(fields, sku.FieldSpuID)
	}
	if m.addstock != nil {
		fields = append(fields, sku.FieldStock)
	}
	if m.addcategory_id != nil {
		fields = append(fields, sku.FieldCategoryID)
	}
	if m.addroot_category_id != nil {
		fields = append(fields, sku.FieldRootCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sku.FieldPrice:
		return m.AddedPrice()
	case sku.FieldDiscountPrice:
		return m.AddedDiscountPrice()
	case sku.FieldOnline:
		return m.AddedOnline()
	case sku.FieldSpuID:
		return m.AddedSpuID()
	case sku.FieldStock:
		return m.AddedStock()
	case sku.FieldCategoryID:
		return m.AddedCategoryID()
	case sku.FieldRootCategoryID:
		return m.AddedRootCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sku.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case sku.FieldDiscountPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountPrice(v)
		return nil
	case sku.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnline(v)
		return nil
	case sku.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpuID(v)
		return nil
	case sku.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case sku.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	case sku.FieldRootCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRootCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Sku numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sku.FieldDeleteTime) {
		fields = append(fields, sku.FieldDeleteTime)
	}
	if m.FieldCleared(sku.FieldSpuID) {
		fields = append(fields, sku.FieldSpuID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkuMutation) ClearField(name string) error {
	switch name {
	case sku.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case sku.FieldSpuID:
		m.ClearSpuID()
		return nil
	}
	return fmt.Errorf("unknown Sku nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkuMutation) ResetField(name string) error {
	switch name {
	case sku.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case sku.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case sku.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case sku.FieldPrice:
		m.ResetPrice()
		return nil
	case sku.FieldDiscountPrice:
		m.ResetDiscountPrice()
		return nil
	case sku.FieldOnline:
		m.ResetOnline()
		return nil
	case sku.FieldImg:
		m.ResetImg()
		return nil
	case sku.FieldTitle:
		m.ResetTitle()
		return nil
	case sku.FieldSpuID:
		m.ResetSpuID()
		return nil
	case sku.FieldSpecs:
		m.ResetSpecs()
		return nil
	case sku.FieldCode:
		m.ResetCode()
		return nil
	case sku.FieldStock:
		m.ResetStock()
		return nil
	case sku.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case sku.FieldRootCategoryID:
		m.ResetRootCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Sku field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkuMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkuMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkuMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkuMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Sku unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkuMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Sku edge %s", name)
}

// SkuSpecMutation represents an operation that mutates the SkuSpec nodes in the graph.
type SkuSpecMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	spu_id        *int64
	addspu_id     *int64
	sku_id        *int64
	addsku_id     *int64
	key_id        *int64
	addkey_id     *int64
	value_id      *int64
	addvalue_id   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SkuSpec, error)
	predicates    []predicate.SkuSpec
}

var _ ent.Mutation = (*SkuSpecMutation)(nil)

// skuspecOption allows management of the mutation configuration using functional options.
type skuspecOption func(*SkuSpecMutation)

// newSkuSpecMutation creates new mutation for the SkuSpec entity.
func newSkuSpecMutation(c config, op Op, opts ...skuspecOption) *SkuSpecMutation {
	m := &SkuSpecMutation{
		config:        c,
		op:            op,
		typ:           TypeSkuSpec,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkuSpecID sets the ID field of the mutation.
func withSkuSpecID(id int64) skuspecOption {
	return func(m *SkuSpecMutation) {
		var (
			err   error
			once  sync.Once
			value *SkuSpec
		)
		m.oldValue = func(ctx context.Context) (*SkuSpec, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SkuSpec.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkuSpec sets the old SkuSpec of the mutation.
func withSkuSpec(node *SkuSpec) skuspecOption {
	return func(m *SkuSpecMutation) {
		m.oldValue = func(context.Context) (*SkuSpec, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkuSpecMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkuSpecMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkuSpecMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSpuID sets the "spu_id" field.
func (m *SkuSpecMutation) SetSpuID(i int64) {
	m.spu_id = &i
	m.addspu_id = nil
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *SkuSpecMutation) SpuID() (r int64, exists bool) {
	v := m.spu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the SkuSpec entity.
// If the SkuSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuSpecMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// AddSpuID adds i to the "spu_id" field.
func (m *SkuSpecMutation) AddSpuID(i int64) {
	if m.addspu_id != nil {
		*m.addspu_id += i
	} else {
		m.addspu_id = &i
	}
}

// AddedSpuID returns the value that was added to the "spu_id" field in this mutation.
func (m *SkuSpecMutation) AddedSpuID() (r int64, exists bool) {
	v := m.addspu_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *SkuSpecMutation) ResetSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
}

// SetSkuID sets the "sku_id" field.
func (m *SkuSpecMutation) SetSkuID(i int64) {
	m.sku_id = &i
	m.addsku_id = nil
}

// SkuID returns the value of the "sku_id" field in the mutation.
func (m *SkuSpecMutation) SkuID() (r int64, exists bool) {
	v := m.sku_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSkuID returns the old "sku_id" field's value of the SkuSpec entity.
// If the SkuSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuSpecMutation) OldSkuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSkuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSkuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkuID: %w", err)
	}
	return oldValue.SkuID, nil
}

// AddSkuID adds i to the "sku_id" field.
func (m *SkuSpecMutation) AddSkuID(i int64) {
	if m.addsku_id != nil {
		*m.addsku_id += i
	} else {
		m.addsku_id = &i
	}
}

// AddedSkuID returns the value that was added to the "sku_id" field in this mutation.
func (m *SkuSpecMutation) AddedSkuID() (r int64, exists bool) {
	v := m.addsku_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSkuID resets all changes to the "sku_id" field.
func (m *SkuSpecMutation) ResetSkuID() {
	m.sku_id = nil
	m.addsku_id = nil
}

// SetKeyID sets the "key_id" field.
func (m *SkuSpecMutation) SetKeyID(i int64) {
	m.key_id = &i
	m.addkey_id = nil
}

// KeyID returns the value of the "key_id" field in the mutation.
func (m *SkuSpecMutation) KeyID() (r int64, exists bool) {
	v := m.key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyID returns the old "key_id" field's value of the SkuSpec entity.
// If the SkuSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuSpecMutation) OldKeyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyID: %w", err)
	}
	return oldValue.KeyID, nil
}

// AddKeyID adds i to the "key_id" field.
func (m *SkuSpecMutation) AddKeyID(i int64) {
	if m.addkey_id != nil {
		*m.addkey_id += i
	} else {
		m.addkey_id = &i
	}
}

// AddedKeyID returns the value that was added to the "key_id" field in this mutation.
func (m *SkuSpecMutation) AddedKeyID() (r int64, exists bool) {
	v := m.addkey_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetKeyID resets all changes to the "key_id" field.
func (m *SkuSpecMutation) ResetKeyID() {
	m.key_id = nil
	m.addkey_id = nil
}

// SetValueID sets the "value_id" field.
func (m *SkuSpecMutation) SetValueID(i int64) {
	m.value_id = &i
	m.addvalue_id = nil
}

// ValueID returns the value of the "value_id" field in the mutation.
func (m *SkuSpecMutation) ValueID() (r int64, exists bool) {
	v := m.value_id
	if v == nil {
		return
	}
	return *v, true
}

// OldValueID returns the old "value_id" field's value of the SkuSpec entity.
// If the SkuSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuSpecMutation) OldValueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueID: %w", err)
	}
	return oldValue.ValueID, nil
}

// AddValueID adds i to the "value_id" field.
func (m *SkuSpecMutation) AddValueID(i int64) {
	if m.addvalue_id != nil {
		*m.addvalue_id += i
	} else {
		m.addvalue_id = &i
	}
}

// AddedValueID returns the value that was added to the "value_id" field in this mutation.
func (m *SkuSpecMutation) AddedValueID() (r int64, exists bool) {
	v := m.addvalue_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetValueID resets all changes to the "value_id" field.
func (m *SkuSpecMutation) ResetValueID() {
	m.value_id = nil
	m.addvalue_id = nil
}

// Where appends a list predicates to the SkuSpecMutation builder.
func (m *SkuSpecMutation) Where(ps ...predicate.SkuSpec) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SkuSpecMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SkuSpec).
func (m *SkuSpecMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkuSpecMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.spu_id != nil {
		fields = append(fields, skuspec.FieldSpuID)
	}
	if m.sku_id != nil {
		fields = append(fields, skuspec.FieldSkuID)
	}
	if m.key_id != nil {
		fields = append(fields, skuspec.FieldKeyID)
	}
	if m.value_id != nil {
		fields = append(fields, skuspec.FieldValueID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkuSpecMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skuspec.FieldSpuID:
		return m.SpuID()
	case skuspec.FieldSkuID:
		return m.SkuID()
	case skuspec.FieldKeyID:
		return m.KeyID()
	case skuspec.FieldValueID:
		return m.ValueID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkuSpecMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skuspec.FieldSpuID:
		return m.OldSpuID(ctx)
	case skuspec.FieldSkuID:
		return m.OldSkuID(ctx)
	case skuspec.FieldKeyID:
		return m.OldKeyID(ctx)
	case skuspec.FieldValueID:
		return m.OldValueID(ctx)
	}
	return nil, fmt.Errorf("unknown SkuSpec field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkuSpecMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skuspec.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case skuspec.FieldSkuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkuID(v)
		return nil
	case skuspec.FieldKeyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyID(v)
		return nil
	case skuspec.FieldValueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueID(v)
		return nil
	}
	return fmt.Errorf("unknown SkuSpec field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkuSpecMutation) AddedFields() []string {
	var fields []string
	if m.addspu_id != nil {
		fields = append(fields, skuspec.FieldSpuID)
	}
	if m.addsku_id != nil {
		fields = append(fields, skuspec.FieldSkuID)
	}
	if m.addkey_id != nil {
		fields = append(fields, skuspec.FieldKeyID)
	}
	if m.addvalue_id != nil {
		fields = append(fields, skuspec.FieldValueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkuSpecMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case skuspec.FieldSpuID:
		return m.AddedSpuID()
	case skuspec.FieldSkuID:
		return m.AddedSkuID()
	case skuspec.FieldKeyID:
		return m.AddedKeyID()
	case skuspec.FieldValueID:
		return m.AddedValueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkuSpecMutation) AddField(name string, value ent.Value) error {
	switch name {
	case skuspec.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpuID(v)
		return nil
	case skuspec.FieldSkuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSkuID(v)
		return nil
	case skuspec.FieldKeyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKeyID(v)
		return nil
	case skuspec.FieldValueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValueID(v)
		return nil
	}
	return fmt.Errorf("unknown SkuSpec numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkuSpecMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkuSpecMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkuSpecMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SkuSpec nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkuSpecMutation) ResetField(name string) error {
	switch name {
	case skuspec.FieldSpuID:
		m.ResetSpuID()
		return nil
	case skuspec.FieldSkuID:
		m.ResetSkuID()
		return nil
	case skuspec.FieldKeyID:
		m.ResetKeyID()
		return nil
	case skuspec.FieldValueID:
		m.ResetValueID()
		return nil
	}
	return fmt.Errorf("unknown SkuSpec field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkuSpecMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkuSpecMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkuSpecMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkuSpecMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkuSpecMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkuSpecMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkuSpecMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SkuSpec unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkuSpecMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SkuSpec edge %s", name)
}

// SpecKeyMutation represents an operation that mutates the SpecKey nodes in the graph.
type SpecKeyMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	name          *string
	unit          *string
	standard      *int
	addstandard   *int
	description   *string
	clearedFields map[string]struct{}
	spu           map[int64]struct{}
	removedspu    map[int64]struct{}
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*SpecKey, error)
	predicates    []predicate.SpecKey
}

var _ ent.Mutation = (*SpecKeyMutation)(nil)

// speckeyOption allows management of the mutation configuration using functional options.
type speckeyOption func(*SpecKeyMutation)

// newSpecKeyMutation creates new mutation for the SpecKey entity.
func newSpecKeyMutation(c config, op Op, opts ...speckeyOption) *SpecKeyMutation {
	m := &SpecKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeSpecKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpecKeyID sets the ID field of the mutation.
func withSpecKeyID(id int64) speckeyOption {
	return func(m *SpecKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *SpecKey
		)
		m.oldValue = func(ctx context.Context) (*SpecKey, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpecKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpecKey sets the old SpecKey of the mutation.
func withSpecKey(node *SpecKey) speckeyOption {
	return func(m *SpecKeyMutation) {
		m.oldValue = func(context.Context) (*SpecKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpecKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpecKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpecKeyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SpecKeyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SpecKeyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SpecKeyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SpecKeyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SpecKeyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SpecKeyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SpecKeyMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SpecKeyMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SpecKeyMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[speckey.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SpecKeyMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[speckey.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SpecKeyMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, speckey.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *SpecKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SpecKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SpecKeyMutation) ResetName() {
	m.name = nil
}

// SetUnit sets the "unit" field.
func (m *SpecKeyMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *SpecKeyMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *SpecKeyMutation) ResetUnit() {
	m.unit = nil
}

// SetStandard sets the "standard" field.
func (m *SpecKeyMutation) SetStandard(i int) {
	m.standard = &i
	m.addstandard = nil
}

// Standard returns the value of the "standard" field in the mutation.
func (m *SpecKeyMutation) Standard() (r int, exists bool) {
	v := m.standard
	if v == nil {
		return
	}
	return *v, true
}

// OldStandard returns the old "standard" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldStandard(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStandard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStandard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStandard: %w", err)
	}
	return oldValue.Standard, nil
}

// AddStandard adds i to the "standard" field.
func (m *SpecKeyMutation) AddStandard(i int) {
	if m.addstandard != nil {
		*m.addstandard += i
	} else {
		m.addstandard = &i
	}
}

// AddedStandard returns the value that was added to the "standard" field in this mutation.
func (m *SpecKeyMutation) AddedStandard() (r int, exists bool) {
	v := m.addstandard
	if v == nil {
		return
	}
	return *v, true
}

// ResetStandard resets all changes to the "standard" field.
func (m *SpecKeyMutation) ResetStandard() {
	m.standard = nil
	m.addstandard = nil
}

// SetDescription sets the "description" field.
func (m *SpecKeyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SpecKeyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SpecKeyMutation) ResetDescription() {
	m.description = nil
}

// AddSpuIDs adds the "spu" edge to the Spu entity by ids.
func (m *SpecKeyMutation) AddSpuIDs(ids ...int64) {
	if m.spu == nil {
		m.spu = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu[ids[i]] = struct{}{}
	}
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *SpecKeyMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *SpecKeyMutation) SpuCleared() bool {
	return m.clearedspu
}

// RemoveSpuIDs removes the "spu" edge to the Spu entity by IDs.
func (m *SpecKeyMutation) RemoveSpuIDs(ids ...int64) {
	if m.removedspu == nil {
		m.removedspu = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu, ids[i])
		m.removedspu[ids[i]] = struct{}{}
	}
}

// RemovedSpu returns the removed IDs of the "spu" edge to the Spu entity.
func (m *SpecKeyMutation) RemovedSpuIDs() (ids []int64) {
	for id := range m.removedspu {
		ids = append(ids, id)
	}
	return
}

// SpuIDs returns the "spu" edge IDs in the mutation.
func (m *SpecKeyMutation) SpuIDs() (ids []int64) {
	for id := range m.spu {
		ids = append(ids, id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *SpecKeyMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
	m.removedspu = nil
}

// Where appends a list predicates to the SpecKeyMutation builder.
func (m *SpecKeyMutation) Where(ps ...predicate.SpecKey) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SpecKeyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SpecKey).
func (m *SpecKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpecKeyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, speckey.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, speckey.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, speckey.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, speckey.FieldName)
	}
	if m.unit != nil {
		fields = append(fields, speckey.FieldUnit)
	}
	if m.standard != nil {
		fields = append(fields, speckey.FieldStandard)
	}
	if m.description != nil {
		fields = append(fields, speckey.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpecKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case speckey.FieldCreateTime:
		return m.CreateTime()
	case speckey.FieldUpdateTime:
		return m.UpdateTime()
	case speckey.FieldDeleteTime:
		return m.DeleteTime()
	case speckey.FieldName:
		return m.Name()
	case speckey.FieldUnit:
		return m.Unit()
	case speckey.FieldStandard:
		return m.Standard()
	case speckey.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpecKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case speckey.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case speckey.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case speckey.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case speckey.FieldName:
		return m.OldName(ctx)
	case speckey.FieldUnit:
		return m.OldUnit(ctx)
	case speckey.FieldStandard:
		return m.OldStandard(ctx)
	case speckey.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown SpecKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpecKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case speckey.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case speckey.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case speckey.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case speckey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case speckey.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case speckey.FieldStandard:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStandard(v)
		return nil
	case speckey.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown SpecKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpecKeyMutation) AddedFields() []string {
	var fields []string
	if m.addstandard != nil {
		fields = append(fields, speckey.FieldStandard)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpecKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case speckey.FieldStandard:
		return m.AddedStandard()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpecKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case speckey.FieldStandard:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStandard(v)
		return nil
	}
	return fmt.Errorf("unknown SpecKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpecKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(speckey.FieldDeleteTime) {
		fields = append(fields, speckey.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpecKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpecKeyMutation) ClearField(name string) error {
	switch name {
	case speckey.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown SpecKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpecKeyMutation) ResetField(name string) error {
	switch name {
	case speckey.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case speckey.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case speckey.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case speckey.FieldName:
		m.ResetName()
		return nil
	case speckey.FieldUnit:
		m.ResetUnit()
		return nil
	case speckey.FieldStandard:
		m.ResetStandard()
		return nil
	case speckey.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown SpecKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpecKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, speckey.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpecKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case speckey.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.spu))
		for id := range m.spu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpecKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedspu != nil {
		edges = append(edges, speckey.EdgeSpu)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpecKeyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case speckey.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.removedspu))
		for id := range m.removedspu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpecKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, speckey.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpecKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case speckey.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpecKeyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SpecKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpecKeyMutation) ResetEdge(name string) error {
	switch name {
	case speckey.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown SpecKey edge %s", name)
}

// SpecValueMutation represents an operation that mutates the SpecValue nodes in the graph.
type SpecValueMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	value         *string
	spec_id       *int64
	addspec_id    *int64
	extend        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SpecValue, error)
	predicates    []predicate.SpecValue
}

var _ ent.Mutation = (*SpecValueMutation)(nil)

// specvalueOption allows management of the mutation configuration using functional options.
type specvalueOption func(*SpecValueMutation)

// newSpecValueMutation creates new mutation for the SpecValue entity.
func newSpecValueMutation(c config, op Op, opts ...specvalueOption) *SpecValueMutation {
	m := &SpecValueMutation{
		config:        c,
		op:            op,
		typ:           TypeSpecValue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpecValueID sets the ID field of the mutation.
func withSpecValueID(id int64) specvalueOption {
	return func(m *SpecValueMutation) {
		var (
			err   error
			once  sync.Once
			value *SpecValue
		)
		m.oldValue = func(ctx context.Context) (*SpecValue, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpecValue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpecValue sets the old SpecValue of the mutation.
func withSpecValue(node *SpecValue) specvalueOption {
	return func(m *SpecValueMutation) {
		m.oldValue = func(context.Context) (*SpecValue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpecValueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpecValueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpecValueMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SpecValueMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SpecValueMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SpecValueMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SpecValueMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SpecValueMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SpecValueMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SpecValueMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SpecValueMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SpecValueMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[specvalue.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SpecValueMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[specvalue.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SpecValueMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, specvalue.FieldDeleteTime)
}

// SetValue sets the "value" field.
func (m *SpecValueMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SpecValueMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SpecValueMutation) ResetValue() {
	m.value = nil
}

// SetSpecID sets the "spec_id" field.
func (m *SpecValueMutation) SetSpecID(i int64) {
	m.spec_id = &i
	m.addspec_id = nil
}

// SpecID returns the value of the "spec_id" field in the mutation.
func (m *SpecValueMutation) SpecID() (r int64, exists bool) {
	v := m.spec_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecID returns the old "spec_id" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldSpecID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecID: %w", err)
	}
	return oldValue.SpecID, nil
}

// AddSpecID adds i to the "spec_id" field.
func (m *SpecValueMutation) AddSpecID(i int64) {
	if m.addspec_id != nil {
		*m.addspec_id += i
	} else {
		m.addspec_id = &i
	}
}

// AddedSpecID returns the value that was added to the "spec_id" field in this mutation.
func (m *SpecValueMutation) AddedSpecID() (r int64, exists bool) {
	v := m.addspec_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpecID resets all changes to the "spec_id" field.
func (m *SpecValueMutation) ResetSpecID() {
	m.spec_id = nil
	m.addspec_id = nil
}

// SetExtend sets the "extend" field.
func (m *SpecValueMutation) SetExtend(s string) {
	m.extend = &s
}

// Extend returns the value of the "extend" field in the mutation.
func (m *SpecValueMutation) Extend() (r string, exists bool) {
	v := m.extend
	if v == nil {
		return
	}
	return *v, true
}

// OldExtend returns the old "extend" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldExtend(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExtend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExtend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtend: %w", err)
	}
	return oldValue.Extend, nil
}

// ResetExtend resets all changes to the "extend" field.
func (m *SpecValueMutation) ResetExtend() {
	m.extend = nil
}

// Where appends a list predicates to the SpecValueMutation builder.
func (m *SpecValueMutation) Where(ps ...predicate.SpecValue) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SpecValueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SpecValue).
func (m *SpecValueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpecValueMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, specvalue.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, specvalue.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, specvalue.FieldDeleteTime)
	}
	if m.value != nil {
		fields = append(fields, specvalue.FieldValue)
	}
	if m.spec_id != nil {
		fields = append(fields, specvalue.FieldSpecID)
	}
	if m.extend != nil {
		fields = append(fields, specvalue.FieldExtend)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpecValueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case specvalue.FieldCreateTime:
		return m.CreateTime()
	case specvalue.FieldUpdateTime:
		return m.UpdateTime()
	case specvalue.FieldDeleteTime:
		return m.DeleteTime()
	case specvalue.FieldValue:
		return m.Value()
	case specvalue.FieldSpecID:
		return m.SpecID()
	case specvalue.FieldExtend:
		return m.Extend()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpecValueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case specvalue.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case specvalue.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case specvalue.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case specvalue.FieldValue:
		return m.OldValue(ctx)
	case specvalue.FieldSpecID:
		return m.OldSpecID(ctx)
	case specvalue.FieldExtend:
		return m.OldExtend(ctx)
	}
	return nil, fmt.Errorf("unknown SpecValue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpecValueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case specvalue.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case specvalue.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case specvalue.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case specvalue.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case specvalue.FieldSpecID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecID(v)
		return nil
	case specvalue.FieldExtend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtend(v)
		return nil
	}
	return fmt.Errorf("unknown SpecValue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpecValueMutation) AddedFields() []string {
	var fields []string
	if m.addspec_id != nil {
		fields = append(fields, specvalue.FieldSpecID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpecValueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case specvalue.FieldSpecID:
		return m.AddedSpecID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpecValueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case specvalue.FieldSpecID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpecID(v)
		return nil
	}
	return fmt.Errorf("unknown SpecValue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpecValueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(specvalue.FieldDeleteTime) {
		fields = append(fields, specvalue.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpecValueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpecValueMutation) ClearField(name string) error {
	switch name {
	case specvalue.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown SpecValue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpecValueMutation) ResetField(name string) error {
	switch name {
	case specvalue.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case specvalue.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case specvalue.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case specvalue.FieldValue:
		m.ResetValue()
		return nil
	case specvalue.FieldSpecID:
		m.ResetSpecID()
		return nil
	case specvalue.FieldExtend:
		m.ResetExtend()
		return nil
	}
	return fmt.Errorf("unknown SpecValue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpecValueMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpecValueMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpecValueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpecValueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpecValueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpecValueMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpecValueMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SpecValue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpecValueMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SpecValue edge %s", name)
}

// SpuMutation represents an operation that mutates the Spu nodes in the graph.
type SpuMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	create_time           *time.Time
	update_time           *time.Time
	delete_time           *time.Time
	title                 *string
	subtitle              *string
	category_id           *int64
	addcategory_id        *int64
	root_category_id      *int64
	addroot_category_id   *int64
	online                *int
	addonline             *int
	price                 *string
	sketch_spec_id        *int
	addsketch_spec_id     *int
	default_sku_id        *int
	adddefault_sku_id     *int
	img                   *string
	discount_price        *string
	description           *string
	tags                  *string
	spu_theme_img         *string
	for_theme_img         *string
	clearedFields         map[string]struct{}
	sale_explain          map[int64]struct{}
	removedsale_explain   map[int64]struct{}
	clearedsale_explain   bool
	spu_img               map[int64]struct{}
	removedspu_img        map[int64]struct{}
	clearedspu_img        bool
	spu_detail_img        map[int64]struct{}
	removedspu_detail_img map[int64]struct{}
	clearedspu_detail_img bool
	spec_key              map[int64]struct{}
	removedspec_key       map[int64]struct{}
	clearedspec_key       bool
	tag                   map[int64]struct{}
	removedtag            map[int64]struct{}
	clearedtag            bool
	theme                 map[int64]struct{}
	removedtheme          map[int64]struct{}
	clearedtheme          bool
	activity              map[int64]struct{}
	removedactivity       map[int64]struct{}
	clearedactivity       bool
	brand                 map[int64]struct{}
	removedbrand          map[int64]struct{}
	clearedbrand          bool
	done                  bool
	oldValue              func(context.Context) (*Spu, error)
	predicates            []predicate.Spu
}

var _ ent.Mutation = (*SpuMutation)(nil)

// spuOption allows management of the mutation configuration using functional options.
type spuOption func(*SpuMutation)

// newSpuMutation creates new mutation for the Spu entity.
func newSpuMutation(c config, op Op, opts ...spuOption) *SpuMutation {
	m := &SpuMutation{
		config:        c,
		op:            op,
		typ:           TypeSpu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpuID sets the ID field of the mutation.
func withSpuID(id int64) spuOption {
	return func(m *SpuMutation) {
		var (
			err   error
			once  sync.Once
			value *Spu
		)
		m.oldValue = func(ctx context.Context) (*Spu, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Spu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpu sets the old Spu of the mutation.
func withSpu(node *Spu) spuOption {
	return func(m *SpuMutation) {
		m.oldValue = func(context.Context) (*Spu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SpuMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SpuMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SpuMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SpuMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SpuMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SpuMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SpuMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SpuMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SpuMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[spu.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SpuMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[spu.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SpuMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, spu.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *SpuMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SpuMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SpuMutation) ResetTitle() {
	m.title = nil
}

// SetSubtitle sets the "subtitle" field.
func (m *SpuMutation) SetSubtitle(s string) {
	m.subtitle = &s
}

// Subtitle returns the value of the "subtitle" field in the mutation.
func (m *SpuMutation) Subtitle() (r string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old "subtitle" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldSubtitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubtitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ResetSubtitle resets all changes to the "subtitle" field.
func (m *SpuMutation) ResetSubtitle() {
	m.subtitle = nil
}

// SetCategoryID sets the "category_id" field.
func (m *SpuMutation) SetCategoryID(i int64) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *SpuMutation) CategoryID() (r int64, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldCategoryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *SpuMutation) AddCategoryID(i int64) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *SpuMutation) AddedCategoryID() (r int64, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *SpuMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// SetRootCategoryID sets the "root_category_id" field.
func (m *SpuMutation) SetRootCategoryID(i int64) {
	m.root_category_id = &i
	m.addroot_category_id = nil
}

// RootCategoryID returns the value of the "root_category_id" field in the mutation.
func (m *SpuMutation) RootCategoryID() (r int64, exists bool) {
	v := m.root_category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootCategoryID returns the old "root_category_id" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldRootCategoryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRootCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRootCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootCategoryID: %w", err)
	}
	return oldValue.RootCategoryID, nil
}

// AddRootCategoryID adds i to the "root_category_id" field.
func (m *SpuMutation) AddRootCategoryID(i int64) {
	if m.addroot_category_id != nil {
		*m.addroot_category_id += i
	} else {
		m.addroot_category_id = &i
	}
}

// AddedRootCategoryID returns the value that was added to the "root_category_id" field in this mutation.
func (m *SpuMutation) AddedRootCategoryID() (r int64, exists bool) {
	v := m.addroot_category_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRootCategoryID resets all changes to the "root_category_id" field.
func (m *SpuMutation) ResetRootCategoryID() {
	m.root_category_id = nil
	m.addroot_category_id = nil
}

// SetOnline sets the "online" field.
func (m *SpuMutation) SetOnline(i int) {
	m.online = &i
	m.addonline = nil
}

// Online returns the value of the "online" field in the mutation.
func (m *SpuMutation) Online() (r int, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldOnline(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// AddOnline adds i to the "online" field.
func (m *SpuMutation) AddOnline(i int) {
	if m.addonline != nil {
		*m.addonline += i
	} else {
		m.addonline = &i
	}
}

// AddedOnline returns the value that was added to the "online" field in this mutation.
func (m *SpuMutation) AddedOnline() (r int, exists bool) {
	v := m.addonline
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnline resets all changes to the "online" field.
func (m *SpuMutation) ResetOnline() {
	m.online = nil
	m.addonline = nil
}

// SetPrice sets the "price" field.
func (m *SpuMutation) SetPrice(s string) {
	m.price = &s
}

// Price returns the value of the "price" field in the mutation.
func (m *SpuMutation) Price() (r string, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *SpuMutation) ResetPrice() {
	m.price = nil
}

// SetSketchSpecID sets the "sketch_spec_id" field.
func (m *SpuMutation) SetSketchSpecID(i int) {
	m.sketch_spec_id = &i
	m.addsketch_spec_id = nil
}

// SketchSpecID returns the value of the "sketch_spec_id" field in the mutation.
func (m *SpuMutation) SketchSpecID() (r int, exists bool) {
	v := m.sketch_spec_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSketchSpecID returns the old "sketch_spec_id" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldSketchSpecID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSketchSpecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSketchSpecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSketchSpecID: %w", err)
	}
	return oldValue.SketchSpecID, nil
}

// AddSketchSpecID adds i to the "sketch_spec_id" field.
func (m *SpuMutation) AddSketchSpecID(i int) {
	if m.addsketch_spec_id != nil {
		*m.addsketch_spec_id += i
	} else {
		m.addsketch_spec_id = &i
	}
}

// AddedSketchSpecID returns the value that was added to the "sketch_spec_id" field in this mutation.
func (m *SpuMutation) AddedSketchSpecID() (r int, exists bool) {
	v := m.addsketch_spec_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSketchSpecID resets all changes to the "sketch_spec_id" field.
func (m *SpuMutation) ResetSketchSpecID() {
	m.sketch_spec_id = nil
	m.addsketch_spec_id = nil
}

// SetDefaultSkuID sets the "default_sku_id" field.
func (m *SpuMutation) SetDefaultSkuID(i int) {
	m.default_sku_id = &i
	m.adddefault_sku_id = nil
}

// DefaultSkuID returns the value of the "default_sku_id" field in the mutation.
func (m *SpuMutation) DefaultSkuID() (r int, exists bool) {
	v := m.default_sku_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultSkuID returns the old "default_sku_id" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldDefaultSkuID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultSkuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultSkuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultSkuID: %w", err)
	}
	return oldValue.DefaultSkuID, nil
}

// AddDefaultSkuID adds i to the "default_sku_id" field.
func (m *SpuMutation) AddDefaultSkuID(i int) {
	if m.adddefault_sku_id != nil {
		*m.adddefault_sku_id += i
	} else {
		m.adddefault_sku_id = &i
	}
}

// AddedDefaultSkuID returns the value that was added to the "default_sku_id" field in this mutation.
func (m *SpuMutation) AddedDefaultSkuID() (r int, exists bool) {
	v := m.adddefault_sku_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultSkuID resets all changes to the "default_sku_id" field.
func (m *SpuMutation) ResetDefaultSkuID() {
	m.default_sku_id = nil
	m.adddefault_sku_id = nil
}

// SetImg sets the "img" field.
func (m *SpuMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *SpuMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *SpuMutation) ResetImg() {
	m.img = nil
}

// SetDiscountPrice sets the "discount_price" field.
func (m *SpuMutation) SetDiscountPrice(s string) {
	m.discount_price = &s
}

// DiscountPrice returns the value of the "discount_price" field in the mutation.
func (m *SpuMutation) DiscountPrice() (r string, exists bool) {
	v := m.discount_price
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountPrice returns the old "discount_price" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldDiscountPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscountPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscountPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountPrice: %w", err)
	}
	return oldValue.DiscountPrice, nil
}

// ResetDiscountPrice resets all changes to the "discount_price" field.
func (m *SpuMutation) ResetDiscountPrice() {
	m.discount_price = nil
}

// SetDescription sets the "description" field.
func (m *SpuMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SpuMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SpuMutation) ResetDescription() {
	m.description = nil
}

// SetTags sets the "tags" field.
func (m *SpuMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *SpuMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *SpuMutation) ResetTags() {
	m.tags = nil
}

// SetSpuThemeImg sets the "spu_theme_img" field.
func (m *SpuMutation) SetSpuThemeImg(s string) {
	m.spu_theme_img = &s
}

// SpuThemeImg returns the value of the "spu_theme_img" field in the mutation.
func (m *SpuMutation) SpuThemeImg() (r string, exists bool) {
	v := m.spu_theme_img
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuThemeImg returns the old "spu_theme_img" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldSpuThemeImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuThemeImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuThemeImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuThemeImg: %w", err)
	}
	return oldValue.SpuThemeImg, nil
}

// ResetSpuThemeImg resets all changes to the "spu_theme_img" field.
func (m *SpuMutation) ResetSpuThemeImg() {
	m.spu_theme_img = nil
}

// SetForThemeImg sets the "for_theme_img" field.
func (m *SpuMutation) SetForThemeImg(s string) {
	m.for_theme_img = &s
}

// ForThemeImg returns the value of the "for_theme_img" field in the mutation.
func (m *SpuMutation) ForThemeImg() (r string, exists bool) {
	v := m.for_theme_img
	if v == nil {
		return
	}
	return *v, true
}

// OldForThemeImg returns the old "for_theme_img" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldForThemeImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldForThemeImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldForThemeImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForThemeImg: %w", err)
	}
	return oldValue.ForThemeImg, nil
}

// ResetForThemeImg resets all changes to the "for_theme_img" field.
func (m *SpuMutation) ResetForThemeImg() {
	m.for_theme_img = nil
}

// AddSaleExplainIDs adds the "sale_explain" edge to the SaleExplain entity by ids.
func (m *SpuMutation) AddSaleExplainIDs(ids ...int64) {
	if m.sale_explain == nil {
		m.sale_explain = make(map[int64]struct{})
	}
	for i := range ids {
		m.sale_explain[ids[i]] = struct{}{}
	}
}

// ClearSaleExplain clears the "sale_explain" edge to the SaleExplain entity.
func (m *SpuMutation) ClearSaleExplain() {
	m.clearedsale_explain = true
}

// SaleExplainCleared reports if the "sale_explain" edge to the SaleExplain entity was cleared.
func (m *SpuMutation) SaleExplainCleared() bool {
	return m.clearedsale_explain
}

// RemoveSaleExplainIDs removes the "sale_explain" edge to the SaleExplain entity by IDs.
func (m *SpuMutation) RemoveSaleExplainIDs(ids ...int64) {
	if m.removedsale_explain == nil {
		m.removedsale_explain = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sale_explain, ids[i])
		m.removedsale_explain[ids[i]] = struct{}{}
	}
}

// RemovedSaleExplain returns the removed IDs of the "sale_explain" edge to the SaleExplain entity.
func (m *SpuMutation) RemovedSaleExplainIDs() (ids []int64) {
	for id := range m.removedsale_explain {
		ids = append(ids, id)
	}
	return
}

// SaleExplainIDs returns the "sale_explain" edge IDs in the mutation.
func (m *SpuMutation) SaleExplainIDs() (ids []int64) {
	for id := range m.sale_explain {
		ids = append(ids, id)
	}
	return
}

// ResetSaleExplain resets all changes to the "sale_explain" edge.
func (m *SpuMutation) ResetSaleExplain() {
	m.sale_explain = nil
	m.clearedsale_explain = false
	m.removedsale_explain = nil
}

// AddSpuImgIDs adds the "spu_img" edge to the SpuImg entity by ids.
func (m *SpuMutation) AddSpuImgIDs(ids ...int64) {
	if m.spu_img == nil {
		m.spu_img = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu_img[ids[i]] = struct{}{}
	}
}

// ClearSpuImg clears the "spu_img" edge to the SpuImg entity.
func (m *SpuMutation) ClearSpuImg() {
	m.clearedspu_img = true
}

// SpuImgCleared reports if the "spu_img" edge to the SpuImg entity was cleared.
func (m *SpuMutation) SpuImgCleared() bool {
	return m.clearedspu_img
}

// RemoveSpuImgIDs removes the "spu_img" edge to the SpuImg entity by IDs.
func (m *SpuMutation) RemoveSpuImgIDs(ids ...int64) {
	if m.removedspu_img == nil {
		m.removedspu_img = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu_img, ids[i])
		m.removedspu_img[ids[i]] = struct{}{}
	}
}

// RemovedSpuImg returns the removed IDs of the "spu_img" edge to the SpuImg entity.
func (m *SpuMutation) RemovedSpuImgIDs() (ids []int64) {
	for id := range m.removedspu_img {
		ids = append(ids, id)
	}
	return
}

// SpuImgIDs returns the "spu_img" edge IDs in the mutation.
func (m *SpuMutation) SpuImgIDs() (ids []int64) {
	for id := range m.spu_img {
		ids = append(ids, id)
	}
	return
}

// ResetSpuImg resets all changes to the "spu_img" edge.
func (m *SpuMutation) ResetSpuImg() {
	m.spu_img = nil
	m.clearedspu_img = false
	m.removedspu_img = nil
}

// AddSpuDetailImgIDs adds the "spu_detail_img" edge to the SpuDetailImg entity by ids.
func (m *SpuMutation) AddSpuDetailImgIDs(ids ...int64) {
	if m.spu_detail_img == nil {
		m.spu_detail_img = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu_detail_img[ids[i]] = struct{}{}
	}
}

// ClearSpuDetailImg clears the "spu_detail_img" edge to the SpuDetailImg entity.
func (m *SpuMutation) ClearSpuDetailImg() {
	m.clearedspu_detail_img = true
}

// SpuDetailImgCleared reports if the "spu_detail_img" edge to the SpuDetailImg entity was cleared.
func (m *SpuMutation) SpuDetailImgCleared() bool {
	return m.clearedspu_detail_img
}

// RemoveSpuDetailImgIDs removes the "spu_detail_img" edge to the SpuDetailImg entity by IDs.
func (m *SpuMutation) RemoveSpuDetailImgIDs(ids ...int64) {
	if m.removedspu_detail_img == nil {
		m.removedspu_detail_img = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu_detail_img, ids[i])
		m.removedspu_detail_img[ids[i]] = struct{}{}
	}
}

// RemovedSpuDetailImg returns the removed IDs of the "spu_detail_img" edge to the SpuDetailImg entity.
func (m *SpuMutation) RemovedSpuDetailImgIDs() (ids []int64) {
	for id := range m.removedspu_detail_img {
		ids = append(ids, id)
	}
	return
}

// SpuDetailImgIDs returns the "spu_detail_img" edge IDs in the mutation.
func (m *SpuMutation) SpuDetailImgIDs() (ids []int64) {
	for id := range m.spu_detail_img {
		ids = append(ids, id)
	}
	return
}

// ResetSpuDetailImg resets all changes to the "spu_detail_img" edge.
func (m *SpuMutation) ResetSpuDetailImg() {
	m.spu_detail_img = nil
	m.clearedspu_detail_img = false
	m.removedspu_detail_img = nil
}

// AddSpecKeyIDs adds the "spec_key" edge to the SpecKey entity by ids.
func (m *SpuMutation) AddSpecKeyIDs(ids ...int64) {
	if m.spec_key == nil {
		m.spec_key = make(map[int64]struct{})
	}
	for i := range ids {
		m.spec_key[ids[i]] = struct{}{}
	}
}

// ClearSpecKey clears the "spec_key" edge to the SpecKey entity.
func (m *SpuMutation) ClearSpecKey() {
	m.clearedspec_key = true
}

// SpecKeyCleared reports if the "spec_key" edge to the SpecKey entity was cleared.
func (m *SpuMutation) SpecKeyCleared() bool {
	return m.clearedspec_key
}

// RemoveSpecKeyIDs removes the "spec_key" edge to the SpecKey entity by IDs.
func (m *SpuMutation) RemoveSpecKeyIDs(ids ...int64) {
	if m.removedspec_key == nil {
		m.removedspec_key = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spec_key, ids[i])
		m.removedspec_key[ids[i]] = struct{}{}
	}
}

// RemovedSpecKey returns the removed IDs of the "spec_key" edge to the SpecKey entity.
func (m *SpuMutation) RemovedSpecKeyIDs() (ids []int64) {
	for id := range m.removedspec_key {
		ids = append(ids, id)
	}
	return
}

// SpecKeyIDs returns the "spec_key" edge IDs in the mutation.
func (m *SpuMutation) SpecKeyIDs() (ids []int64) {
	for id := range m.spec_key {
		ids = append(ids, id)
	}
	return
}

// ResetSpecKey resets all changes to the "spec_key" edge.
func (m *SpuMutation) ResetSpecKey() {
	m.spec_key = nil
	m.clearedspec_key = false
	m.removedspec_key = nil
}

// AddTagIDs adds the "tag" edge to the Tag entity by ids.
func (m *SpuMutation) AddTagIDs(ids ...int64) {
	if m.tag == nil {
		m.tag = make(map[int64]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *SpuMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *SpuMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the "tag" edge to the Tag entity by IDs.
func (m *SpuMutation) RemoveTagIDs(ids ...int64) {
	if m.removedtag == nil {
		m.removedtag = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tag, ids[i])
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "tag" edge to the Tag entity.
func (m *SpuMutation) RemovedTagIDs() (ids []int64) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
func (m *SpuMutation) TagIDs() (ids []int64) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *SpuMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// AddThemeIDs adds the "theme" edge to the Theme entity by ids.
func (m *SpuMutation) AddThemeIDs(ids ...int64) {
	if m.theme == nil {
		m.theme = make(map[int64]struct{})
	}
	for i := range ids {
		m.theme[ids[i]] = struct{}{}
	}
}

// ClearTheme clears the "theme" edge to the Theme entity.
func (m *SpuMutation) ClearTheme() {
	m.clearedtheme = true
}

// ThemeCleared reports if the "theme" edge to the Theme entity was cleared.
func (m *SpuMutation) ThemeCleared() bool {
	return m.clearedtheme
}

// RemoveThemeIDs removes the "theme" edge to the Theme entity by IDs.
func (m *SpuMutation) RemoveThemeIDs(ids ...int64) {
	if m.removedtheme == nil {
		m.removedtheme = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.theme, ids[i])
		m.removedtheme[ids[i]] = struct{}{}
	}
}

// RemovedTheme returns the removed IDs of the "theme" edge to the Theme entity.
func (m *SpuMutation) RemovedThemeIDs() (ids []int64) {
	for id := range m.removedtheme {
		ids = append(ids, id)
	}
	return
}

// ThemeIDs returns the "theme" edge IDs in the mutation.
func (m *SpuMutation) ThemeIDs() (ids []int64) {
	for id := range m.theme {
		ids = append(ids, id)
	}
	return
}

// ResetTheme resets all changes to the "theme" edge.
func (m *SpuMutation) ResetTheme() {
	m.theme = nil
	m.clearedtheme = false
	m.removedtheme = nil
}

// AddActivityIDs adds the "activity" edge to the Activity entity by ids.
func (m *SpuMutation) AddActivityIDs(ids ...int64) {
	if m.activity == nil {
		m.activity = make(map[int64]struct{})
	}
	for i := range ids {
		m.activity[ids[i]] = struct{}{}
	}
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *SpuMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *SpuMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// RemoveActivityIDs removes the "activity" edge to the Activity entity by IDs.
func (m *SpuMutation) RemoveActivityIDs(ids ...int64) {
	if m.removedactivity == nil {
		m.removedactivity = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.activity, ids[i])
		m.removedactivity[ids[i]] = struct{}{}
	}
}

// RemovedActivity returns the removed IDs of the "activity" edge to the Activity entity.
func (m *SpuMutation) RemovedActivityIDs() (ids []int64) {
	for id := range m.removedactivity {
		ids = append(ids, id)
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
func (m *SpuMutation) ActivityIDs() (ids []int64) {
	for id := range m.activity {
		ids = append(ids, id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *SpuMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
	m.removedactivity = nil
}

// AddBrandIDs adds the "brand" edge to the Brand entity by ids.
func (m *SpuMutation) AddBrandIDs(ids ...int64) {
	if m.brand == nil {
		m.brand = make(map[int64]struct{})
	}
	for i := range ids {
		m.brand[ids[i]] = struct{}{}
	}
}

// ClearBrand clears the "brand" edge to the Brand entity.
func (m *SpuMutation) ClearBrand() {
	m.clearedbrand = true
}

// BrandCleared reports if the "brand" edge to the Brand entity was cleared.
func (m *SpuMutation) BrandCleared() bool {
	return m.clearedbrand
}

// RemoveBrandIDs removes the "brand" edge to the Brand entity by IDs.
func (m *SpuMutation) RemoveBrandIDs(ids ...int64) {
	if m.removedbrand == nil {
		m.removedbrand = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.brand, ids[i])
		m.removedbrand[ids[i]] = struct{}{}
	}
}

// RemovedBrand returns the removed IDs of the "brand" edge to the Brand entity.
func (m *SpuMutation) RemovedBrandIDs() (ids []int64) {
	for id := range m.removedbrand {
		ids = append(ids, id)
	}
	return
}

// BrandIDs returns the "brand" edge IDs in the mutation.
func (m *SpuMutation) BrandIDs() (ids []int64) {
	for id := range m.brand {
		ids = append(ids, id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *SpuMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
	m.removedbrand = nil
}

// Where appends a list predicates to the SpuMutation builder.
func (m *SpuMutation) Where(ps ...predicate.Spu) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SpuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Spu).
func (m *SpuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpuMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.create_time != nil {
		fields = append(fields, spu.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, spu.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, spu.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, spu.FieldTitle)
	}
	if m.subtitle != nil {
		fields = append(fields, spu.FieldSubtitle)
	}
	if m.category_id != nil {
		fields = append(fields, spu.FieldCategoryID)
	}
	if m.root_category_id != nil {
		fields = append(fields, spu.FieldRootCategoryID)
	}
	if m.online != nil {
		fields = append(fields, spu.FieldOnline)
	}
	if m.price != nil {
		fields = append(fields, spu.FieldPrice)
	}
	if m.sketch_spec_id != nil {
		fields = append(fields, spu.FieldSketchSpecID)
	}
	if m.default_sku_id != nil {
		fields = append(fields, spu.FieldDefaultSkuID)
	}
	if m.img != nil {
		fields = append(fields, spu.FieldImg)
	}
	if m.discount_price != nil {
		fields = append(fields, spu.FieldDiscountPrice)
	}
	if m.description != nil {
		fields = append(fields, spu.FieldDescription)
	}
	if m.tags != nil {
		fields = append(fields, spu.FieldTags)
	}
	if m.spu_theme_img != nil {
		fields = append(fields, spu.FieldSpuThemeImg)
	}
	if m.for_theme_img != nil {
		fields = append(fields, spu.FieldForThemeImg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spu.FieldCreateTime:
		return m.CreateTime()
	case spu.FieldUpdateTime:
		return m.UpdateTime()
	case spu.FieldDeleteTime:
		return m.DeleteTime()
	case spu.FieldTitle:
		return m.Title()
	case spu.FieldSubtitle:
		return m.Subtitle()
	case spu.FieldCategoryID:
		return m.CategoryID()
	case spu.FieldRootCategoryID:
		return m.RootCategoryID()
	case spu.FieldOnline:
		return m.Online()
	case spu.FieldPrice:
		return m.Price()
	case spu.FieldSketchSpecID:
		return m.SketchSpecID()
	case spu.FieldDefaultSkuID:
		return m.DefaultSkuID()
	case spu.FieldImg:
		return m.Img()
	case spu.FieldDiscountPrice:
		return m.DiscountPrice()
	case spu.FieldDescription:
		return m.Description()
	case spu.FieldTags:
		return m.Tags()
	case spu.FieldSpuThemeImg:
		return m.SpuThemeImg()
	case spu.FieldForThemeImg:
		return m.ForThemeImg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spu.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case spu.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case spu.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case spu.FieldTitle:
		return m.OldTitle(ctx)
	case spu.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case spu.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case spu.FieldRootCategoryID:
		return m.OldRootCategoryID(ctx)
	case spu.FieldOnline:
		return m.OldOnline(ctx)
	case spu.FieldPrice:
		return m.OldPrice(ctx)
	case spu.FieldSketchSpecID:
		return m.OldSketchSpecID(ctx)
	case spu.FieldDefaultSkuID:
		return m.OldDefaultSkuID(ctx)
	case spu.FieldImg:
		return m.OldImg(ctx)
	case spu.FieldDiscountPrice:
		return m.OldDiscountPrice(ctx)
	case spu.FieldDescription:
		return m.OldDescription(ctx)
	case spu.FieldTags:
		return m.OldTags(ctx)
	case spu.FieldSpuThemeImg:
		return m.OldSpuThemeImg(ctx)
	case spu.FieldForThemeImg:
		return m.OldForThemeImg(ctx)
	}
	return nil, fmt.Errorf("unknown Spu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spu.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case spu.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case spu.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case spu.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case spu.FieldSubtitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case spu.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case spu.FieldRootCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootCategoryID(v)
		return nil
	case spu.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case spu.FieldPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case spu.FieldSketchSpecID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSketchSpecID(v)
		return nil
	case spu.FieldDefaultSkuID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultSkuID(v)
		return nil
	case spu.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case spu.FieldDiscountPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountPrice(v)
		return nil
	case spu.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case spu.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case spu.FieldSpuThemeImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuThemeImg(v)
		return nil
	case spu.FieldForThemeImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForThemeImg(v)
		return nil
	}
	return fmt.Errorf("unknown Spu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpuMutation) AddedFields() []string {
	var fields []string
	if m.addcategory_id != nil {
		fields = append(fields, spu.FieldCategoryID)
	}
	if m.addroot_category_id != nil {
		fields = append(fields, spu.FieldRootCategoryID)
	}
	if m.addonline != nil {
		fields = append(fields, spu.FieldOnline)
	}
	if m.addsketch_spec_id != nil {
		fields = append(fields, spu.FieldSketchSpecID)
	}
	if m.adddefault_sku_id != nil {
		fields = append(fields, spu.FieldDefaultSkuID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case spu.FieldCategoryID:
		return m.AddedCategoryID()
	case spu.FieldRootCategoryID:
		return m.AddedRootCategoryID()
	case spu.FieldOnline:
		return m.AddedOnline()
	case spu.FieldSketchSpecID:
		return m.AddedSketchSpecID()
	case spu.FieldDefaultSkuID:
		return m.AddedDefaultSkuID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case spu.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	case spu.FieldRootCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRootCategoryID(v)
		return nil
	case spu.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnline(v)
		return nil
	case spu.FieldSketchSpecID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSketchSpecID(v)
		return nil
	case spu.FieldDefaultSkuID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultSkuID(v)
		return nil
	}
	return fmt.Errorf("unknown Spu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spu.FieldDeleteTime) {
		fields = append(fields, spu.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpuMutation) ClearField(name string) error {
	switch name {
	case spu.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Spu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpuMutation) ResetField(name string) error {
	switch name {
	case spu.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case spu.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case spu.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case spu.FieldTitle:
		m.ResetTitle()
		return nil
	case spu.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case spu.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case spu.FieldRootCategoryID:
		m.ResetRootCategoryID()
		return nil
	case spu.FieldOnline:
		m.ResetOnline()
		return nil
	case spu.FieldPrice:
		m.ResetPrice()
		return nil
	case spu.FieldSketchSpecID:
		m.ResetSketchSpecID()
		return nil
	case spu.FieldDefaultSkuID:
		m.ResetDefaultSkuID()
		return nil
	case spu.FieldImg:
		m.ResetImg()
		return nil
	case spu.FieldDiscountPrice:
		m.ResetDiscountPrice()
		return nil
	case spu.FieldDescription:
		m.ResetDescription()
		return nil
	case spu.FieldTags:
		m.ResetTags()
		return nil
	case spu.FieldSpuThemeImg:
		m.ResetSpuThemeImg()
		return nil
	case spu.FieldForThemeImg:
		m.ResetForThemeImg()
		return nil
	}
	return fmt.Errorf("unknown Spu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpuMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.sale_explain != nil {
		edges = append(edges, spu.EdgeSaleExplain)
	}
	if m.spu_img != nil {
		edges = append(edges, spu.EdgeSpuImg)
	}
	if m.spu_detail_img != nil {
		edges = append(edges, spu.EdgeSpuDetailImg)
	}
	if m.spec_key != nil {
		edges = append(edges, spu.EdgeSpecKey)
	}
	if m.tag != nil {
		edges = append(edges, spu.EdgeTag)
	}
	if m.theme != nil {
		edges = append(edges, spu.EdgeTheme)
	}
	if m.activity != nil {
		edges = append(edges, spu.EdgeActivity)
	}
	if m.brand != nil {
		edges = append(edges, spu.EdgeBrand)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spu.EdgeSaleExplain:
		ids := make([]ent.Value, 0, len(m.sale_explain))
		for id := range m.sale_explain {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpuImg:
		ids := make([]ent.Value, 0, len(m.spu_img))
		for id := range m.spu_img {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpuDetailImg:
		ids := make([]ent.Value, 0, len(m.spu_detail_img))
		for id := range m.spu_detail_img {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpecKey:
		ids := make([]ent.Value, 0, len(m.spec_key))
		for id := range m.spec_key {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeTheme:
		ids := make([]ent.Value, 0, len(m.theme))
		for id := range m.theme {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeActivity:
		ids := make([]ent.Value, 0, len(m.activity))
		for id := range m.activity {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeBrand:
		ids := make([]ent.Value, 0, len(m.brand))
		for id := range m.brand {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedsale_explain != nil {
		edges = append(edges, spu.EdgeSaleExplain)
	}
	if m.removedspu_img != nil {
		edges = append(edges, spu.EdgeSpuImg)
	}
	if m.removedspu_detail_img != nil {
		edges = append(edges, spu.EdgeSpuDetailImg)
	}
	if m.removedspec_key != nil {
		edges = append(edges, spu.EdgeSpecKey)
	}
	if m.removedtag != nil {
		edges = append(edges, spu.EdgeTag)
	}
	if m.removedtheme != nil {
		edges = append(edges, spu.EdgeTheme)
	}
	if m.removedactivity != nil {
		edges = append(edges, spu.EdgeActivity)
	}
	if m.removedbrand != nil {
		edges = append(edges, spu.EdgeBrand)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case spu.EdgeSaleExplain:
		ids := make([]ent.Value, 0, len(m.removedsale_explain))
		for id := range m.removedsale_explain {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpuImg:
		ids := make([]ent.Value, 0, len(m.removedspu_img))
		for id := range m.removedspu_img {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpuDetailImg:
		ids := make([]ent.Value, 0, len(m.removedspu_detail_img))
		for id := range m.removedspu_detail_img {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpecKey:
		ids := make([]ent.Value, 0, len(m.removedspec_key))
		for id := range m.removedspec_key {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeTheme:
		ids := make([]ent.Value, 0, len(m.removedtheme))
		for id := range m.removedtheme {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeActivity:
		ids := make([]ent.Value, 0, len(m.removedactivity))
		for id := range m.removedactivity {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeBrand:
		ids := make([]ent.Value, 0, len(m.removedbrand))
		for id := range m.removedbrand {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedsale_explain {
		edges = append(edges, spu.EdgeSaleExplain)
	}
	if m.clearedspu_img {
		edges = append(edges, spu.EdgeSpuImg)
	}
	if m.clearedspu_detail_img {
		edges = append(edges, spu.EdgeSpuDetailImg)
	}
	if m.clearedspec_key {
		edges = append(edges, spu.EdgeSpecKey)
	}
	if m.clearedtag {
		edges = append(edges, spu.EdgeTag)
	}
	if m.clearedtheme {
		edges = append(edges, spu.EdgeTheme)
	}
	if m.clearedactivity {
		edges = append(edges, spu.EdgeActivity)
	}
	if m.clearedbrand {
		edges = append(edges, spu.EdgeBrand)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpuMutation) EdgeCleared(name string) bool {
	switch name {
	case spu.EdgeSaleExplain:
		return m.clearedsale_explain
	case spu.EdgeSpuImg:
		return m.clearedspu_img
	case spu.EdgeSpuDetailImg:
		return m.clearedspu_detail_img
	case spu.EdgeSpecKey:
		return m.clearedspec_key
	case spu.EdgeTag:
		return m.clearedtag
	case spu.EdgeTheme:
		return m.clearedtheme
	case spu.EdgeActivity:
		return m.clearedactivity
	case spu.EdgeBrand:
		return m.clearedbrand
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpuMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Spu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpuMutation) ResetEdge(name string) error {
	switch name {
	case spu.EdgeSaleExplain:
		m.ResetSaleExplain()
		return nil
	case spu.EdgeSpuImg:
		m.ResetSpuImg()
		return nil
	case spu.EdgeSpuDetailImg:
		m.ResetSpuDetailImg()
		return nil
	case spu.EdgeSpecKey:
		m.ResetSpecKey()
		return nil
	case spu.EdgeTag:
		m.ResetTag()
		return nil
	case spu.EdgeTheme:
		m.ResetTheme()
		return nil
	case spu.EdgeActivity:
		m.ResetActivity()
		return nil
	case spu.EdgeBrand:
		m.ResetBrand()
		return nil
	}
	return fmt.Errorf("unknown Spu edge %s", name)
}

// SpuDetailImgMutation represents an operation that mutates the SpuDetailImg nodes in the graph.
type SpuDetailImgMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	img           *string
	index         *int
	addindex      *int
	clearedFields map[string]struct{}
	spu           *int64
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*SpuDetailImg, error)
	predicates    []predicate.SpuDetailImg
}

var _ ent.Mutation = (*SpuDetailImgMutation)(nil)

// spudetailimgOption allows management of the mutation configuration using functional options.
type spudetailimgOption func(*SpuDetailImgMutation)

// newSpuDetailImgMutation creates new mutation for the SpuDetailImg entity.
func newSpuDetailImgMutation(c config, op Op, opts ...spudetailimgOption) *SpuDetailImgMutation {
	m := &SpuDetailImgMutation{
		config:        c,
		op:            op,
		typ:           TypeSpuDetailImg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpuDetailImgID sets the ID field of the mutation.
func withSpuDetailImgID(id int64) spudetailimgOption {
	return func(m *SpuDetailImgMutation) {
		var (
			err   error
			once  sync.Once
			value *SpuDetailImg
		)
		m.oldValue = func(ctx context.Context) (*SpuDetailImg, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpuDetailImg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpuDetailImg sets the old SpuDetailImg of the mutation.
func withSpuDetailImg(node *SpuDetailImg) spudetailimgOption {
	return func(m *SpuDetailImgMutation) {
		m.oldValue = func(context.Context) (*SpuDetailImg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpuDetailImgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpuDetailImgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpuDetailImgMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SpuDetailImgMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SpuDetailImgMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SpuDetailImgMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SpuDetailImgMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SpuDetailImgMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SpuDetailImgMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SpuDetailImgMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SpuDetailImgMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SpuDetailImgMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[spudetailimg.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SpuDetailImgMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[spudetailimg.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SpuDetailImgMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, spudetailimg.FieldDeleteTime)
}

// SetImg sets the "img" field.
func (m *SpuDetailImgMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *SpuDetailImgMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *SpuDetailImgMutation) ResetImg() {
	m.img = nil
}

// SetSpuID sets the "spu_id" field.
func (m *SpuDetailImgMutation) SetSpuID(i int64) {
	m.spu = &i
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *SpuDetailImgMutation) SpuID() (r int64, exists bool) {
	v := m.spu
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// ClearSpuID clears the value of the "spu_id" field.
func (m *SpuDetailImgMutation) ClearSpuID() {
	m.spu = nil
	m.clearedFields[spudetailimg.FieldSpuID] = struct{}{}
}

// SpuIDCleared returns if the "spu_id" field was cleared in this mutation.
func (m *SpuDetailImgMutation) SpuIDCleared() bool {
	_, ok := m.clearedFields[spudetailimg.FieldSpuID]
	return ok
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *SpuDetailImgMutation) ResetSpuID() {
	m.spu = nil
	delete(m.clearedFields, spudetailimg.FieldSpuID)
}

// SetIndex sets the "index" field.
func (m *SpuDetailImgMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *SpuDetailImgMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *SpuDetailImgMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *SpuDetailImgMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *SpuDetailImgMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *SpuDetailImgMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *SpuDetailImgMutation) SpuCleared() bool {
	return m.SpuIDCleared() || m.clearedspu
}

// SpuIDs returns the "spu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpuID instead. It exists only for internal usage by the builders.
func (m *SpuDetailImgMutation) SpuIDs() (ids []int64) {
	if id := m.spu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *SpuDetailImgMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
}

// Where appends a list predicates to the SpuDetailImgMutation builder.
func (m *SpuDetailImgMutation) Where(ps ...predicate.SpuDetailImg) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SpuDetailImgMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SpuDetailImg).
func (m *SpuDetailImgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpuDetailImgMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, spudetailimg.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, spudetailimg.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, spudetailimg.FieldDeleteTime)
	}
	if m.img != nil {
		fields = append(fields, spudetailimg.FieldImg)
	}
	if m.spu != nil {
		fields = append(fields, spudetailimg.FieldSpuID)
	}
	if m.index != nil {
		fields = append(fields, spudetailimg.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpuDetailImgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spudetailimg.FieldCreateTime:
		return m.CreateTime()
	case spudetailimg.FieldUpdateTime:
		return m.UpdateTime()
	case spudetailimg.FieldDeleteTime:
		return m.DeleteTime()
	case spudetailimg.FieldImg:
		return m.Img()
	case spudetailimg.FieldSpuID:
		return m.SpuID()
	case spudetailimg.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpuDetailImgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spudetailimg.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case spudetailimg.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case spudetailimg.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case spudetailimg.FieldImg:
		return m.OldImg(ctx)
	case spudetailimg.FieldSpuID:
		return m.OldSpuID(ctx)
	case spudetailimg.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown SpuDetailImg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuDetailImgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spudetailimg.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case spudetailimg.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case spudetailimg.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case spudetailimg.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case spudetailimg.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case spudetailimg.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpuDetailImgMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, spudetailimg.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpuDetailImgMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case spudetailimg.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuDetailImgMutation) AddField(name string, value ent.Value) error {
	switch name {
	case spudetailimg.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpuDetailImgMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spudetailimg.FieldDeleteTime) {
		fields = append(fields, spudetailimg.FieldDeleteTime)
	}
	if m.FieldCleared(spudetailimg.FieldSpuID) {
		fields = append(fields, spudetailimg.FieldSpuID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpuDetailImgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpuDetailImgMutation) ClearField(name string) error {
	switch name {
	case spudetailimg.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case spudetailimg.FieldSpuID:
		m.ClearSpuID()
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpuDetailImgMutation) ResetField(name string) error {
	switch name {
	case spudetailimg.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case spudetailimg.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case spudetailimg.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case spudetailimg.FieldImg:
		m.ResetImg()
		return nil
	case spudetailimg.FieldSpuID:
		m.ResetSpuID()
		return nil
	case spudetailimg.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpuDetailImgMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, spudetailimg.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpuDetailImgMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spudetailimg.EdgeSpu:
		if id := m.spu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpuDetailImgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpuDetailImgMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpuDetailImgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, spudetailimg.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpuDetailImgMutation) EdgeCleared(name string) bool {
	switch name {
	case spudetailimg.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpuDetailImgMutation) ClearEdge(name string) error {
	switch name {
	case spudetailimg.EdgeSpu:
		m.ClearSpu()
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpuDetailImgMutation) ResetEdge(name string) error {
	switch name {
	case spudetailimg.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg edge %s", name)
}

// SpuImgMutation represents an operation that mutates the SpuImg nodes in the graph.
type SpuImgMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	img           *string
	clearedFields map[string]struct{}
	spu           *int64
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*SpuImg, error)
	predicates    []predicate.SpuImg
}

var _ ent.Mutation = (*SpuImgMutation)(nil)

// spuimgOption allows management of the mutation configuration using functional options.
type spuimgOption func(*SpuImgMutation)

// newSpuImgMutation creates new mutation for the SpuImg entity.
func newSpuImgMutation(c config, op Op, opts ...spuimgOption) *SpuImgMutation {
	m := &SpuImgMutation{
		config:        c,
		op:            op,
		typ:           TypeSpuImg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpuImgID sets the ID field of the mutation.
func withSpuImgID(id int64) spuimgOption {
	return func(m *SpuImgMutation) {
		var (
			err   error
			once  sync.Once
			value *SpuImg
		)
		m.oldValue = func(ctx context.Context) (*SpuImg, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpuImg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpuImg sets the old SpuImg of the mutation.
func withSpuImg(node *SpuImg) spuimgOption {
	return func(m *SpuImgMutation) {
		m.oldValue = func(context.Context) (*SpuImg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpuImgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpuImgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpuImgMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SpuImgMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SpuImgMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SpuImg entity.
// If the SpuImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuImgMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SpuImgMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SpuImgMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SpuImgMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SpuImg entity.
// If the SpuImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuImgMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SpuImgMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SpuImgMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SpuImgMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SpuImg entity.
// If the SpuImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuImgMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SpuImgMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[spuimg.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SpuImgMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[spuimg.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SpuImgMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, spuimg.FieldDeleteTime)
}

// SetImg sets the "img" field.
func (m *SpuImgMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *SpuImgMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the SpuImg entity.
// If the SpuImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuImgMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *SpuImgMutation) ResetImg() {
	m.img = nil
}

// SetSpuID sets the "spu_id" field.
func (m *SpuImgMutation) SetSpuID(i int64) {
	m.spu = &i
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *SpuImgMutation) SpuID() (r int64, exists bool) {
	v := m.spu
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the SpuImg entity.
// If the SpuImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuImgMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// ClearSpuID clears the value of the "spu_id" field.
func (m *SpuImgMutation) ClearSpuID() {
	m.spu = nil
	m.clearedFields[spuimg.FieldSpuID] = struct{}{}
}

// SpuIDCleared returns if the "spu_id" field was cleared in this mutation.
func (m *SpuImgMutation) SpuIDCleared() bool {
	_, ok := m.clearedFields[spuimg.FieldSpuID]
	return ok
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *SpuImgMutation) ResetSpuID() {
	m.spu = nil
	delete(m.clearedFields, spuimg.FieldSpuID)
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *SpuImgMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *SpuImgMutation) SpuCleared() bool {
	return m.SpuIDCleared() || m.clearedspu
}

// SpuIDs returns the "spu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpuID instead. It exists only for internal usage by the builders.
func (m *SpuImgMutation) SpuIDs() (ids []int64) {
	if id := m.spu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *SpuImgMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
}

// Where appends a list predicates to the SpuImgMutation builder.
func (m *SpuImgMutation) Where(ps ...predicate.SpuImg) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SpuImgMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SpuImg).
func (m *SpuImgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpuImgMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, spuimg.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, spuimg.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, spuimg.FieldDeleteTime)
	}
	if m.img != nil {
		fields = append(fields, spuimg.FieldImg)
	}
	if m.spu != nil {
		fields = append(fields, spuimg.FieldSpuID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpuImgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spuimg.FieldCreateTime:
		return m.CreateTime()
	case spuimg.FieldUpdateTime:
		return m.UpdateTime()
	case spuimg.FieldDeleteTime:
		return m.DeleteTime()
	case spuimg.FieldImg:
		return m.Img()
	case spuimg.FieldSpuID:
		return m.SpuID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpuImgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spuimg.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case spuimg.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case spuimg.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case spuimg.FieldImg:
		return m.OldImg(ctx)
	case spuimg.FieldSpuID:
		return m.OldSpuID(ctx)
	}
	return nil, fmt.Errorf("unknown SpuImg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuImgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spuimg.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case spuimg.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case spuimg.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case spuimg.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case spuimg.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	}
	return fmt.Errorf("unknown SpuImg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpuImgMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpuImgMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuImgMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SpuImg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpuImgMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spuimg.FieldDeleteTime) {
		fields = append(fields, spuimg.FieldDeleteTime)
	}
	if m.FieldCleared(spuimg.FieldSpuID) {
		fields = append(fields, spuimg.FieldSpuID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpuImgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpuImgMutation) ClearField(name string) error {
	switch name {
	case spuimg.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case spuimg.FieldSpuID:
		m.ClearSpuID()
		return nil
	}
	return fmt.Errorf("unknown SpuImg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpuImgMutation) ResetField(name string) error {
	switch name {
	case spuimg.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case spuimg.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case spuimg.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case spuimg.FieldImg:
		m.ResetImg()
		return nil
	case spuimg.FieldSpuID:
		m.ResetSpuID()
		return nil
	}
	return fmt.Errorf("unknown SpuImg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpuImgMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, spuimg.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpuImgMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spuimg.EdgeSpu:
		if id := m.spu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpuImgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpuImgMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpuImgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, spuimg.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpuImgMutation) EdgeCleared(name string) bool {
	switch name {
	case spuimg.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpuImgMutation) ClearEdge(name string) error {
	switch name {
	case spuimg.EdgeSpu:
		m.ClearSpu()
		return nil
	}
	return fmt.Errorf("unknown SpuImg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpuImgMutation) ResetEdge(name string) error {
	switch name {
	case spuimg.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown SpuImg edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	title         *string
	description   *string
	highlight     *int
	addhighlight  *int
	_type         *int
	add_type      *int
	clearedFields map[string]struct{}
	spu           map[int64]struct{}
	removedspu    map[int64]struct{}
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int64) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *TagMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TagMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TagMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TagMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TagMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TagMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *TagMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *TagMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *TagMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[tag.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *TagMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[tag.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *TagMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, tag.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *TagMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TagMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TagMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
}

// SetHighlight sets the "highlight" field.
func (m *TagMutation) SetHighlight(i int) {
	m.highlight = &i
	m.addhighlight = nil
}

// Highlight returns the value of the "highlight" field in the mutation.
func (m *TagMutation) Highlight() (r int, exists bool) {
	v := m.highlight
	if v == nil {
		return
	}
	return *v, true
}

// OldHighlight returns the old "highlight" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldHighlight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHighlight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHighlight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighlight: %w", err)
	}
	return oldValue.Highlight, nil
}

// AddHighlight adds i to the "highlight" field.
func (m *TagMutation) AddHighlight(i int) {
	if m.addhighlight != nil {
		*m.addhighlight += i
	} else {
		m.addhighlight = &i
	}
}

// AddedHighlight returns the value that was added to the "highlight" field in this mutation.
func (m *TagMutation) AddedHighlight() (r int, exists bool) {
	v := m.addhighlight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHighlight resets all changes to the "highlight" field.
func (m *TagMutation) ResetHighlight() {
	m.highlight = nil
	m.addhighlight = nil
}

// SetType sets the "type" field.
func (m *TagMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *TagMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *TagMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *TagMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *TagMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// AddSpuIDs adds the "spu" edge to the Spu entity by ids.
func (m *TagMutation) AddSpuIDs(ids ...int64) {
	if m.spu == nil {
		m.spu = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu[ids[i]] = struct{}{}
	}
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *TagMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *TagMutation) SpuCleared() bool {
	return m.clearedspu
}

// RemoveSpuIDs removes the "spu" edge to the Spu entity by IDs.
func (m *TagMutation) RemoveSpuIDs(ids ...int64) {
	if m.removedspu == nil {
		m.removedspu = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu, ids[i])
		m.removedspu[ids[i]] = struct{}{}
	}
}

// RemovedSpu returns the removed IDs of the "spu" edge to the Spu entity.
func (m *TagMutation) RemovedSpuIDs() (ids []int64) {
	for id := range m.removedspu {
		ids = append(ids, id)
	}
	return
}

// SpuIDs returns the "spu" edge IDs in the mutation.
func (m *TagMutation) SpuIDs() (ids []int64) {
	for id := range m.spu {
		ids = append(ids, id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *TagMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
	m.removedspu = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, tag.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tag.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, tag.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, tag.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.highlight != nil {
		fields = append(fields, tag.FieldHighlight)
	}
	if m._type != nil {
		fields = append(fields, tag.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreateTime:
		return m.CreateTime()
	case tag.FieldUpdateTime:
		return m.UpdateTime()
	case tag.FieldDeleteTime:
		return m.DeleteTime()
	case tag.FieldTitle:
		return m.Title()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldHighlight:
		return m.Highlight()
	case tag.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tag.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tag.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case tag.FieldTitle:
		return m.OldTitle(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldHighlight:
		return m.OldHighlight(ctx)
	case tag.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tag.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tag.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case tag.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldHighlight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighlight(v)
		return nil
	case tag.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	if m.addhighlight != nil {
		fields = append(fields, tag.FieldHighlight)
	}
	if m.add_type != nil {
		fields = append(fields, tag.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldHighlight:
		return m.AddedHighlight()
	case tag.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tag.FieldHighlight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighlight(v)
		return nil
	case tag.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDeleteTime) {
		fields = append(fields, tag.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tag.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tag.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case tag.FieldTitle:
		m.ResetTitle()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldHighlight:
		m.ResetHighlight()
		return nil
	case tag.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, tag.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.spu))
		for id := range m.spu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedspu != nil {
		edges = append(edges, tag.EdgeSpu)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.removedspu))
		for id := range m.removedspu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, tag.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// ThemeMutation represents an operation that mutates the Theme nodes in the graph.
type ThemeMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	create_time      *time.Time
	update_time      *time.Time
	delete_time      *time.Time
	title            *string
	description      *string
	name             *string
	tpl_name         *string
	entrance_img     *string
	extend           *string
	internal_top_img *string
	title_img        *string
	online           *int
	addonline        *int
	clearedFields    map[string]struct{}
	spu              map[int64]struct{}
	removedspu       map[int64]struct{}
	clearedspu       bool
	done             bool
	oldValue         func(context.Context) (*Theme, error)
	predicates       []predicate.Theme
}

var _ ent.Mutation = (*ThemeMutation)(nil)

// themeOption allows management of the mutation configuration using functional options.
type themeOption func(*ThemeMutation)

// newThemeMutation creates new mutation for the Theme entity.
func newThemeMutation(c config, op Op, opts ...themeOption) *ThemeMutation {
	m := &ThemeMutation{
		config:        c,
		op:            op,
		typ:           TypeTheme,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThemeID sets the ID field of the mutation.
func withThemeID(id int64) themeOption {
	return func(m *ThemeMutation) {
		var (
			err   error
			once  sync.Once
			value *Theme
		)
		m.oldValue = func(ctx context.Context) (*Theme, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Theme.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTheme sets the old Theme of the mutation.
func withTheme(node *Theme) themeOption {
	return func(m *ThemeMutation) {
		m.oldValue = func(context.Context) (*Theme, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThemeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThemeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThemeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ThemeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ThemeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ThemeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ThemeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ThemeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ThemeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *ThemeMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *ThemeMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *ThemeMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[theme.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *ThemeMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[theme.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *ThemeMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, theme.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *ThemeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ThemeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ThemeMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ThemeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ThemeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ThemeMutation) ResetDescription() {
	m.description = nil
}

// SetName sets the "name" field.
func (m *ThemeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ThemeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ThemeMutation) ResetName() {
	m.name = nil
}

// SetTplName sets the "tpl_name" field.
func (m *ThemeMutation) SetTplName(s string) {
	m.tpl_name = &s
}

// TplName returns the value of the "tpl_name" field in the mutation.
func (m *ThemeMutation) TplName() (r string, exists bool) {
	v := m.tpl_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTplName returns the old "tpl_name" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldTplName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTplName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTplName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTplName: %w", err)
	}
	return oldValue.TplName, nil
}

// ResetTplName resets all changes to the "tpl_name" field.
func (m *ThemeMutation) ResetTplName() {
	m.tpl_name = nil
}

// SetEntranceImg sets the "entrance_img" field.
func (m *ThemeMutation) SetEntranceImg(s string) {
	m.entrance_img = &s
}

// EntranceImg returns the value of the "entrance_img" field in the mutation.
func (m *ThemeMutation) EntranceImg() (r string, exists bool) {
	v := m.entrance_img
	if v == nil {
		return
	}
	return *v, true
}

// OldEntranceImg returns the old "entrance_img" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldEntranceImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEntranceImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEntranceImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntranceImg: %w", err)
	}
	return oldValue.EntranceImg, nil
}

// ResetEntranceImg resets all changes to the "entrance_img" field.
func (m *ThemeMutation) ResetEntranceImg() {
	m.entrance_img = nil
}

// SetExtend sets the "extend" field.
func (m *ThemeMutation) SetExtend(s string) {
	m.extend = &s
}

// Extend returns the value of the "extend" field in the mutation.
func (m *ThemeMutation) Extend() (r string, exists bool) {
	v := m.extend
	if v == nil {
		return
	}
	return *v, true
}

// OldExtend returns the old "extend" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldExtend(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExtend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExtend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtend: %w", err)
	}
	return oldValue.Extend, nil
}

// ResetExtend resets all changes to the "extend" field.
func (m *ThemeMutation) ResetExtend() {
	m.extend = nil
}

// SetInternalTopImg sets the "internal_top_img" field.
func (m *ThemeMutation) SetInternalTopImg(s string) {
	m.internal_top_img = &s
}

// InternalTopImg returns the value of the "internal_top_img" field in the mutation.
func (m *ThemeMutation) InternalTopImg() (r string, exists bool) {
	v := m.internal_top_img
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalTopImg returns the old "internal_top_img" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldInternalTopImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInternalTopImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInternalTopImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalTopImg: %w", err)
	}
	return oldValue.InternalTopImg, nil
}

// ResetInternalTopImg resets all changes to the "internal_top_img" field.
func (m *ThemeMutation) ResetInternalTopImg() {
	m.internal_top_img = nil
}

// SetTitleImg sets the "title_img" field.
func (m *ThemeMutation) SetTitleImg(s string) {
	m.title_img = &s
}

// TitleImg returns the value of the "title_img" field in the mutation.
func (m *ThemeMutation) TitleImg() (r string, exists bool) {
	v := m.title_img
	if v == nil {
		return
	}
	return *v, true
}

// OldTitleImg returns the old "title_img" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldTitleImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitleImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitleImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitleImg: %w", err)
	}
	return oldValue.TitleImg, nil
}

// ResetTitleImg resets all changes to the "title_img" field.
func (m *ThemeMutation) ResetTitleImg() {
	m.title_img = nil
}

// SetOnline sets the "online" field.
func (m *ThemeMutation) SetOnline(i int) {
	m.online = &i
	m.addonline = nil
}

// Online returns the value of the "online" field in the mutation.
func (m *ThemeMutation) Online() (r int, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldOnline(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// AddOnline adds i to the "online" field.
func (m *ThemeMutation) AddOnline(i int) {
	if m.addonline != nil {
		*m.addonline += i
	} else {
		m.addonline = &i
	}
}

// AddedOnline returns the value that was added to the "online" field in this mutation.
func (m *ThemeMutation) AddedOnline() (r int, exists bool) {
	v := m.addonline
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnline resets all changes to the "online" field.
func (m *ThemeMutation) ResetOnline() {
	m.online = nil
	m.addonline = nil
}

// AddSpuIDs adds the "spu" edge to the Spu entity by ids.
func (m *ThemeMutation) AddSpuIDs(ids ...int64) {
	if m.spu == nil {
		m.spu = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu[ids[i]] = struct{}{}
	}
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *ThemeMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *ThemeMutation) SpuCleared() bool {
	return m.clearedspu
}

// RemoveSpuIDs removes the "spu" edge to the Spu entity by IDs.
func (m *ThemeMutation) RemoveSpuIDs(ids ...int64) {
	if m.removedspu == nil {
		m.removedspu = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu, ids[i])
		m.removedspu[ids[i]] = struct{}{}
	}
}

// RemovedSpu returns the removed IDs of the "spu" edge to the Spu entity.
func (m *ThemeMutation) RemovedSpuIDs() (ids []int64) {
	for id := range m.removedspu {
		ids = append(ids, id)
	}
	return
}

// SpuIDs returns the "spu" edge IDs in the mutation.
func (m *ThemeMutation) SpuIDs() (ids []int64) {
	for id := range m.spu {
		ids = append(ids, id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *ThemeMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
	m.removedspu = nil
}

// Where appends a list predicates to the ThemeMutation builder.
func (m *ThemeMutation) Where(ps ...predicate.Theme) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ThemeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Theme).
func (m *ThemeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThemeMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, theme.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, theme.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, theme.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, theme.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, theme.FieldDescription)
	}
	if m.name != nil {
		fields = append(fields, theme.FieldName)
	}
	if m.tpl_name != nil {
		fields = append(fields, theme.FieldTplName)
	}
	if m.entrance_img != nil {
		fields = append(fields, theme.FieldEntranceImg)
	}
	if m.extend != nil {
		fields = append(fields, theme.FieldExtend)
	}
	if m.internal_top_img != nil {
		fields = append(fields, theme.FieldInternalTopImg)
	}
	if m.title_img != nil {
		fields = append(fields, theme.FieldTitleImg)
	}
	if m.online != nil {
		fields = append(fields, theme.FieldOnline)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThemeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case theme.FieldCreateTime:
		return m.CreateTime()
	case theme.FieldUpdateTime:
		return m.UpdateTime()
	case theme.FieldDeleteTime:
		return m.DeleteTime()
	case theme.FieldTitle:
		return m.Title()
	case theme.FieldDescription:
		return m.Description()
	case theme.FieldName:
		return m.Name()
	case theme.FieldTplName:
		return m.TplName()
	case theme.FieldEntranceImg:
		return m.EntranceImg()
	case theme.FieldExtend:
		return m.Extend()
	case theme.FieldInternalTopImg:
		return m.InternalTopImg()
	case theme.FieldTitleImg:
		return m.TitleImg()
	case theme.FieldOnline:
		return m.Online()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThemeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case theme.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case theme.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case theme.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case theme.FieldTitle:
		return m.OldTitle(ctx)
	case theme.FieldDescription:
		return m.OldDescription(ctx)
	case theme.FieldName:
		return m.OldName(ctx)
	case theme.FieldTplName:
		return m.OldTplName(ctx)
	case theme.FieldEntranceImg:
		return m.OldEntranceImg(ctx)
	case theme.FieldExtend:
		return m.OldExtend(ctx)
	case theme.FieldInternalTopImg:
		return m.OldInternalTopImg(ctx)
	case theme.FieldTitleImg:
		return m.OldTitleImg(ctx)
	case theme.FieldOnline:
		return m.OldOnline(ctx)
	}
	return nil, fmt.Errorf("unknown Theme field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThemeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case theme.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case theme.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case theme.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case theme.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case theme.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case theme.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case theme.FieldTplName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTplName(v)
		return nil
	case theme.FieldEntranceImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntranceImg(v)
		return nil
	case theme.FieldExtend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtend(v)
		return nil
	case theme.FieldInternalTopImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalTopImg(v)
		return nil
	case theme.FieldTitleImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitleImg(v)
		return nil
	case theme.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	}
	return fmt.Errorf("unknown Theme field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThemeMutation) AddedFields() []string {
	var fields []string
	if m.addonline != nil {
		fields = append(fields, theme.FieldOnline)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThemeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case theme.FieldOnline:
		return m.AddedOnline()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThemeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case theme.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnline(v)
		return nil
	}
	return fmt.Errorf("unknown Theme numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThemeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(theme.FieldDeleteTime) {
		fields = append(fields, theme.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThemeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThemeMutation) ClearField(name string) error {
	switch name {
	case theme.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Theme nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThemeMutation) ResetField(name string) error {
	switch name {
	case theme.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case theme.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case theme.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case theme.FieldTitle:
		m.ResetTitle()
		return nil
	case theme.FieldDescription:
		m.ResetDescription()
		return nil
	case theme.FieldName:
		m.ResetName()
		return nil
	case theme.FieldTplName:
		m.ResetTplName()
		return nil
	case theme.FieldEntranceImg:
		m.ResetEntranceImg()
		return nil
	case theme.FieldExtend:
		m.ResetExtend()
		return nil
	case theme.FieldInternalTopImg:
		m.ResetInternalTopImg()
		return nil
	case theme.FieldTitleImg:
		m.ResetTitleImg()
		return nil
	case theme.FieldOnline:
		m.ResetOnline()
		return nil
	}
	return fmt.Errorf("unknown Theme field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThemeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, theme.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThemeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case theme.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.spu))
		for id := range m.spu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThemeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedspu != nil {
		edges = append(edges, theme.EdgeSpu)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThemeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case theme.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.removedspu))
		for id := range m.removedspu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThemeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, theme.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThemeMutation) EdgeCleared(name string) bool {
	switch name {
	case theme.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThemeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Theme unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThemeMutation) ResetEdge(name string) error {
	switch name {
	case theme.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown Theme edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	openid        *string
	email         *string
	password      *string
	mobile        *string
	status        *int
	addstatus     *int
	clearedFields map[string]struct{}
	_order        map[int64]struct{}
	removed_order map[int64]struct{}
	cleared_order bool
	refund        map[int64]struct{}
	removedrefund map[int64]struct{}
	clearedrefund bool
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *UserMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *UserMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *UserMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[user.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *UserMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[user.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *UserMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, user.FieldDeleteTime)
}

// SetOpenid sets the "openid" field.
func (m *UserMutation) SetOpenid(s string) {
	m.openid = &s
}

// Openid returns the value of the "openid" field in the mutation.
func (m *UserMutation) Openid() (r string, exists bool) {
	v := m.openid
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenid returns the old "openid" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldOpenid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOpenid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOpenid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenid: %w", err)
	}
	return oldValue.Openid, nil
}

// ResetOpenid resets all changes to the "openid" field.
func (m *UserMutation) ResetOpenid() {
	m.openid = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// AddOrderIDs adds the "order" edge to the Order entity by ids.
func (m *UserMutation) AddOrderIDs(ids ...int64) {
	if m._order == nil {
		m._order = make(map[int64]struct{})
	}
	for i := range ids {
		m._order[ids[i]] = struct{}{}
	}
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *UserMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *UserMutation) OrderCleared() bool {
	return m.cleared_order
}

// RemoveOrderIDs removes the "order" edge to the Order entity by IDs.
func (m *UserMutation) RemoveOrderIDs(ids ...int64) {
	if m.removed_order == nil {
		m.removed_order = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m._order, ids[i])
		m.removed_order[ids[i]] = struct{}{}
	}
}

// RemovedOrder returns the removed IDs of the "order" edge to the Order entity.
func (m *UserMutation) RemovedOrderIDs() (ids []int64) {
	for id := range m.removed_order {
		ids = append(ids, id)
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
func (m *UserMutation) OrderIDs() (ids []int64) {
	for id := range m._order {
		ids = append(ids, id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *UserMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
	m.removed_order = nil
}

// AddRefundIDs adds the "refund" edge to the Refund entity by ids.
func (m *UserMutation) AddRefundIDs(ids ...int64) {
	if m.refund == nil {
		m.refund = make(map[int64]struct{})
	}
	for i := range ids {
		m.refund[ids[i]] = struct{}{}
	}
}

// ClearRefund clears the "refund" edge to the Refund entity.
func (m *UserMutation) ClearRefund() {
	m.clearedrefund = true
}

// RefundCleared reports if the "refund" edge to the Refund entity was cleared.
func (m *UserMutation) RefundCleared() bool {
	return m.clearedrefund
}

// RemoveRefundIDs removes the "refund" edge to the Refund entity by IDs.
func (m *UserMutation) RemoveRefundIDs(ids ...int64) {
	if m.removedrefund == nil {
		m.removedrefund = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.refund, ids[i])
		m.removedrefund[ids[i]] = struct{}{}
	}
}

// RemovedRefund returns the removed IDs of the "refund" edge to the Refund entity.
func (m *UserMutation) RemovedRefundIDs() (ids []int64) {
	for id := range m.removedrefund {
		ids = append(ids, id)
	}
	return
}

// RefundIDs returns the "refund" edge IDs in the mutation.
func (m *UserMutation) RefundIDs() (ids []int64) {
	for id := range m.refund {
		ids = append(ids, id)
	}
	return
}

// ResetRefund resets all changes to the "refund" edge.
func (m *UserMutation) ResetRefund() {
	m.refund = nil
	m.clearedrefund = false
	m.removedrefund = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, user.FieldDeleteTime)
	}
	if m.openid != nil {
		fields = append(fields, user.FieldOpenid)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldDeleteTime:
		return m.DeleteTime()
	case user.FieldOpenid:
		return m.Openid()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case user.FieldOpenid:
		return m.OldOpenid(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case user.FieldOpenid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenid(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, user.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeleteTime) {
		fields = append(fields, user.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case user.FieldOpenid:
		m.ResetOpenid()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._order != nil {
		edges = append(edges, user.EdgeOrder)
	}
	if m.refund != nil {
		edges = append(edges, user.EdgeRefund)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOrder:
		ids := make([]ent.Value, 0, len(m._order))
		for id := range m._order {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRefund:
		ids := make([]ent.Value, 0, len(m.refund))
		for id := range m.refund {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_order != nil {
		edges = append(edges, user.EdgeOrder)
	}
	if m.removedrefund != nil {
		edges = append(edges, user.EdgeRefund)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.removed_order))
		for id := range m.removed_order {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRefund:
		ids := make([]ent.Value, 0, len(m.removedrefund))
		for id := range m.removedrefund {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_order {
		edges = append(edges, user.EdgeOrder)
	}
	if m.clearedrefund {
		edges = append(edges, user.EdgeRefund)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeOrder:
		return m.cleared_order
	case user.EdgeRefund:
		return m.clearedrefund
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeOrder:
		m.ResetOrder()
		return nil
	case user.EdgeRefund:
		m.ResetRefund()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserCouponMutation represents an operation that mutates the UserCoupon nodes in the graph.
type UserCouponMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	user_id       *int64
	adduser_id    *int64
	coupon_id     *int64
	addcoupon_id  *int64
	status        *int
	addstatus     *int
	order_id      *int
	addorder_id   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserCoupon, error)
	predicates    []predicate.UserCoupon
}

var _ ent.Mutation = (*UserCouponMutation)(nil)

// usercouponOption allows management of the mutation configuration using functional options.
type usercouponOption func(*UserCouponMutation)

// newUserCouponMutation creates new mutation for the UserCoupon entity.
func newUserCouponMutation(c config, op Op, opts ...usercouponOption) *UserCouponMutation {
	m := &UserCouponMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCouponID sets the ID field of the mutation.
func withUserCouponID(id int64) usercouponOption {
	return func(m *UserCouponMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCoupon
		)
		m.oldValue = func(ctx context.Context) (*UserCoupon, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCoupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCoupon sets the old UserCoupon of the mutation.
func withUserCoupon(node *UserCoupon) usercouponOption {
	return func(m *UserCouponMutation) {
		m.oldValue = func(context.Context) (*UserCoupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCouponMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *UserCouponMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserCouponMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserCoupon entity.
// If the UserCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCouponMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserCouponMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserCouponMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserCouponMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserCoupon entity.
// If the UserCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCouponMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserCouponMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *UserCouponMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *UserCouponMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the UserCoupon entity.
// If the UserCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCouponMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *UserCouponMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[usercoupon.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *UserCouponMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[usercoupon.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *UserCouponMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, usercoupon.FieldDeleteTime)
}

// SetUserID sets the "user_id" field.
func (m *UserCouponMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserCouponMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserCoupon entity.
// If the UserCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCouponMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserCouponMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserCouponMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserCouponMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetCouponID sets the "coupon_id" field.
func (m *UserCouponMutation) SetCouponID(i int64) {
	m.coupon_id = &i
	m.addcoupon_id = nil
}

// CouponID returns the value of the "coupon_id" field in the mutation.
func (m *UserCouponMutation) CouponID() (r int64, exists bool) {
	v := m.coupon_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponID returns the old "coupon_id" field's value of the UserCoupon entity.
// If the UserCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCouponMutation) OldCouponID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCouponID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCouponID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponID: %w", err)
	}
	return oldValue.CouponID, nil
}

// AddCouponID adds i to the "coupon_id" field.
func (m *UserCouponMutation) AddCouponID(i int64) {
	if m.addcoupon_id != nil {
		*m.addcoupon_id += i
	} else {
		m.addcoupon_id = &i
	}
}

// AddedCouponID returns the value that was added to the "coupon_id" field in this mutation.
func (m *UserCouponMutation) AddedCouponID() (r int64, exists bool) {
	v := m.addcoupon_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCouponID resets all changes to the "coupon_id" field.
func (m *UserCouponMutation) ResetCouponID() {
	m.coupon_id = nil
	m.addcoupon_id = nil
}

// SetStatus sets the "status" field.
func (m *UserCouponMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserCouponMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserCoupon entity.
// If the UserCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCouponMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserCouponMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserCouponMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserCouponMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetOrderID sets the "order_id" field.
func (m *UserCouponMutation) SetOrderID(i int) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *UserCouponMutation) OrderID() (r int, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the UserCoupon entity.
// If the UserCoupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCouponMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *UserCouponMutation) AddOrderID(i int) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *UserCouponMutation) AddedOrderID() (r int, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *UserCouponMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// Where appends a list predicates to the UserCouponMutation builder.
func (m *UserCouponMutation) Where(ps ...predicate.UserCoupon) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserCouponMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserCoupon).
func (m *UserCouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCouponMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, usercoupon.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, usercoupon.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, usercoupon.FieldDeleteTime)
	}
	if m.user_id != nil {
		fields = append(fields, usercoupon.FieldUserID)
	}
	if m.coupon_id != nil {
		fields = append(fields, usercoupon.FieldCouponID)
	}
	if m.status != nil {
		fields = append(fields, usercoupon.FieldStatus)
	}
	if m.order_id != nil {
		fields = append(fields, usercoupon.FieldOrderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercoupon.FieldCreateTime:
		return m.CreateTime()
	case usercoupon.FieldUpdateTime:
		return m.UpdateTime()
	case usercoupon.FieldDeleteTime:
		return m.DeleteTime()
	case usercoupon.FieldUserID:
		return m.UserID()
	case usercoupon.FieldCouponID:
		return m.CouponID()
	case usercoupon.FieldStatus:
		return m.Status()
	case usercoupon.FieldOrderID:
		return m.OrderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercoupon.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case usercoupon.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case usercoupon.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case usercoupon.FieldUserID:
		return m.OldUserID(ctx)
	case usercoupon.FieldCouponID:
		return m.OldCouponID(ctx)
	case usercoupon.FieldStatus:
		return m.OldStatus(ctx)
	case usercoupon.FieldOrderID:
		return m.OldOrderID(ctx)
	}
	return nil, fmt.Errorf("unknown UserCoupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercoupon.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case usercoupon.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case usercoupon.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case usercoupon.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usercoupon.FieldCouponID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponID(v)
		return nil
	case usercoupon.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usercoupon.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown UserCoupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCouponMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, usercoupon.FieldUserID)
	}
	if m.addcoupon_id != nil {
		fields = append(fields, usercoupon.FieldCouponID)
	}
	if m.addstatus != nil {
		fields = append(fields, usercoupon.FieldStatus)
	}
	if m.addorder_id != nil {
		fields = append(fields, usercoupon.FieldOrderID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCouponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usercoupon.FieldUserID:
		return m.AddedUserID()
	case usercoupon.FieldCouponID:
		return m.AddedCouponID()
	case usercoupon.FieldStatus:
		return m.AddedStatus()
	case usercoupon.FieldOrderID:
		return m.AddedOrderID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usercoupon.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case usercoupon.FieldCouponID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponID(v)
		return nil
	case usercoupon.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case usercoupon.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	}
	return fmt.Errorf("unknown UserCoupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usercoupon.FieldDeleteTime) {
		fields = append(fields, usercoupon.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCouponMutation) ClearField(name string) error {
	switch name {
	case usercoupon.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown UserCoupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCouponMutation) ResetField(name string) error {
	switch name {
	case usercoupon.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case usercoupon.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case usercoupon.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case usercoupon.FieldUserID:
		m.ResetUserID()
		return nil
	case usercoupon.FieldCouponID:
		m.ResetCouponID()
		return nil
	case usercoupon.FieldStatus:
		m.ResetStatus()
		return nil
	case usercoupon.FieldOrderID:
		m.ResetOrderID()
		return nil
	}
	return fmt.Errorf("unknown UserCoupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCouponMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCouponMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCouponMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCouponMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserCoupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCouponMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserCoupon edge %s", name)
}

// UserFavorMutation represents an operation that mutates the UserFavor nodes in the graph.
type UserFavorMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	user_id       *int64
	adduser_id    *int64
	spu_id        *int64
	addspu_id     *int64
	status        *int
	addstatus     *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserFavor, error)
	predicates    []predicate.UserFavor
}

var _ ent.Mutation = (*UserFavorMutation)(nil)

// userfavorOption allows management of the mutation configuration using functional options.
type userfavorOption func(*UserFavorMutation)

// newUserFavorMutation creates new mutation for the UserFavor entity.
func newUserFavorMutation(c config, op Op, opts ...userfavorOption) *UserFavorMutation {
	m := &UserFavorMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFavor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFavorID sets the ID field of the mutation.
func withUserFavorID(id int64) userfavorOption {
	return func(m *UserFavorMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFavor
		)
		m.oldValue = func(ctx context.Context) (*UserFavor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFavor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFavor sets the old UserFavor of the mutation.
func withUserFavor(node *UserFavor) userfavorOption {
	return func(m *UserFavorMutation) {
		m.oldValue = func(context.Context) (*UserFavor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFavorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFavorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFavorMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *UserFavorMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserFavorMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserFavorMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserFavorMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserFavorMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserFavorMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *UserFavorMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *UserFavorMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *UserFavorMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[userfavor.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *UserFavorMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[userfavor.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *UserFavorMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, userfavor.FieldDeleteTime)
}

// SetUserID sets the "user_id" field.
func (m *UserFavorMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserFavorMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserFavorMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserFavorMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserFavorMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetSpuID sets the "spu_id" field.
func (m *UserFavorMutation) SetSpuID(i int64) {
	m.spu_id = &i
	m.addspu_id = nil
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *UserFavorMutation) SpuID() (r int64, exists bool) {
	v := m.spu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// AddSpuID adds i to the "spu_id" field.
func (m *UserFavorMutation) AddSpuID(i int64) {
	if m.addspu_id != nil {
		*m.addspu_id += i
	} else {
		m.addspu_id = &i
	}
}

// AddedSpuID returns the value that was added to the "spu_id" field in this mutation.
func (m *UserFavorMutation) AddedSpuID() (r int64, exists bool) {
	v := m.addspu_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *UserFavorMutation) ResetSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
}

// SetStatus sets the "status" field.
func (m *UserFavorMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserFavorMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserFavorMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserFavorMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserFavorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the UserFavorMutation builder.
func (m *UserFavorMutation) Where(ps ...predicate.UserFavor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserFavorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserFavor).
func (m *UserFavorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFavorMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, userfavor.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userfavor.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, userfavor.FieldDeleteTime)
	}
	if m.user_id != nil {
		fields = append(fields, userfavor.FieldUserID)
	}
	if m.spu_id != nil {
		fields = append(fields, userfavor.FieldSpuID)
	}
	if m.status != nil {
		fields = append(fields, userfavor.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFavorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfavor.FieldCreateTime:
		return m.CreateTime()
	case userfavor.FieldUpdateTime:
		return m.UpdateTime()
	case userfavor.FieldDeleteTime:
		return m.DeleteTime()
	case userfavor.FieldUserID:
		return m.UserID()
	case userfavor.FieldSpuID:
		return m.SpuID()
	case userfavor.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFavorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfavor.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userfavor.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userfavor.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case userfavor.FieldUserID:
		return m.OldUserID(ctx)
	case userfavor.FieldSpuID:
		return m.OldSpuID(ctx)
	case userfavor.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserFavor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfavor.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userfavor.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userfavor.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case userfavor.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userfavor.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case userfavor.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserFavor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFavorMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userfavor.FieldUserID)
	}
	if m.addspu_id != nil {
		fields = append(fields, userfavor.FieldSpuID)
	}
	if m.addstatus != nil {
		fields = append(fields, userfavor.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFavorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userfavor.FieldUserID:
		return m.AddedUserID()
	case userfavor.FieldSpuID:
		return m.AddedSpuID()
	case userfavor.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userfavor.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userfavor.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpuID(v)
		return nil
	case userfavor.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserFavor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFavorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userfavor.FieldDeleteTime) {
		fields = append(fields, userfavor.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFavorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFavorMutation) ClearField(name string) error {
	switch name {
	case userfavor.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown UserFavor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFavorMutation) ResetField(name string) error {
	switch name {
	case userfavor.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userfavor.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userfavor.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case userfavor.FieldUserID:
		m.ResetUserID()
		return nil
	case userfavor.FieldSpuID:
		m.ResetSpuID()
		return nil
	case userfavor.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserFavor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFavorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFavorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFavorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFavorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFavorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFavorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFavorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserFavor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFavorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserFavor edge %s", name)
}

// UserInfoMutation represents an operation that mutates the UserInfo nodes in the graph.
type UserInfoMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	nickname      *string
	unify_uid     *int
	addunify_uid  *int
	email         *string
	avatar        *string
	wx_profile    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserInfo, error)
	predicates    []predicate.UserInfo
}

var _ ent.Mutation = (*UserInfoMutation)(nil)

// userinfoOption allows management of the mutation configuration using functional options.
type userinfoOption func(*UserInfoMutation)

// newUserInfoMutation creates new mutation for the UserInfo entity.
func newUserInfoMutation(c config, op Op, opts ...userinfoOption) *UserInfoMutation {
	m := &UserInfoMutation{
		config:        c,
		op:            op,
		typ:           TypeUserInfo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserInfoID sets the ID field of the mutation.
func withUserInfoID(id int64) userinfoOption {
	return func(m *UserInfoMutation) {
		var (
			err   error
			once  sync.Once
			value *UserInfo
		)
		m.oldValue = func(ctx context.Context) (*UserInfo, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserInfo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserInfo sets the old UserInfo of the mutation.
func withUserInfo(node *UserInfo) userinfoOption {
	return func(m *UserInfoMutation) {
		m.oldValue = func(context.Context) (*UserInfo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserInfoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserInfoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserInfo entities.
func (m *UserInfoMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserInfoMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *UserInfoMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserInfoMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserInfo entity.
// If the UserInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInfoMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserInfoMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserInfoMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserInfoMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserInfo entity.
// If the UserInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInfoMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserInfoMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *UserInfoMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *UserInfoMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the UserInfo entity.
// If the UserInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInfoMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *UserInfoMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[userinfo.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *UserInfoMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[userinfo.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *UserInfoMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, userinfo.FieldDeleteTime)
}

// SetNickname sets the "nickname" field.
func (m *UserInfoMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *UserInfoMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the UserInfo entity.
// If the UserInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInfoMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *UserInfoMutation) ResetNickname() {
	m.nickname = nil
}

// SetUnifyUID sets the "unify_uid" field.
func (m *UserInfoMutation) SetUnifyUID(i int) {
	m.unify_uid = &i
	m.addunify_uid = nil
}

// UnifyUID returns the value of the "unify_uid" field in the mutation.
func (m *UserInfoMutation) UnifyUID() (r int, exists bool) {
	v := m.unify_uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUnifyUID returns the old "unify_uid" field's value of the UserInfo entity.
// If the UserInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInfoMutation) OldUnifyUID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnifyUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnifyUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnifyUID: %w", err)
	}
	return oldValue.UnifyUID, nil
}

// AddUnifyUID adds i to the "unify_uid" field.
func (m *UserInfoMutation) AddUnifyUID(i int) {
	if m.addunify_uid != nil {
		*m.addunify_uid += i
	} else {
		m.addunify_uid = &i
	}
}

// AddedUnifyUID returns the value that was added to the "unify_uid" field in this mutation.
func (m *UserInfoMutation) AddedUnifyUID() (r int, exists bool) {
	v := m.addunify_uid
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnifyUID resets all changes to the "unify_uid" field.
func (m *UserInfoMutation) ResetUnifyUID() {
	m.unify_uid = nil
	m.addunify_uid = nil
}

// SetEmail sets the "email" field.
func (m *UserInfoMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserInfoMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the UserInfo entity.
// If the UserInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInfoMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserInfoMutation) ResetEmail() {
	m.email = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserInfoMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserInfoMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the UserInfo entity.
// If the UserInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInfoMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserInfoMutation) ResetAvatar() {
	m.avatar = nil
}

// SetWxProfile sets the "wx_profile" field.
func (m *UserInfoMutation) SetWxProfile(s string) {
	m.wx_profile = &s
}

// WxProfile returns the value of the "wx_profile" field in the mutation.
func (m *UserInfoMutation) WxProfile() (r string, exists bool) {
	v := m.wx_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldWxProfile returns the old "wx_profile" field's value of the UserInfo entity.
// If the UserInfo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserInfoMutation) OldWxProfile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWxProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWxProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWxProfile: %w", err)
	}
	return oldValue.WxProfile, nil
}

// ResetWxProfile resets all changes to the "wx_profile" field.
func (m *UserInfoMutation) ResetWxProfile() {
	m.wx_profile = nil
}

// Where appends a list predicates to the UserInfoMutation builder.
func (m *UserInfoMutation) Where(ps ...predicate.UserInfo) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserInfoMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserInfo).
func (m *UserInfoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserInfoMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, userinfo.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userinfo.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, userinfo.FieldDeleteTime)
	}
	if m.nickname != nil {
		fields = append(fields, userinfo.FieldNickname)
	}
	if m.unify_uid != nil {
		fields = append(fields, userinfo.FieldUnifyUID)
	}
	if m.email != nil {
		fields = append(fields, userinfo.FieldEmail)
	}
	if m.avatar != nil {
		fields = append(fields, userinfo.FieldAvatar)
	}
	if m.wx_profile != nil {
		fields = append(fields, userinfo.FieldWxProfile)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserInfoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userinfo.FieldCreateTime:
		return m.CreateTime()
	case userinfo.FieldUpdateTime:
		return m.UpdateTime()
	case userinfo.FieldDeleteTime:
		return m.DeleteTime()
	case userinfo.FieldNickname:
		return m.Nickname()
	case userinfo.FieldUnifyUID:
		return m.UnifyUID()
	case userinfo.FieldEmail:
		return m.Email()
	case userinfo.FieldAvatar:
		return m.Avatar()
	case userinfo.FieldWxProfile:
		return m.WxProfile()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserInfoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userinfo.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userinfo.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userinfo.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case userinfo.FieldNickname:
		return m.OldNickname(ctx)
	case userinfo.FieldUnifyUID:
		return m.OldUnifyUID(ctx)
	case userinfo.FieldEmail:
		return m.OldEmail(ctx)
	case userinfo.FieldAvatar:
		return m.OldAvatar(ctx)
	case userinfo.FieldWxProfile:
		return m.OldWxProfile(ctx)
	}
	return nil, fmt.Errorf("unknown UserInfo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserInfoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userinfo.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userinfo.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userinfo.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case userinfo.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case userinfo.FieldUnifyUID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnifyUID(v)
		return nil
	case userinfo.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case userinfo.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case userinfo.FieldWxProfile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWxProfile(v)
		return nil
	}
	return fmt.Errorf("unknown UserInfo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserInfoMutation) AddedFields() []string {
	var fields []string
	if m.addunify_uid != nil {
		fields = append(fields, userinfo.FieldUnifyUID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserInfoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userinfo.FieldUnifyUID:
		return m.AddedUnifyUID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserInfoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userinfo.FieldUnifyUID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnifyUID(v)
		return nil
	}
	return fmt.Errorf("unknown UserInfo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserInfoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userinfo.FieldDeleteTime) {
		fields = append(fields, userinfo.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserInfoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserInfoMutation) ClearField(name string) error {
	switch name {
	case userinfo.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown UserInfo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserInfoMutation) ResetField(name string) error {
	switch name {
	case userinfo.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userinfo.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userinfo.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case userinfo.FieldNickname:
		m.ResetNickname()
		return nil
	case userinfo.FieldUnifyUID:
		m.ResetUnifyUID()
		return nil
	case userinfo.FieldEmail:
		m.ResetEmail()
		return nil
	case userinfo.FieldAvatar:
		m.ResetAvatar()
		return nil
	case userinfo.FieldWxProfile:
		m.ResetWxProfile()
		return nil
	}
	return fmt.Errorf("unknown UserInfo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserInfoMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserInfoMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserInfoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserInfoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserInfoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserInfoMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserInfoMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserInfo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserInfoMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserInfo edge %s", name)
}

// UserPointMutation represents an operation that mutates the UserPoint nodes in the graph.
type UserPointMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	value         *int
	addvalue      *int
	status        *int
	addstatus     *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserPoint, error)
	predicates    []predicate.UserPoint
}

var _ ent.Mutation = (*UserPointMutation)(nil)

// userpointOption allows management of the mutation configuration using functional options.
type userpointOption func(*UserPointMutation)

// newUserPointMutation creates new mutation for the UserPoint entity.
func newUserPointMutation(c config, op Op, opts ...userpointOption) *UserPointMutation {
	m := &UserPointMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPointID sets the ID field of the mutation.
func withUserPointID(id int64) userpointOption {
	return func(m *UserPointMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPoint
		)
		m.oldValue = func(ctx context.Context) (*UserPoint, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPoint sets the old UserPoint of the mutation.
func withUserPoint(node *UserPoint) userpointOption {
	return func(m *UserPointMutation) {
		m.oldValue = func(context.Context) (*UserPoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserPoint entities.
func (m *UserPointMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPointMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *UserPointMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserPointMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserPoint entity.
// If the UserPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPointMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserPointMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserPointMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserPointMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserPoint entity.
// If the UserPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPointMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserPointMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *UserPointMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *UserPointMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the UserPoint entity.
// If the UserPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPointMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *UserPointMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[userpoint.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *UserPointMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[userpoint.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *UserPointMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, userpoint.FieldDeleteTime)
}

// SetValue sets the "value" field.
func (m *UserPointMutation) SetValue(i int) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *UserPointMutation) Value() (r int, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the UserPoint entity.
// If the UserPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPointMutation) OldValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to the "value" field.
func (m *UserPointMutation) AddValue(i int) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *UserPointMutation) AddedValue() (r int, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *UserPointMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetStatus sets the "status" field.
func (m *UserPointMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserPointMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserPoint entity.
// If the UserPoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPointMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserPointMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserPointMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserPointMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the UserPointMutation builder.
func (m *UserPointMutation) Where(ps ...predicate.UserPoint) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserPointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserPoint).
func (m *UserPointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPointMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, userpoint.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userpoint.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, userpoint.FieldDeleteTime)
	}
	if m.value != nil {
		fields = append(fields, userpoint.FieldValue)
	}
	if m.status != nil {
		fields = append(fields, userpoint.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpoint.FieldCreateTime:
		return m.CreateTime()
	case userpoint.FieldUpdateTime:
		return m.UpdateTime()
	case userpoint.FieldDeleteTime:
		return m.DeleteTime()
	case userpoint.FieldValue:
		return m.Value()
	case userpoint.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpoint.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userpoint.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userpoint.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case userpoint.FieldValue:
		return m.OldValue(ctx)
	case userpoint.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserPoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpoint.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userpoint.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userpoint.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case userpoint.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case userpoint.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserPoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPointMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, userpoint.FieldValue)
	}
	if m.addstatus != nil {
		fields = append(fields, userpoint.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPointMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userpoint.FieldValue:
		return m.AddedValue()
	case userpoint.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPointMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userpoint.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case userpoint.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserPoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userpoint.FieldDeleteTime) {
		fields = append(fields, userpoint.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPointMutation) ClearField(name string) error {
	switch name {
	case userpoint.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown UserPoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPointMutation) ResetField(name string) error {
	switch name {
	case userpoint.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userpoint.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userpoint.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case userpoint.FieldValue:
		m.ResetValue()
		return nil
	case userpoint.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserPoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPointMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPointMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPointMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPointMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPointMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserPoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPointMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserPoint edge %s", name)
}

// UserPointDetailMutation represents an operation that mutates the UserPointDetail nodes in the graph.
type UserPointDetailMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	user_id       *int64
	adduser_id    *int64
	value         *int
	addvalue      *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserPointDetail, error)
	predicates    []predicate.UserPointDetail
}

var _ ent.Mutation = (*UserPointDetailMutation)(nil)

// userpointdetailOption allows management of the mutation configuration using functional options.
type userpointdetailOption func(*UserPointDetailMutation)

// newUserPointDetailMutation creates new mutation for the UserPointDetail entity.
func newUserPointDetailMutation(c config, op Op, opts ...userpointdetailOption) *UserPointDetailMutation {
	m := &UserPointDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeUserPointDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserPointDetailID sets the ID field of the mutation.
func withUserPointDetailID(id int64) userpointdetailOption {
	return func(m *UserPointDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *UserPointDetail
		)
		m.oldValue = func(ctx context.Context) (*UserPointDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserPointDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserPointDetail sets the old UserPointDetail of the mutation.
func withUserPointDetail(node *UserPointDetail) userpointdetailOption {
	return func(m *UserPointDetailMutation) {
		m.oldValue = func(context.Context) (*UserPointDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserPointDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserPointDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserPointDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *UserPointDetailMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserPointDetailMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserPointDetail entity.
// If the UserPointDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPointDetailMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserPointDetailMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserPointDetailMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserPointDetailMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserPointDetail entity.
// If the UserPointDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPointDetailMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserPointDetailMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *UserPointDetailMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *UserPointDetailMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the UserPointDetail entity.
// If the UserPointDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPointDetailMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *UserPointDetailMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[userpointdetail.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *UserPointDetailMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[userpointdetail.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *UserPointDetailMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, userpointdetail.FieldDeleteTime)
}

// SetUserID sets the "user_id" field.
func (m *UserPointDetailMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserPointDetailMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserPointDetail entity.
// If the UserPointDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPointDetailMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserPointDetailMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserPointDetailMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserPointDetailMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetValue sets the "value" field.
func (m *UserPointDetailMutation) SetValue(i int) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *UserPointDetailMutation) Value() (r int, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the UserPointDetail entity.
// If the UserPointDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserPointDetailMutation) OldValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to the "value" field.
func (m *UserPointDetailMutation) AddValue(i int) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *UserPointDetailMutation) AddedValue() (r int, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *UserPointDetailMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// Where appends a list predicates to the UserPointDetailMutation builder.
func (m *UserPointDetailMutation) Where(ps ...predicate.UserPointDetail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserPointDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserPointDetail).
func (m *UserPointDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserPointDetailMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, userpointdetail.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userpointdetail.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, userpointdetail.FieldDeleteTime)
	}
	if m.user_id != nil {
		fields = append(fields, userpointdetail.FieldUserID)
	}
	if m.value != nil {
		fields = append(fields, userpointdetail.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserPointDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userpointdetail.FieldCreateTime:
		return m.CreateTime()
	case userpointdetail.FieldUpdateTime:
		return m.UpdateTime()
	case userpointdetail.FieldDeleteTime:
		return m.DeleteTime()
	case userpointdetail.FieldUserID:
		return m.UserID()
	case userpointdetail.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserPointDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userpointdetail.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userpointdetail.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userpointdetail.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case userpointdetail.FieldUserID:
		return m.OldUserID(ctx)
	case userpointdetail.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown UserPointDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPointDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userpointdetail.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userpointdetail.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userpointdetail.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case userpointdetail.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userpointdetail.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown UserPointDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserPointDetailMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userpointdetail.FieldUserID)
	}
	if m.addvalue != nil {
		fields = append(fields, userpointdetail.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserPointDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userpointdetail.FieldUserID:
		return m.AddedUserID()
	case userpointdetail.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserPointDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userpointdetail.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userpointdetail.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown UserPointDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserPointDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userpointdetail.FieldDeleteTime) {
		fields = append(fields, userpointdetail.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserPointDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserPointDetailMutation) ClearField(name string) error {
	switch name {
	case userpointdetail.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown UserPointDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserPointDetailMutation) ResetField(name string) error {
	switch name {
	case userpointdetail.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userpointdetail.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userpointdetail.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case userpointdetail.FieldUserID:
		m.ResetUserID()
		return nil
	case userpointdetail.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown UserPointDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserPointDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserPointDetailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserPointDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserPointDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserPointDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserPointDetailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserPointDetailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserPointDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserPointDetailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserPointDetail edge %s", name)
}

// UserWalletMutation represents an operation that mutates the UserWallet nodes in the graph.
type UserWalletMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	value         *int
	addvalue      *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserWallet, error)
	predicates    []predicate.UserWallet
}

var _ ent.Mutation = (*UserWalletMutation)(nil)

// userwalletOption allows management of the mutation configuration using functional options.
type userwalletOption func(*UserWalletMutation)

// newUserWalletMutation creates new mutation for the UserWallet entity.
func newUserWalletMutation(c config, op Op, opts ...userwalletOption) *UserWalletMutation {
	m := &UserWalletMutation{
		config:        c,
		op:            op,
		typ:           TypeUserWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserWalletID sets the ID field of the mutation.
func withUserWalletID(id int64) userwalletOption {
	return func(m *UserWalletMutation) {
		var (
			err   error
			once  sync.Once
			value *UserWallet
		)
		m.oldValue = func(ctx context.Context) (*UserWallet, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserWallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserWallet sets the old UserWallet of the mutation.
func withUserWallet(node *UserWallet) userwalletOption {
	return func(m *UserWalletMutation) {
		m.oldValue = func(context.Context) (*UserWallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserWalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserWalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserWallet entities.
func (m *UserWalletMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserWalletMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *UserWalletMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserWalletMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserWallet entity.
// If the UserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserWalletMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserWalletMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserWalletMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserWallet entity.
// If the UserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserWalletMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *UserWalletMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *UserWalletMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the UserWallet entity.
// If the UserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *UserWalletMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[userwallet.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *UserWalletMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *UserWalletMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, userwallet.FieldDeleteTime)
}

// SetValue sets the "value" field.
func (m *UserWalletMutation) SetValue(i int) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *UserWalletMutation) Value() (r int, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the UserWallet entity.
// If the UserWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletMutation) OldValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to the "value" field.
func (m *UserWalletMutation) AddValue(i int) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *UserWalletMutation) AddedValue() (r int, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *UserWalletMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// Where appends a list predicates to the UserWalletMutation builder.
func (m *UserWalletMutation) Where(ps ...predicate.UserWallet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserWalletMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserWallet).
func (m *UserWalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserWalletMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, userwallet.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userwallet.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, userwallet.FieldDeleteTime)
	}
	if m.value != nil {
		fields = append(fields, userwallet.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserWalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userwallet.FieldCreateTime:
		return m.CreateTime()
	case userwallet.FieldUpdateTime:
		return m.UpdateTime()
	case userwallet.FieldDeleteTime:
		return m.DeleteTime()
	case userwallet.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserWalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userwallet.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userwallet.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userwallet.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case userwallet.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown UserWallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserWalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userwallet.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userwallet.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userwallet.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case userwallet.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown UserWallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserWalletMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, userwallet.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserWalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userwallet.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserWalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userwallet.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown UserWallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserWalletMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userwallet.FieldDeleteTime) {
		fields = append(fields, userwallet.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserWalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserWalletMutation) ClearField(name string) error {
	switch name {
	case userwallet.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown UserWallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserWalletMutation) ResetField(name string) error {
	switch name {
	case userwallet.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userwallet.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userwallet.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case userwallet.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown UserWallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserWalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserWalletMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserWalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserWalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserWalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserWalletMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserWalletMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserWallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserWalletMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserWallet edge %s", name)
}

// UserWalletDetailMutation represents an operation that mutates the UserWalletDetail nodes in the graph.
type UserWalletDetailMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	description   *string
	_op           *int
	add_op        *int
	current       *int
	addcurrent    *int
	value         *int
	addvalue      *int
	_type         *int
	add_type      *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserWalletDetail, error)
	predicates    []predicate.UserWalletDetail
}

var _ ent.Mutation = (*UserWalletDetailMutation)(nil)

// userwalletdetailOption allows management of the mutation configuration using functional options.
type userwalletdetailOption func(*UserWalletDetailMutation)

// newUserWalletDetailMutation creates new mutation for the UserWalletDetail entity.
func newUserWalletDetailMutation(c config, op Op, opts ...userwalletdetailOption) *UserWalletDetailMutation {
	m := &UserWalletDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeUserWalletDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserWalletDetailID sets the ID field of the mutation.
func withUserWalletDetailID(id int64) userwalletdetailOption {
	return func(m *UserWalletDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *UserWalletDetail
		)
		m.oldValue = func(ctx context.Context) (*UserWalletDetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserWalletDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserWalletDetail sets the old UserWalletDetail of the mutation.
func withUserWalletDetail(node *UserWalletDetail) userwalletdetailOption {
	return func(m *UserWalletDetailMutation) {
		m.oldValue = func(context.Context) (*UserWalletDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserWalletDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserWalletDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserWalletDetailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *UserWalletDetailMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserWalletDetailMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserWalletDetail entity.
// If the UserWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletDetailMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserWalletDetailMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserWalletDetailMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserWalletDetailMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserWalletDetail entity.
// If the UserWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletDetailMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserWalletDetailMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *UserWalletDetailMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *UserWalletDetailMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the UserWalletDetail entity.
// If the UserWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletDetailMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *UserWalletDetailMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[userwalletdetail.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *UserWalletDetailMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[userwalletdetail.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *UserWalletDetailMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, userwalletdetail.FieldDeleteTime)
}

// SetDescription sets the "description" field.
func (m *UserWalletDetailMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserWalletDetailMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserWalletDetail entity.
// If the UserWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletDetailMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserWalletDetailMutation) ResetDescription() {
	m.description = nil
}

// SetOp sets the "op" field.
func (m *UserWalletDetailMutation) SetOp(i int) {
	m._op = &i
	m.add_op = nil
}

// GetOp returns the value of the "op" field in the mutation.
func (m *UserWalletDetailMutation) GetOp() (r int, exists bool) {
	v := m._op
	if v == nil {
		return
	}
	return *v, true
}

// OldOp returns the old "op" field's value of the UserWalletDetail entity.
// If the UserWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletDetailMutation) OldOp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOp: %w", err)
	}
	return oldValue.Op, nil
}

// AddOp adds i to the "op" field.
func (m *UserWalletDetailMutation) AddOp(i int) {
	if m.add_op != nil {
		*m.add_op += i
	} else {
		m.add_op = &i
	}
}

// AddedOp returns the value that was added to the "op" field in this mutation.
func (m *UserWalletDetailMutation) AddedOp() (r int, exists bool) {
	v := m.add_op
	if v == nil {
		return
	}
	return *v, true
}

// ResetOp resets all changes to the "op" field.
func (m *UserWalletDetailMutation) ResetOp() {
	m._op = nil
	m.add_op = nil
}

// SetCurrent sets the "current" field.
func (m *UserWalletDetailMutation) SetCurrent(i int) {
	m.current = &i
	m.addcurrent = nil
}

// Current returns the value of the "current" field in the mutation.
func (m *UserWalletDetailMutation) Current() (r int, exists bool) {
	v := m.current
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrent returns the old "current" field's value of the UserWalletDetail entity.
// If the UserWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletDetailMutation) OldCurrent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCurrent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCurrent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrent: %w", err)
	}
	return oldValue.Current, nil
}

// AddCurrent adds i to the "current" field.
func (m *UserWalletDetailMutation) AddCurrent(i int) {
	if m.addcurrent != nil {
		*m.addcurrent += i
	} else {
		m.addcurrent = &i
	}
}

// AddedCurrent returns the value that was added to the "current" field in this mutation.
func (m *UserWalletDetailMutation) AddedCurrent() (r int, exists bool) {
	v := m.addcurrent
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrent resets all changes to the "current" field.
func (m *UserWalletDetailMutation) ResetCurrent() {
	m.current = nil
	m.addcurrent = nil
}

// SetValue sets the "value" field.
func (m *UserWalletDetailMutation) SetValue(i int) {
	m.value = &i
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *UserWalletDetailMutation) Value() (r int, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the UserWalletDetail entity.
// If the UserWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletDetailMutation) OldValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds i to the "value" field.
func (m *UserWalletDetailMutation) AddValue(i int) {
	if m.addvalue != nil {
		*m.addvalue += i
	} else {
		m.addvalue = &i
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *UserWalletDetailMutation) AddedValue() (r int, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *UserWalletDetailMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetType sets the "type" field.
func (m *UserWalletDetailMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserWalletDetailMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserWalletDetail entity.
// If the UserWalletDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWalletDetailMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *UserWalletDetailMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *UserWalletDetailMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *UserWalletDetailMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// Where appends a list predicates to the UserWalletDetailMutation builder.
func (m *UserWalletDetailMutation) Where(ps ...predicate.UserWalletDetail) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserWalletDetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserWalletDetail).
func (m *UserWalletDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserWalletDetailMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, userwalletdetail.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userwalletdetail.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, userwalletdetail.FieldDeleteTime)
	}
	if m.description != nil {
		fields = append(fields, userwalletdetail.FieldDescription)
	}
	if m._op != nil {
		fields = append(fields, userwalletdetail.FieldOp)
	}
	if m.current != nil {
		fields = append(fields, userwalletdetail.FieldCurrent)
	}
	if m.value != nil {
		fields = append(fields, userwalletdetail.FieldValue)
	}
	if m._type != nil {
		fields = append(fields, userwalletdetail.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserWalletDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userwalletdetail.FieldCreateTime:
		return m.CreateTime()
	case userwalletdetail.FieldUpdateTime:
		return m.UpdateTime()
	case userwalletdetail.FieldDeleteTime:
		return m.DeleteTime()
	case userwalletdetail.FieldDescription:
		return m.Description()
	case userwalletdetail.FieldOp:
		return m.GetOp()
	case userwalletdetail.FieldCurrent:
		return m.Current()
	case userwalletdetail.FieldValue:
		return m.Value()
	case userwalletdetail.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserWalletDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userwalletdetail.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userwalletdetail.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userwalletdetail.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case userwalletdetail.FieldDescription:
		return m.OldDescription(ctx)
	case userwalletdetail.FieldOp:
		return m.OldOp(ctx)
	case userwalletdetail.FieldCurrent:
		return m.OldCurrent(ctx)
	case userwalletdetail.FieldValue:
		return m.OldValue(ctx)
	case userwalletdetail.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown UserWalletDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserWalletDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userwalletdetail.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userwalletdetail.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userwalletdetail.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case userwalletdetail.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case userwalletdetail.FieldOp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOp(v)
		return nil
	case userwalletdetail.FieldCurrent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrent(v)
		return nil
	case userwalletdetail.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case userwalletdetail.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown UserWalletDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserWalletDetailMutation) AddedFields() []string {
	var fields []string
	if m.add_op != nil {
		fields = append(fields, userwalletdetail.FieldOp)
	}
	if m.addcurrent != nil {
		fields = append(fields, userwalletdetail.FieldCurrent)
	}
	if m.addvalue != nil {
		fields = append(fields, userwalletdetail.FieldValue)
	}
	if m.add_type != nil {
		fields = append(fields, userwalletdetail.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserWalletDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userwalletdetail.FieldOp:
		return m.AddedOp()
	case userwalletdetail.FieldCurrent:
		return m.AddedCurrent()
	case userwalletdetail.FieldValue:
		return m.AddedValue()
	case userwalletdetail.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserWalletDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userwalletdetail.FieldOp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOp(v)
		return nil
	case userwalletdetail.FieldCurrent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrent(v)
		return nil
	case userwalletdetail.FieldValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case userwalletdetail.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown UserWalletDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserWalletDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userwalletdetail.FieldDeleteTime) {
		fields = append(fields, userwalletdetail.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserWalletDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserWalletDetailMutation) ClearField(name string) error {
	switch name {
	case userwalletdetail.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown UserWalletDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserWalletDetailMutation) ResetField(name string) error {
	switch name {
	case userwalletdetail.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userwalletdetail.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userwalletdetail.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case userwalletdetail.FieldDescription:
		m.ResetDescription()
		return nil
	case userwalletdetail.FieldOp:
		m.ResetOp()
		return nil
	case userwalletdetail.FieldCurrent:
		m.ResetCurrent()
		return nil
	case userwalletdetail.FieldValue:
		m.ResetValue()
		return nil
	case userwalletdetail.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown UserWalletDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserWalletDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserWalletDetailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserWalletDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserWalletDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserWalletDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserWalletDetailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserWalletDetailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserWalletDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserWalletDetailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserWalletDetail edge %s", name)
}
