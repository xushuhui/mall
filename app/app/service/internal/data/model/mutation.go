// Code generated by entc, DO NOT EDIT.

package model

import (
	"context"
	"fmt"
	"mall-go/app/app/service/internal/data/model/activity"
	"mall-go/app/app/service/internal/data/model/banner"
	"mall-go/app/app/service/internal/data/model/banneritem"
	"mall-go/app/app/service/internal/data/model/category"
	"mall-go/app/app/service/internal/data/model/charge"
	"mall-go/app/app/service/internal/data/model/coupon"
	"mall-go/app/app/service/internal/data/model/coupontemplate"
	"mall-go/app/app/service/internal/data/model/coupontype"
	"mall-go/app/app/service/internal/data/model/gridcategory"
	"mall-go/app/app/service/internal/data/model/predicate"
	"mall-go/app/app/service/internal/data/model/refund"
	"mall-go/app/app/service/internal/data/model/theme"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity       = "Activity"
	TypeBanner         = "Banner"
	TypeBannerItem     = "BannerItem"
	TypeCategory       = "Category"
	TypeCharge         = "Charge"
	TypeCoupon         = "Coupon"
	TypeCouponTemplate = "CouponTemplate"
	TypeCouponType     = "CouponType"
	TypeGridCategory   = "GridCategory"
	TypeRefund         = "Refund"
	TypeTheme          = "Theme"
)

// ActivityMutation represents an operation that mutates the Activity nodes in the graph.
type ActivityMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	create_time      *time.Time
	update_time      *time.Time
	delete_time      *time.Time
	title            *string
	description      *string
	start_time       *time.Time
	end_time         *time.Time
	remark           *string
	online           *int
	addonline        *int
	entrance_img     *string
	internal_top_img *string
	name             *string
	clearedFields    map[string]struct{}
	coupon           map[int64]struct{}
	removedcoupon    map[int64]struct{}
	clearedcoupon    bool
	done             bool
	oldValue         func(context.Context) (*Activity, error)
	predicates       []predicate.Activity
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows management of the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for the Activity entity.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the ID field of the mutation.
func withActivityID(id int64) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ActivityMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ActivityMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ActivityMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ActivityMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ActivityMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ActivityMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *ActivityMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *ActivityMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *ActivityMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[activity.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *ActivityMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[activity.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *ActivityMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, activity.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *ActivityMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ActivityMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ActivityMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ActivityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ActivityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ActivityMutation) ResetDescription() {
	m.description = nil
}

// SetStartTime sets the "start_time" field.
func (m *ActivityMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *ActivityMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *ActivityMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *ActivityMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *ActivityMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *ActivityMutation) ResetEndTime() {
	m.end_time = nil
}

// SetRemark sets the "remark" field.
func (m *ActivityMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ActivityMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *ActivityMutation) ResetRemark() {
	m.remark = nil
}

// SetOnline sets the "online" field.
func (m *ActivityMutation) SetOnline(i int) {
	m.online = &i
	m.addonline = nil
}

// Online returns the value of the "online" field in the mutation.
func (m *ActivityMutation) Online() (r int, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldOnline(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// AddOnline adds i to the "online" field.
func (m *ActivityMutation) AddOnline(i int) {
	if m.addonline != nil {
		*m.addonline += i
	} else {
		m.addonline = &i
	}
}

// AddedOnline returns the value that was added to the "online" field in this mutation.
func (m *ActivityMutation) AddedOnline() (r int, exists bool) {
	v := m.addonline
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnline resets all changes to the "online" field.
func (m *ActivityMutation) ResetOnline() {
	m.online = nil
	m.addonline = nil
}

// SetEntranceImg sets the "entrance_img" field.
func (m *ActivityMutation) SetEntranceImg(s string) {
	m.entrance_img = &s
}

// EntranceImg returns the value of the "entrance_img" field in the mutation.
func (m *ActivityMutation) EntranceImg() (r string, exists bool) {
	v := m.entrance_img
	if v == nil {
		return
	}
	return *v, true
}

// OldEntranceImg returns the old "entrance_img" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldEntranceImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEntranceImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEntranceImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntranceImg: %w", err)
	}
	return oldValue.EntranceImg, nil
}

// ResetEntranceImg resets all changes to the "entrance_img" field.
func (m *ActivityMutation) ResetEntranceImg() {
	m.entrance_img = nil
}

// SetInternalTopImg sets the "internal_top_img" field.
func (m *ActivityMutation) SetInternalTopImg(s string) {
	m.internal_top_img = &s
}

// InternalTopImg returns the value of the "internal_top_img" field in the mutation.
func (m *ActivityMutation) InternalTopImg() (r string, exists bool) {
	v := m.internal_top_img
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalTopImg returns the old "internal_top_img" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldInternalTopImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInternalTopImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInternalTopImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalTopImg: %w", err)
	}
	return oldValue.InternalTopImg, nil
}

// ResetInternalTopImg resets all changes to the "internal_top_img" field.
func (m *ActivityMutation) ResetInternalTopImg() {
	m.internal_top_img = nil
}

// SetName sets the "name" field.
func (m *ActivityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActivityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActivityMutation) ResetName() {
	m.name = nil
}

// AddCouponIDs adds the "coupon" edge to the Coupon entity by ids.
func (m *ActivityMutation) AddCouponIDs(ids ...int64) {
	if m.coupon == nil {
		m.coupon = make(map[int64]struct{})
	}
	for i := range ids {
		m.coupon[ids[i]] = struct{}{}
	}
}

// ClearCoupon clears the "coupon" edge to the Coupon entity.
func (m *ActivityMutation) ClearCoupon() {
	m.clearedcoupon = true
}

// CouponCleared reports if the "coupon" edge to the Coupon entity was cleared.
func (m *ActivityMutation) CouponCleared() bool {
	return m.clearedcoupon
}

// RemoveCouponIDs removes the "coupon" edge to the Coupon entity by IDs.
func (m *ActivityMutation) RemoveCouponIDs(ids ...int64) {
	if m.removedcoupon == nil {
		m.removedcoupon = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.coupon, ids[i])
		m.removedcoupon[ids[i]] = struct{}{}
	}
}

// RemovedCoupon returns the removed IDs of the "coupon" edge to the Coupon entity.
func (m *ActivityMutation) RemovedCouponIDs() (ids []int64) {
	for id := range m.removedcoupon {
		ids = append(ids, id)
	}
	return
}

// CouponIDs returns the "coupon" edge IDs in the mutation.
func (m *ActivityMutation) CouponIDs() (ids []int64) {
	for id := range m.coupon {
		ids = append(ids, id)
	}
	return
}

// ResetCoupon resets all changes to the "coupon" edge.
func (m *ActivityMutation) ResetCoupon() {
	m.coupon = nil
	m.clearedcoupon = false
	m.removedcoupon = nil
}

// Where appends a list predicates to the ActivityMutation builder.
func (m *ActivityMutation) Where(ps ...predicate.Activity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, activity.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, activity.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, activity.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, activity.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, activity.FieldDescription)
	}
	if m.start_time != nil {
		fields = append(fields, activity.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, activity.FieldEndTime)
	}
	if m.remark != nil {
		fields = append(fields, activity.FieldRemark)
	}
	if m.online != nil {
		fields = append(fields, activity.FieldOnline)
	}
	if m.entrance_img != nil {
		fields = append(fields, activity.FieldEntranceImg)
	}
	if m.internal_top_img != nil {
		fields = append(fields, activity.FieldInternalTopImg)
	}
	if m.name != nil {
		fields = append(fields, activity.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldCreateTime:
		return m.CreateTime()
	case activity.FieldUpdateTime:
		return m.UpdateTime()
	case activity.FieldDeleteTime:
		return m.DeleteTime()
	case activity.FieldTitle:
		return m.Title()
	case activity.FieldDescription:
		return m.Description()
	case activity.FieldStartTime:
		return m.StartTime()
	case activity.FieldEndTime:
		return m.EndTime()
	case activity.FieldRemark:
		return m.Remark()
	case activity.FieldOnline:
		return m.Online()
	case activity.FieldEntranceImg:
		return m.EntranceImg()
	case activity.FieldInternalTopImg:
		return m.InternalTopImg()
	case activity.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case activity.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case activity.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case activity.FieldTitle:
		return m.OldTitle(ctx)
	case activity.FieldDescription:
		return m.OldDescription(ctx)
	case activity.FieldStartTime:
		return m.OldStartTime(ctx)
	case activity.FieldEndTime:
		return m.OldEndTime(ctx)
	case activity.FieldRemark:
		return m.OldRemark(ctx)
	case activity.FieldOnline:
		return m.OldOnline(ctx)
	case activity.FieldEntranceImg:
		return m.OldEntranceImg(ctx)
	case activity.FieldInternalTopImg:
		return m.OldInternalTopImg(ctx)
	case activity.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case activity.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case activity.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case activity.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case activity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case activity.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case activity.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case activity.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case activity.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case activity.FieldEntranceImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntranceImg(v)
		return nil
	case activity.FieldInternalTopImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalTopImg(v)
		return nil
	case activity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityMutation) AddedFields() []string {
	var fields []string
	if m.addonline != nil {
		fields = append(fields, activity.FieldOnline)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldOnline:
		return m.AddedOnline()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activity.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnline(v)
		return nil
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activity.FieldDeleteTime) {
		fields = append(fields, activity.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	switch name {
	case activity.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case activity.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case activity.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case activity.FieldTitle:
		m.ResetTitle()
		return nil
	case activity.FieldDescription:
		m.ResetDescription()
		return nil
	case activity.FieldStartTime:
		m.ResetStartTime()
		return nil
	case activity.FieldEndTime:
		m.ResetEndTime()
		return nil
	case activity.FieldRemark:
		m.ResetRemark()
		return nil
	case activity.FieldOnline:
		m.ResetOnline()
		return nil
	case activity.FieldEntranceImg:
		m.ResetEntranceImg()
		return nil
	case activity.FieldInternalTopImg:
		m.ResetInternalTopImg()
		return nil
	case activity.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.coupon != nil {
		edges = append(edges, activity.EdgeCoupon)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeCoupon:
		ids := make([]ent.Value, 0, len(m.coupon))
		for id := range m.coupon {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcoupon != nil {
		edges = append(edges, activity.EdgeCoupon)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case activity.EdgeCoupon:
		ids := make([]ent.Value, 0, len(m.removedcoupon))
		for id := range m.removedcoupon {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcoupon {
		edges = append(edges, activity.EdgeCoupon)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case activity.EdgeCoupon:
		return m.clearedcoupon
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	switch name {
	case activity.EdgeCoupon:
		m.ResetCoupon()
		return nil
	}
	return fmt.Errorf("unknown Activity edge %s", name)
}

// BannerMutation represents an operation that mutates the Banner nodes in the graph.
type BannerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	create_time        *time.Time
	update_time        *time.Time
	delete_time        *time.Time
	name               *string
	description        *string
	title              *string
	img                *string
	clearedFields      map[string]struct{}
	banner_item        map[int64]struct{}
	removedbanner_item map[int64]struct{}
	clearedbanner_item bool
	done               bool
	oldValue           func(context.Context) (*Banner, error)
	predicates         []predicate.Banner
}

var _ ent.Mutation = (*BannerMutation)(nil)

// bannerOption allows management of the mutation configuration using functional options.
type bannerOption func(*BannerMutation)

// newBannerMutation creates new mutation for the Banner entity.
func newBannerMutation(c config, op Op, opts ...bannerOption) *BannerMutation {
	m := &BannerMutation{
		config:        c,
		op:            op,
		typ:           TypeBanner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerID sets the ID field of the mutation.
func withBannerID(id int64) bannerOption {
	return func(m *BannerMutation) {
		var (
			err   error
			once  sync.Once
			value *Banner
		)
		m.oldValue = func(ctx context.Context) (*Banner, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Banner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBanner sets the old Banner of the mutation.
func withBanner(node *Banner) bannerOption {
	return func(m *BannerMutation) {
		m.oldValue = func(context.Context) (*Banner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *BannerMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BannerMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BannerMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BannerMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BannerMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BannerMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *BannerMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *BannerMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *BannerMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[banner.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *BannerMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[banner.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *BannerMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, banner.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *BannerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BannerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BannerMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BannerMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BannerMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BannerMutation) ResetDescription() {
	m.description = nil
}

// SetTitle sets the "title" field.
func (m *BannerMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *BannerMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *BannerMutation) ResetTitle() {
	m.title = nil
}

// SetImg sets the "img" field.
func (m *BannerMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *BannerMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the Banner entity.
// If the Banner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *BannerMutation) ResetImg() {
	m.img = nil
}

// AddBannerItemIDs adds the "banner_item" edge to the BannerItem entity by ids.
func (m *BannerMutation) AddBannerItemIDs(ids ...int64) {
	if m.banner_item == nil {
		m.banner_item = make(map[int64]struct{})
	}
	for i := range ids {
		m.banner_item[ids[i]] = struct{}{}
	}
}

// ClearBannerItem clears the "banner_item" edge to the BannerItem entity.
func (m *BannerMutation) ClearBannerItem() {
	m.clearedbanner_item = true
}

// BannerItemCleared reports if the "banner_item" edge to the BannerItem entity was cleared.
func (m *BannerMutation) BannerItemCleared() bool {
	return m.clearedbanner_item
}

// RemoveBannerItemIDs removes the "banner_item" edge to the BannerItem entity by IDs.
func (m *BannerMutation) RemoveBannerItemIDs(ids ...int64) {
	if m.removedbanner_item == nil {
		m.removedbanner_item = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.banner_item, ids[i])
		m.removedbanner_item[ids[i]] = struct{}{}
	}
}

// RemovedBannerItem returns the removed IDs of the "banner_item" edge to the BannerItem entity.
func (m *BannerMutation) RemovedBannerItemIDs() (ids []int64) {
	for id := range m.removedbanner_item {
		ids = append(ids, id)
	}
	return
}

// BannerItemIDs returns the "banner_item" edge IDs in the mutation.
func (m *BannerMutation) BannerItemIDs() (ids []int64) {
	for id := range m.banner_item {
		ids = append(ids, id)
	}
	return
}

// ResetBannerItem resets all changes to the "banner_item" edge.
func (m *BannerMutation) ResetBannerItem() {
	m.banner_item = nil
	m.clearedbanner_item = false
	m.removedbanner_item = nil
}

// Where appends a list predicates to the BannerMutation builder.
func (m *BannerMutation) Where(ps ...predicate.Banner) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BannerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Banner).
func (m *BannerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, banner.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, banner.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, banner.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, banner.FieldName)
	}
	if m.description != nil {
		fields = append(fields, banner.FieldDescription)
	}
	if m.title != nil {
		fields = append(fields, banner.FieldTitle)
	}
	if m.img != nil {
		fields = append(fields, banner.FieldImg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banner.FieldCreateTime:
		return m.CreateTime()
	case banner.FieldUpdateTime:
		return m.UpdateTime()
	case banner.FieldDeleteTime:
		return m.DeleteTime()
	case banner.FieldName:
		return m.Name()
	case banner.FieldDescription:
		return m.Description()
	case banner.FieldTitle:
		return m.Title()
	case banner.FieldImg:
		return m.Img()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banner.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case banner.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case banner.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case banner.FieldName:
		return m.OldName(ctx)
	case banner.FieldDescription:
		return m.OldDescription(ctx)
	case banner.FieldTitle:
		return m.OldTitle(ctx)
	case banner.FieldImg:
		return m.OldImg(ctx)
	}
	return nil, fmt.Errorf("unknown Banner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banner.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case banner.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case banner.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case banner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case banner.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case banner.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case banner.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Banner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(banner.FieldDeleteTime) {
		fields = append(fields, banner.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerMutation) ClearField(name string) error {
	switch name {
	case banner.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Banner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerMutation) ResetField(name string) error {
	switch name {
	case banner.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case banner.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case banner.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case banner.FieldName:
		m.ResetName()
		return nil
	case banner.FieldDescription:
		m.ResetDescription()
		return nil
	case banner.FieldTitle:
		m.ResetTitle()
		return nil
	case banner.FieldImg:
		m.ResetImg()
		return nil
	}
	return fmt.Errorf("unknown Banner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.banner_item != nil {
		edges = append(edges, banner.EdgeBannerItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case banner.EdgeBannerItem:
		ids := make([]ent.Value, 0, len(m.banner_item))
		for id := range m.banner_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedbanner_item != nil {
		edges = append(edges, banner.EdgeBannerItem)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case banner.EdgeBannerItem:
		ids := make([]ent.Value, 0, len(m.removedbanner_item))
		for id := range m.removedbanner_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbanner_item {
		edges = append(edges, banner.EdgeBannerItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerMutation) EdgeCleared(name string) bool {
	switch name {
	case banner.EdgeBannerItem:
		return m.clearedbanner_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Banner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerMutation) ResetEdge(name string) error {
	switch name {
	case banner.EdgeBannerItem:
		m.ResetBannerItem()
		return nil
	}
	return fmt.Errorf("unknown Banner edge %s", name)
}

// BannerItemMutation represents an operation that mutates the BannerItem nodes in the graph.
type BannerItemMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	img           *string
	keyword       *string
	_type         *int
	add_type      *int
	name          *string
	clearedFields map[string]struct{}
	banner        *int64
	clearedbanner bool
	done          bool
	oldValue      func(context.Context) (*BannerItem, error)
	predicates    []predicate.BannerItem
}

var _ ent.Mutation = (*BannerItemMutation)(nil)

// banneritemOption allows management of the mutation configuration using functional options.
type banneritemOption func(*BannerItemMutation)

// newBannerItemMutation creates new mutation for the BannerItem entity.
func newBannerItemMutation(c config, op Op, opts ...banneritemOption) *BannerItemMutation {
	m := &BannerItemMutation{
		config:        c,
		op:            op,
		typ:           TypeBannerItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBannerItemID sets the ID field of the mutation.
func withBannerItemID(id int64) banneritemOption {
	return func(m *BannerItemMutation) {
		var (
			err   error
			once  sync.Once
			value *BannerItem
		)
		m.oldValue = func(ctx context.Context) (*BannerItem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BannerItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBannerItem sets the old BannerItem of the mutation.
func withBannerItem(node *BannerItem) banneritemOption {
	return func(m *BannerItemMutation) {
		m.oldValue = func(context.Context) (*BannerItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BannerItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BannerItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BannerItemMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *BannerItemMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BannerItemMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BannerItemMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BannerItemMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BannerItemMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BannerItemMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *BannerItemMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *BannerItemMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *BannerItemMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[banneritem.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *BannerItemMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[banneritem.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *BannerItemMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, banneritem.FieldDeleteTime)
}

// SetImg sets the "img" field.
func (m *BannerItemMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *BannerItemMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *BannerItemMutation) ResetImg() {
	m.img = nil
}

// SetKeyword sets the "keyword" field.
func (m *BannerItemMutation) SetKeyword(s string) {
	m.keyword = &s
}

// Keyword returns the value of the "keyword" field in the mutation.
func (m *BannerItemMutation) Keyword() (r string, exists bool) {
	v := m.keyword
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyword returns the old "keyword" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldKeyword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKeyword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKeyword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyword: %w", err)
	}
	return oldValue.Keyword, nil
}

// ResetKeyword resets all changes to the "keyword" field.
func (m *BannerItemMutation) ResetKeyword() {
	m.keyword = nil
}

// SetType sets the "type" field.
func (m *BannerItemMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *BannerItemMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *BannerItemMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *BannerItemMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *BannerItemMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetBannerID sets the "banner_id" field.
func (m *BannerItemMutation) SetBannerID(i int64) {
	m.banner = &i
}

// BannerID returns the value of the "banner_id" field in the mutation.
func (m *BannerItemMutation) BannerID() (r int64, exists bool) {
	v := m.banner
	if v == nil {
		return
	}
	return *v, true
}

// OldBannerID returns the old "banner_id" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldBannerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBannerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBannerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBannerID: %w", err)
	}
	return oldValue.BannerID, nil
}

// ClearBannerID clears the value of the "banner_id" field.
func (m *BannerItemMutation) ClearBannerID() {
	m.banner = nil
	m.clearedFields[banneritem.FieldBannerID] = struct{}{}
}

// BannerIDCleared returns if the "banner_id" field was cleared in this mutation.
func (m *BannerItemMutation) BannerIDCleared() bool {
	_, ok := m.clearedFields[banneritem.FieldBannerID]
	return ok
}

// ResetBannerID resets all changes to the "banner_id" field.
func (m *BannerItemMutation) ResetBannerID() {
	m.banner = nil
	delete(m.clearedFields, banneritem.FieldBannerID)
}

// SetName sets the "name" field.
func (m *BannerItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BannerItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BannerItem entity.
// If the BannerItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BannerItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BannerItemMutation) ResetName() {
	m.name = nil
}

// ClearBanner clears the "banner" edge to the Banner entity.
func (m *BannerItemMutation) ClearBanner() {
	m.clearedbanner = true
}

// BannerCleared reports if the "banner" edge to the Banner entity was cleared.
func (m *BannerItemMutation) BannerCleared() bool {
	return m.BannerIDCleared() || m.clearedbanner
}

// BannerIDs returns the "banner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BannerID instead. It exists only for internal usage by the builders.
func (m *BannerItemMutation) BannerIDs() (ids []int64) {
	if id := m.banner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBanner resets all changes to the "banner" edge.
func (m *BannerItemMutation) ResetBanner() {
	m.banner = nil
	m.clearedbanner = false
}

// Where appends a list predicates to the BannerItemMutation builder.
func (m *BannerItemMutation) Where(ps ...predicate.BannerItem) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BannerItemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BannerItem).
func (m *BannerItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BannerItemMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, banneritem.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, banneritem.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, banneritem.FieldDeleteTime)
	}
	if m.img != nil {
		fields = append(fields, banneritem.FieldImg)
	}
	if m.keyword != nil {
		fields = append(fields, banneritem.FieldKeyword)
	}
	if m._type != nil {
		fields = append(fields, banneritem.FieldType)
	}
	if m.banner != nil {
		fields = append(fields, banneritem.FieldBannerID)
	}
	if m.name != nil {
		fields = append(fields, banneritem.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BannerItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case banneritem.FieldCreateTime:
		return m.CreateTime()
	case banneritem.FieldUpdateTime:
		return m.UpdateTime()
	case banneritem.FieldDeleteTime:
		return m.DeleteTime()
	case banneritem.FieldImg:
		return m.Img()
	case banneritem.FieldKeyword:
		return m.Keyword()
	case banneritem.FieldType:
		return m.GetType()
	case banneritem.FieldBannerID:
		return m.BannerID()
	case banneritem.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BannerItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case banneritem.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case banneritem.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case banneritem.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case banneritem.FieldImg:
		return m.OldImg(ctx)
	case banneritem.FieldKeyword:
		return m.OldKeyword(ctx)
	case banneritem.FieldType:
		return m.OldType(ctx)
	case banneritem.FieldBannerID:
		return m.OldBannerID(ctx)
	case banneritem.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown BannerItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case banneritem.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case banneritem.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case banneritem.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case banneritem.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case banneritem.FieldKeyword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyword(v)
		return nil
	case banneritem.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case banneritem.FieldBannerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannerID(v)
		return nil
	case banneritem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown BannerItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BannerItemMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, banneritem.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BannerItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case banneritem.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BannerItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case banneritem.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown BannerItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BannerItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(banneritem.FieldDeleteTime) {
		fields = append(fields, banneritem.FieldDeleteTime)
	}
	if m.FieldCleared(banneritem.FieldBannerID) {
		fields = append(fields, banneritem.FieldBannerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BannerItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BannerItemMutation) ClearField(name string) error {
	switch name {
	case banneritem.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case banneritem.FieldBannerID:
		m.ClearBannerID()
		return nil
	}
	return fmt.Errorf("unknown BannerItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BannerItemMutation) ResetField(name string) error {
	switch name {
	case banneritem.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case banneritem.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case banneritem.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case banneritem.FieldImg:
		m.ResetImg()
		return nil
	case banneritem.FieldKeyword:
		m.ResetKeyword()
		return nil
	case banneritem.FieldType:
		m.ResetType()
		return nil
	case banneritem.FieldBannerID:
		m.ResetBannerID()
		return nil
	case banneritem.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown BannerItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BannerItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.banner != nil {
		edges = append(edges, banneritem.EdgeBanner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BannerItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case banneritem.EdgeBanner:
		if id := m.banner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BannerItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BannerItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BannerItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbanner {
		edges = append(edges, banneritem.EdgeBanner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BannerItemMutation) EdgeCleared(name string) bool {
	switch name {
	case banneritem.EdgeBanner:
		return m.clearedbanner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BannerItemMutation) ClearEdge(name string) error {
	switch name {
	case banneritem.EdgeBanner:
		m.ClearBanner()
		return nil
	}
	return fmt.Errorf("unknown BannerItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BannerItemMutation) ResetEdge(name string) error {
	switch name {
	case banneritem.EdgeBanner:
		m.ResetBanner()
		return nil
	}
	return fmt.Errorf("unknown BannerItem edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	create_time     *time.Time
	update_time     *time.Time
	delete_time     *time.Time
	name            *string
	description     *string
	is_root         *int
	addis_root      *int
	img             *string
	index           *int
	addindex        *int
	online          *int
	addonline       *int
	level           *int
	addlevel        *int
	clearedFields   map[string]struct{}
	coupon          map[int64]struct{}
	removedcoupon   map[int64]struct{}
	clearedcoupon   bool
	parent          *int64
	clearedparent   bool
	children        map[int64]struct{}
	removedchildren map[int64]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*Category, error)
	predicates      []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int64) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *CategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *CategoryMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CategoryMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CategoryMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[category.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CategoryMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[category.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CategoryMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, category.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CategoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CategoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CategoryMutation) ResetDescription() {
	m.description = nil
}

// SetIsRoot sets the "is_root" field.
func (m *CategoryMutation) SetIsRoot(i int) {
	m.is_root = &i
	m.addis_root = nil
}

// IsRoot returns the value of the "is_root" field in the mutation.
func (m *CategoryMutation) IsRoot() (r int, exists bool) {
	v := m.is_root
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRoot returns the old "is_root" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldIsRoot(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsRoot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsRoot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRoot: %w", err)
	}
	return oldValue.IsRoot, nil
}

// AddIsRoot adds i to the "is_root" field.
func (m *CategoryMutation) AddIsRoot(i int) {
	if m.addis_root != nil {
		*m.addis_root += i
	} else {
		m.addis_root = &i
	}
}

// AddedIsRoot returns the value that was added to the "is_root" field in this mutation.
func (m *CategoryMutation) AddedIsRoot() (r int, exists bool) {
	v := m.addis_root
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsRoot resets all changes to the "is_root" field.
func (m *CategoryMutation) ResetIsRoot() {
	m.is_root = nil
	m.addis_root = nil
}

// SetParentID sets the "parent_id" field.
func (m *CategoryMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CategoryMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CategoryMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[category.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CategoryMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, category.FieldParentID)
}

// SetImg sets the "img" field.
func (m *CategoryMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *CategoryMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *CategoryMutation) ResetImg() {
	m.img = nil
}

// SetIndex sets the "index" field.
func (m *CategoryMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *CategoryMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *CategoryMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *CategoryMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *CategoryMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetOnline sets the "online" field.
func (m *CategoryMutation) SetOnline(i int) {
	m.online = &i
	m.addonline = nil
}

// Online returns the value of the "online" field in the mutation.
func (m *CategoryMutation) Online() (r int, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldOnline(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// AddOnline adds i to the "online" field.
func (m *CategoryMutation) AddOnline(i int) {
	if m.addonline != nil {
		*m.addonline += i
	} else {
		m.addonline = &i
	}
}

// AddedOnline returns the value that was added to the "online" field in this mutation.
func (m *CategoryMutation) AddedOnline() (r int, exists bool) {
	v := m.addonline
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnline resets all changes to the "online" field.
func (m *CategoryMutation) ResetOnline() {
	m.online = nil
	m.addonline = nil
}

// SetLevel sets the "level" field.
func (m *CategoryMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CategoryMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *CategoryMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CategoryMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *CategoryMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// AddCouponIDs adds the "coupon" edge to the Coupon entity by ids.
func (m *CategoryMutation) AddCouponIDs(ids ...int64) {
	if m.coupon == nil {
		m.coupon = make(map[int64]struct{})
	}
	for i := range ids {
		m.coupon[ids[i]] = struct{}{}
	}
}

// ClearCoupon clears the "coupon" edge to the Coupon entity.
func (m *CategoryMutation) ClearCoupon() {
	m.clearedcoupon = true
}

// CouponCleared reports if the "coupon" edge to the Coupon entity was cleared.
func (m *CategoryMutation) CouponCleared() bool {
	return m.clearedcoupon
}

// RemoveCouponIDs removes the "coupon" edge to the Coupon entity by IDs.
func (m *CategoryMutation) RemoveCouponIDs(ids ...int64) {
	if m.removedcoupon == nil {
		m.removedcoupon = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.coupon, ids[i])
		m.removedcoupon[ids[i]] = struct{}{}
	}
}

// RemovedCoupon returns the removed IDs of the "coupon" edge to the Coupon entity.
func (m *CategoryMutation) RemovedCouponIDs() (ids []int64) {
	for id := range m.removedcoupon {
		ids = append(ids, id)
	}
	return
}

// CouponIDs returns the "coupon" edge IDs in the mutation.
func (m *CategoryMutation) CouponIDs() (ids []int64) {
	for id := range m.coupon {
		ids = append(ids, id)
	}
	return
}

// ResetCoupon resets all changes to the "coupon" edge.
func (m *CategoryMutation) ResetCoupon() {
	m.coupon = nil
	m.clearedcoupon = false
	m.removedcoupon = nil
}

// ClearParent clears the "parent" edge to the Category entity.
func (m *CategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Category entity was cleared.
func (m *CategoryMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Category entity by ids.
func (m *CategoryMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Category entity.
func (m *CategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Category entity was cleared.
func (m *CategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Category entity by IDs.
func (m *CategoryMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Category entity.
func (m *CategoryMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CategoryMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.create_time != nil {
		fields = append(fields, category.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, category.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, category.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.description != nil {
		fields = append(fields, category.FieldDescription)
	}
	if m.is_root != nil {
		fields = append(fields, category.FieldIsRoot)
	}
	if m.parent != nil {
		fields = append(fields, category.FieldParentID)
	}
	if m.img != nil {
		fields = append(fields, category.FieldImg)
	}
	if m.index != nil {
		fields = append(fields, category.FieldIndex)
	}
	if m.online != nil {
		fields = append(fields, category.FieldOnline)
	}
	if m.level != nil {
		fields = append(fields, category.FieldLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldCreateTime:
		return m.CreateTime()
	case category.FieldUpdateTime:
		return m.UpdateTime()
	case category.FieldDeleteTime:
		return m.DeleteTime()
	case category.FieldName:
		return m.Name()
	case category.FieldDescription:
		return m.Description()
	case category.FieldIsRoot:
		return m.IsRoot()
	case category.FieldParentID:
		return m.ParentID()
	case category.FieldImg:
		return m.Img()
	case category.FieldIndex:
		return m.Index()
	case category.FieldOnline:
		return m.Online()
	case category.FieldLevel:
		return m.Level()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case category.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case category.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldDescription:
		return m.OldDescription(ctx)
	case category.FieldIsRoot:
		return m.OldIsRoot(ctx)
	case category.FieldParentID:
		return m.OldParentID(ctx)
	case category.FieldImg:
		return m.OldImg(ctx)
	case category.FieldIndex:
		return m.OldIndex(ctx)
	case category.FieldOnline:
		return m.OldOnline(ctx)
	case category.FieldLevel:
		return m.OldLevel(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case category.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case category.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case category.FieldIsRoot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRoot(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case category.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case category.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case category.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case category.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addis_root != nil {
		fields = append(fields, category.FieldIsRoot)
	}
	if m.addindex != nil {
		fields = append(fields, category.FieldIndex)
	}
	if m.addonline != nil {
		fields = append(fields, category.FieldOnline)
	}
	if m.addlevel != nil {
		fields = append(fields, category.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldIsRoot:
		return m.AddedIsRoot()
	case category.FieldIndex:
		return m.AddedIndex()
	case category.FieldOnline:
		return m.AddedOnline()
	case category.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldIsRoot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsRoot(v)
		return nil
	case category.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case category.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnline(v)
		return nil
	case category.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldDeleteTime) {
		fields = append(fields, category.FieldDeleteTime)
	}
	if m.FieldCleared(category.FieldParentID) {
		fields = append(fields, category.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case category.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case category.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case category.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldDescription:
		m.ResetDescription()
		return nil
	case category.FieldIsRoot:
		m.ResetIsRoot()
		return nil
	case category.FieldParentID:
		m.ResetParentID()
		return nil
	case category.FieldImg:
		m.ResetImg()
		return nil
	case category.FieldIndex:
		m.ResetIndex()
		return nil
	case category.FieldOnline:
		m.ResetOnline()
		return nil
	case category.FieldLevel:
		m.ResetLevel()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.coupon != nil {
		edges = append(edges, category.EdgeCoupon)
	}
	if m.parent != nil {
		edges = append(edges, category.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCoupon:
		ids := make([]ent.Value, 0, len(m.coupon))
		for id := range m.coupon {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcoupon != nil {
		edges = append(edges, category.EdgeCoupon)
	}
	if m.removedchildren != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCoupon:
		ids := make([]ent.Value, 0, len(m.removedcoupon))
		for id := range m.removedcoupon {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcoupon {
		edges = append(edges, category.EdgeCoupon)
	}
	if m.clearedparent {
		edges = append(edges, category.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeCoupon:
		return m.clearedcoupon
	case category.EdgeParent:
		return m.clearedparent
	case category.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeCoupon:
		m.ResetCoupon()
		return nil
	case category.EdgeParent:
		m.ResetParent()
		return nil
	case category.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// ChargeMutation represents an operation that mutates the Charge nodes in the graph.
type ChargeMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	create_time    *time.Time
	update_time    *time.Time
	delete_time    *time.Time
	user_id        *int64
	adduser_id     *int64
	amount         *string
	charge_no      *string
	transaction_id *string
	pay_way        *int
	addpay_way     *int
	client_type    *int
	addclient_type *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Charge, error)
	predicates     []predicate.Charge
}

var _ ent.Mutation = (*ChargeMutation)(nil)

// chargeOption allows management of the mutation configuration using functional options.
type chargeOption func(*ChargeMutation)

// newChargeMutation creates new mutation for the Charge entity.
func newChargeMutation(c config, op Op, opts ...chargeOption) *ChargeMutation {
	m := &ChargeMutation{
		config:        c,
		op:            op,
		typ:           TypeCharge,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChargeID sets the ID field of the mutation.
func withChargeID(id int64) chargeOption {
	return func(m *ChargeMutation) {
		var (
			err   error
			once  sync.Once
			value *Charge
		)
		m.oldValue = func(ctx context.Context) (*Charge, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Charge.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCharge sets the old Charge of the mutation.
func withCharge(node *Charge) chargeOption {
	return func(m *ChargeMutation) {
		m.oldValue = func(context.Context) (*Charge, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChargeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChargeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChargeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ChargeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ChargeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ChargeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ChargeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ChargeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ChargeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *ChargeMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *ChargeMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *ChargeMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[charge.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *ChargeMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[charge.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *ChargeMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, charge.FieldDeleteTime)
}

// SetUserID sets the "user_id" field.
func (m *ChargeMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ChargeMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *ChargeMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *ChargeMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ChargeMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetAmount sets the "amount" field.
func (m *ChargeMutation) SetAmount(s string) {
	m.amount = &s
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ChargeMutation) Amount() (r string, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// ResetAmount resets all changes to the "amount" field.
func (m *ChargeMutation) ResetAmount() {
	m.amount = nil
}

// SetChargeNo sets the "charge_no" field.
func (m *ChargeMutation) SetChargeNo(s string) {
	m.charge_no = &s
}

// ChargeNo returns the value of the "charge_no" field in the mutation.
func (m *ChargeMutation) ChargeNo() (r string, exists bool) {
	v := m.charge_no
	if v == nil {
		return
	}
	return *v, true
}

// OldChargeNo returns the old "charge_no" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldChargeNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldChargeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldChargeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChargeNo: %w", err)
	}
	return oldValue.ChargeNo, nil
}

// ResetChargeNo resets all changes to the "charge_no" field.
func (m *ChargeMutation) ResetChargeNo() {
	m.charge_no = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *ChargeMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *ChargeMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *ChargeMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// SetPayWay sets the "pay_way" field.
func (m *ChargeMutation) SetPayWay(i int) {
	m.pay_way = &i
	m.addpay_way = nil
}

// PayWay returns the value of the "pay_way" field in the mutation.
func (m *ChargeMutation) PayWay() (r int, exists bool) {
	v := m.pay_way
	if v == nil {
		return
	}
	return *v, true
}

// OldPayWay returns the old "pay_way" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldPayWay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPayWay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPayWay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayWay: %w", err)
	}
	return oldValue.PayWay, nil
}

// AddPayWay adds i to the "pay_way" field.
func (m *ChargeMutation) AddPayWay(i int) {
	if m.addpay_way != nil {
		*m.addpay_way += i
	} else {
		m.addpay_way = &i
	}
}

// AddedPayWay returns the value that was added to the "pay_way" field in this mutation.
func (m *ChargeMutation) AddedPayWay() (r int, exists bool) {
	v := m.addpay_way
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayWay resets all changes to the "pay_way" field.
func (m *ChargeMutation) ResetPayWay() {
	m.pay_way = nil
	m.addpay_way = nil
}

// SetClientType sets the "client_type" field.
func (m *ChargeMutation) SetClientType(i int) {
	m.client_type = &i
	m.addclient_type = nil
}

// ClientType returns the value of the "client_type" field in the mutation.
func (m *ChargeMutation) ClientType() (r int, exists bool) {
	v := m.client_type
	if v == nil {
		return
	}
	return *v, true
}

// OldClientType returns the old "client_type" field's value of the Charge entity.
// If the Charge object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChargeMutation) OldClientType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClientType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClientType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientType: %w", err)
	}
	return oldValue.ClientType, nil
}

// AddClientType adds i to the "client_type" field.
func (m *ChargeMutation) AddClientType(i int) {
	if m.addclient_type != nil {
		*m.addclient_type += i
	} else {
		m.addclient_type = &i
	}
}

// AddedClientType returns the value that was added to the "client_type" field in this mutation.
func (m *ChargeMutation) AddedClientType() (r int, exists bool) {
	v := m.addclient_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientType resets all changes to the "client_type" field.
func (m *ChargeMutation) ResetClientType() {
	m.client_type = nil
	m.addclient_type = nil
}

// Where appends a list predicates to the ChargeMutation builder.
func (m *ChargeMutation) Where(ps ...predicate.Charge) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ChargeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Charge).
func (m *ChargeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChargeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, charge.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, charge.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, charge.FieldDeleteTime)
	}
	if m.user_id != nil {
		fields = append(fields, charge.FieldUserID)
	}
	if m.amount != nil {
		fields = append(fields, charge.FieldAmount)
	}
	if m.charge_no != nil {
		fields = append(fields, charge.FieldChargeNo)
	}
	if m.transaction_id != nil {
		fields = append(fields, charge.FieldTransactionID)
	}
	if m.pay_way != nil {
		fields = append(fields, charge.FieldPayWay)
	}
	if m.client_type != nil {
		fields = append(fields, charge.FieldClientType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChargeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case charge.FieldCreateTime:
		return m.CreateTime()
	case charge.FieldUpdateTime:
		return m.UpdateTime()
	case charge.FieldDeleteTime:
		return m.DeleteTime()
	case charge.FieldUserID:
		return m.UserID()
	case charge.FieldAmount:
		return m.Amount()
	case charge.FieldChargeNo:
		return m.ChargeNo()
	case charge.FieldTransactionID:
		return m.TransactionID()
	case charge.FieldPayWay:
		return m.PayWay()
	case charge.FieldClientType:
		return m.ClientType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChargeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case charge.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case charge.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case charge.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case charge.FieldUserID:
		return m.OldUserID(ctx)
	case charge.FieldAmount:
		return m.OldAmount(ctx)
	case charge.FieldChargeNo:
		return m.OldChargeNo(ctx)
	case charge.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case charge.FieldPayWay:
		return m.OldPayWay(ctx)
	case charge.FieldClientType:
		return m.OldClientType(ctx)
	}
	return nil, fmt.Errorf("unknown Charge field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChargeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case charge.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case charge.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case charge.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case charge.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case charge.FieldAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case charge.FieldChargeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChargeNo(v)
		return nil
	case charge.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case charge.FieldPayWay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayWay(v)
		return nil
	case charge.FieldClientType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientType(v)
		return nil
	}
	return fmt.Errorf("unknown Charge field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChargeMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, charge.FieldUserID)
	}
	if m.addpay_way != nil {
		fields = append(fields, charge.FieldPayWay)
	}
	if m.addclient_type != nil {
		fields = append(fields, charge.FieldClientType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChargeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case charge.FieldUserID:
		return m.AddedUserID()
	case charge.FieldPayWay:
		return m.AddedPayWay()
	case charge.FieldClientType:
		return m.AddedClientType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChargeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case charge.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case charge.FieldPayWay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayWay(v)
		return nil
	case charge.FieldClientType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientType(v)
		return nil
	}
	return fmt.Errorf("unknown Charge numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChargeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(charge.FieldDeleteTime) {
		fields = append(fields, charge.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChargeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChargeMutation) ClearField(name string) error {
	switch name {
	case charge.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Charge nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChargeMutation) ResetField(name string) error {
	switch name {
	case charge.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case charge.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case charge.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case charge.FieldUserID:
		m.ResetUserID()
		return nil
	case charge.FieldAmount:
		m.ResetAmount()
		return nil
	case charge.FieldChargeNo:
		m.ResetChargeNo()
		return nil
	case charge.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case charge.FieldPayWay:
		m.ResetPayWay()
		return nil
	case charge.FieldClientType:
		m.ResetClientType()
		return nil
	}
	return fmt.Errorf("unknown Charge field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChargeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChargeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChargeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChargeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChargeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChargeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChargeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Charge unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChargeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Charge edge %s", name)
}

// CouponMutation represents an operation that mutates the Coupon nodes in the graph.
type CouponMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	create_time     *time.Time
	update_time     *time.Time
	delete_time     *time.Time
	title           *string
	start_time      *time.Time
	end_time        *time.Time
	description     *string
	full_money      *float64
	addfull_money   *float64
	minus           *float64
	addminus        *float64
	rate            *float64
	addrate         *float64
	_type           *int
	add_type        *int
	valitiy         *int
	addvalitiy      *int
	activity_id     *int64
	addactivity_id  *int64
	remark          *string
	whole_store     *int
	addwhole_store  *int
	clearedFields   map[string]struct{}
	category        map[int64]struct{}
	removedcategory map[int64]struct{}
	clearedcategory bool
	activity        map[int64]struct{}
	removedactivity map[int64]struct{}
	clearedactivity bool
	done            bool
	oldValue        func(context.Context) (*Coupon, error)
	predicates      []predicate.Coupon
}

var _ ent.Mutation = (*CouponMutation)(nil)

// couponOption allows management of the mutation configuration using functional options.
type couponOption func(*CouponMutation)

// newCouponMutation creates new mutation for the Coupon entity.
func newCouponMutation(c config, op Op, opts ...couponOption) *CouponMutation {
	m := &CouponMutation{
		config:        c,
		op:            op,
		typ:           TypeCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponID sets the ID field of the mutation.
func withCouponID(id int64) couponOption {
	return func(m *CouponMutation) {
		var (
			err   error
			once  sync.Once
			value *Coupon
		)
		m.oldValue = func(ctx context.Context) (*Coupon, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoupon sets the old Coupon of the mutation.
func withCoupon(node *Coupon) couponOption {
	return func(m *CouponMutation) {
		m.oldValue = func(context.Context) (*Coupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *CouponMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CouponMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CouponMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CouponMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CouponMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CouponMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *CouponMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CouponMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CouponMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[coupon.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CouponMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[coupon.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CouponMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, coupon.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *CouponMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CouponMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CouponMutation) ResetTitle() {
	m.title = nil
}

// SetStartTime sets the "start_time" field.
func (m *CouponMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *CouponMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *CouponMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *CouponMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *CouponMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *CouponMutation) ResetEndTime() {
	m.end_time = nil
}

// SetDescription sets the "description" field.
func (m *CouponMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CouponMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CouponMutation) ResetDescription() {
	m.description = nil
}

// SetFullMoney sets the "full_money" field.
func (m *CouponMutation) SetFullMoney(f float64) {
	m.full_money = &f
	m.addfull_money = nil
}

// FullMoney returns the value of the "full_money" field in the mutation.
func (m *CouponMutation) FullMoney() (r float64, exists bool) {
	v := m.full_money
	if v == nil {
		return
	}
	return *v, true
}

// OldFullMoney returns the old "full_money" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldFullMoney(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFullMoney is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFullMoney requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullMoney: %w", err)
	}
	return oldValue.FullMoney, nil
}

// AddFullMoney adds f to the "full_money" field.
func (m *CouponMutation) AddFullMoney(f float64) {
	if m.addfull_money != nil {
		*m.addfull_money += f
	} else {
		m.addfull_money = &f
	}
}

// AddedFullMoney returns the value that was added to the "full_money" field in this mutation.
func (m *CouponMutation) AddedFullMoney() (r float64, exists bool) {
	v := m.addfull_money
	if v == nil {
		return
	}
	return *v, true
}

// ResetFullMoney resets all changes to the "full_money" field.
func (m *CouponMutation) ResetFullMoney() {
	m.full_money = nil
	m.addfull_money = nil
}

// SetMinus sets the "minus" field.
func (m *CouponMutation) SetMinus(f float64) {
	m.minus = &f
	m.addminus = nil
}

// Minus returns the value of the "minus" field in the mutation.
func (m *CouponMutation) Minus() (r float64, exists bool) {
	v := m.minus
	if v == nil {
		return
	}
	return *v, true
}

// OldMinus returns the old "minus" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldMinus(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMinus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMinus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinus: %w", err)
	}
	return oldValue.Minus, nil
}

// AddMinus adds f to the "minus" field.
func (m *CouponMutation) AddMinus(f float64) {
	if m.addminus != nil {
		*m.addminus += f
	} else {
		m.addminus = &f
	}
}

// AddedMinus returns the value that was added to the "minus" field in this mutation.
func (m *CouponMutation) AddedMinus() (r float64, exists bool) {
	v := m.addminus
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinus resets all changes to the "minus" field.
func (m *CouponMutation) ResetMinus() {
	m.minus = nil
	m.addminus = nil
}

// SetRate sets the "rate" field.
func (m *CouponMutation) SetRate(f float64) {
	m.rate = &f
	m.addrate = nil
}

// Rate returns the value of the "rate" field in the mutation.
func (m *CouponMutation) Rate() (r float64, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// AddRate adds f to the "rate" field.
func (m *CouponMutation) AddRate(f float64) {
	if m.addrate != nil {
		*m.addrate += f
	} else {
		m.addrate = &f
	}
}

// AddedRate returns the value that was added to the "rate" field in this mutation.
func (m *CouponMutation) AddedRate() (r float64, exists bool) {
	v := m.addrate
	if v == nil {
		return
	}
	return *v, true
}

// ResetRate resets all changes to the "rate" field.
func (m *CouponMutation) ResetRate() {
	m.rate = nil
	m.addrate = nil
}

// SetType sets the "type" field.
func (m *CouponMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *CouponMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *CouponMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *CouponMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *CouponMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetValitiy sets the "valitiy" field.
func (m *CouponMutation) SetValitiy(i int) {
	m.valitiy = &i
	m.addvalitiy = nil
}

// Valitiy returns the value of the "valitiy" field in the mutation.
func (m *CouponMutation) Valitiy() (r int, exists bool) {
	v := m.valitiy
	if v == nil {
		return
	}
	return *v, true
}

// OldValitiy returns the old "valitiy" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldValitiy(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValitiy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValitiy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValitiy: %w", err)
	}
	return oldValue.Valitiy, nil
}

// AddValitiy adds i to the "valitiy" field.
func (m *CouponMutation) AddValitiy(i int) {
	if m.addvalitiy != nil {
		*m.addvalitiy += i
	} else {
		m.addvalitiy = &i
	}
}

// AddedValitiy returns the value that was added to the "valitiy" field in this mutation.
func (m *CouponMutation) AddedValitiy() (r int, exists bool) {
	v := m.addvalitiy
	if v == nil {
		return
	}
	return *v, true
}

// ResetValitiy resets all changes to the "valitiy" field.
func (m *CouponMutation) ResetValitiy() {
	m.valitiy = nil
	m.addvalitiy = nil
}

// SetActivityID sets the "activity_id" field.
func (m *CouponMutation) SetActivityID(i int64) {
	m.activity_id = &i
	m.addactivity_id = nil
}

// ActivityID returns the value of the "activity_id" field in the mutation.
func (m *CouponMutation) ActivityID() (r int64, exists bool) {
	v := m.activity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityID returns the old "activity_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldActivityID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityID: %w", err)
	}
	return oldValue.ActivityID, nil
}

// AddActivityID adds i to the "activity_id" field.
func (m *CouponMutation) AddActivityID(i int64) {
	if m.addactivity_id != nil {
		*m.addactivity_id += i
	} else {
		m.addactivity_id = &i
	}
}

// AddedActivityID returns the value that was added to the "activity_id" field in this mutation.
func (m *CouponMutation) AddedActivityID() (r int64, exists bool) {
	v := m.addactivity_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearActivityID clears the value of the "activity_id" field.
func (m *CouponMutation) ClearActivityID() {
	m.activity_id = nil
	m.addactivity_id = nil
	m.clearedFields[coupon.FieldActivityID] = struct{}{}
}

// ActivityIDCleared returns if the "activity_id" field was cleared in this mutation.
func (m *CouponMutation) ActivityIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldActivityID]
	return ok
}

// ResetActivityID resets all changes to the "activity_id" field.
func (m *CouponMutation) ResetActivityID() {
	m.activity_id = nil
	m.addactivity_id = nil
	delete(m.clearedFields, coupon.FieldActivityID)
}

// SetRemark sets the "remark" field.
func (m *CouponMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CouponMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *CouponMutation) ResetRemark() {
	m.remark = nil
}

// SetWholeStore sets the "whole_store" field.
func (m *CouponMutation) SetWholeStore(i int) {
	m.whole_store = &i
	m.addwhole_store = nil
}

// WholeStore returns the value of the "whole_store" field in the mutation.
func (m *CouponMutation) WholeStore() (r int, exists bool) {
	v := m.whole_store
	if v == nil {
		return
	}
	return *v, true
}

// OldWholeStore returns the old "whole_store" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldWholeStore(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWholeStore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWholeStore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWholeStore: %w", err)
	}
	return oldValue.WholeStore, nil
}

// AddWholeStore adds i to the "whole_store" field.
func (m *CouponMutation) AddWholeStore(i int) {
	if m.addwhole_store != nil {
		*m.addwhole_store += i
	} else {
		m.addwhole_store = &i
	}
}

// AddedWholeStore returns the value that was added to the "whole_store" field in this mutation.
func (m *CouponMutation) AddedWholeStore() (r int, exists bool) {
	v := m.addwhole_store
	if v == nil {
		return
	}
	return *v, true
}

// ResetWholeStore resets all changes to the "whole_store" field.
func (m *CouponMutation) ResetWholeStore() {
	m.whole_store = nil
	m.addwhole_store = nil
}

// AddCategoryIDs adds the "category" edge to the Category entity by ids.
func (m *CouponMutation) AddCategoryIDs(ids ...int64) {
	if m.category == nil {
		m.category = make(map[int64]struct{})
	}
	for i := range ids {
		m.category[ids[i]] = struct{}{}
	}
}

// ClearCategory clears the "category" edge to the Category entity.
func (m *CouponMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Category entity was cleared.
func (m *CouponMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// RemoveCategoryIDs removes the "category" edge to the Category entity by IDs.
func (m *CouponMutation) RemoveCategoryIDs(ids ...int64) {
	if m.removedcategory == nil {
		m.removedcategory = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.category, ids[i])
		m.removedcategory[ids[i]] = struct{}{}
	}
}

// RemovedCategory returns the removed IDs of the "category" edge to the Category entity.
func (m *CouponMutation) RemovedCategoryIDs() (ids []int64) {
	for id := range m.removedcategory {
		ids = append(ids, id)
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
func (m *CouponMutation) CategoryIDs() (ids []int64) {
	for id := range m.category {
		ids = append(ids, id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *CouponMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
	m.removedcategory = nil
}

// AddActivityIDs adds the "activity" edge to the Activity entity by ids.
func (m *CouponMutation) AddActivityIDs(ids ...int64) {
	if m.activity == nil {
		m.activity = make(map[int64]struct{})
	}
	for i := range ids {
		m.activity[ids[i]] = struct{}{}
	}
}

// ClearActivity clears the "activity" edge to the Activity entity.
func (m *CouponMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the Activity entity was cleared.
func (m *CouponMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// RemoveActivityIDs removes the "activity" edge to the Activity entity by IDs.
func (m *CouponMutation) RemoveActivityIDs(ids ...int64) {
	if m.removedactivity == nil {
		m.removedactivity = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.activity, ids[i])
		m.removedactivity[ids[i]] = struct{}{}
	}
}

// RemovedActivity returns the removed IDs of the "activity" edge to the Activity entity.
func (m *CouponMutation) RemovedActivityIDs() (ids []int64) {
	for id := range m.removedactivity {
		ids = append(ids, id)
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
func (m *CouponMutation) ActivityIDs() (ids []int64) {
	for id := range m.activity {
		ids = append(ids, id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *CouponMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
	m.removedactivity = nil
}

// Where appends a list predicates to the CouponMutation builder.
func (m *CouponMutation) Where(ps ...predicate.Coupon) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Coupon).
func (m *CouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.create_time != nil {
		fields = append(fields, coupon.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, coupon.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, coupon.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, coupon.FieldTitle)
	}
	if m.start_time != nil {
		fields = append(fields, coupon.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, coupon.FieldEndTime)
	}
	if m.description != nil {
		fields = append(fields, coupon.FieldDescription)
	}
	if m.full_money != nil {
		fields = append(fields, coupon.FieldFullMoney)
	}
	if m.minus != nil {
		fields = append(fields, coupon.FieldMinus)
	}
	if m.rate != nil {
		fields = append(fields, coupon.FieldRate)
	}
	if m._type != nil {
		fields = append(fields, coupon.FieldType)
	}
	if m.valitiy != nil {
		fields = append(fields, coupon.FieldValitiy)
	}
	if m.activity_id != nil {
		fields = append(fields, coupon.FieldActivityID)
	}
	if m.remark != nil {
		fields = append(fields, coupon.FieldRemark)
	}
	if m.whole_store != nil {
		fields = append(fields, coupon.FieldWholeStore)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldCreateTime:
		return m.CreateTime()
	case coupon.FieldUpdateTime:
		return m.UpdateTime()
	case coupon.FieldDeleteTime:
		return m.DeleteTime()
	case coupon.FieldTitle:
		return m.Title()
	case coupon.FieldStartTime:
		return m.StartTime()
	case coupon.FieldEndTime:
		return m.EndTime()
	case coupon.FieldDescription:
		return m.Description()
	case coupon.FieldFullMoney:
		return m.FullMoney()
	case coupon.FieldMinus:
		return m.Minus()
	case coupon.FieldRate:
		return m.Rate()
	case coupon.FieldType:
		return m.GetType()
	case coupon.FieldValitiy:
		return m.Valitiy()
	case coupon.FieldActivityID:
		return m.ActivityID()
	case coupon.FieldRemark:
		return m.Remark()
	case coupon.FieldWholeStore:
		return m.WholeStore()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupon.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case coupon.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case coupon.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case coupon.FieldTitle:
		return m.OldTitle(ctx)
	case coupon.FieldStartTime:
		return m.OldStartTime(ctx)
	case coupon.FieldEndTime:
		return m.OldEndTime(ctx)
	case coupon.FieldDescription:
		return m.OldDescription(ctx)
	case coupon.FieldFullMoney:
		return m.OldFullMoney(ctx)
	case coupon.FieldMinus:
		return m.OldMinus(ctx)
	case coupon.FieldRate:
		return m.OldRate(ctx)
	case coupon.FieldType:
		return m.OldType(ctx)
	case coupon.FieldValitiy:
		return m.OldValitiy(ctx)
	case coupon.FieldActivityID:
		return m.OldActivityID(ctx)
	case coupon.FieldRemark:
		return m.OldRemark(ctx)
	case coupon.FieldWholeStore:
		return m.OldWholeStore(ctx)
	}
	return nil, fmt.Errorf("unknown Coupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case coupon.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case coupon.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case coupon.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case coupon.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case coupon.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case coupon.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case coupon.FieldFullMoney:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullMoney(v)
		return nil
	case coupon.FieldMinus:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinus(v)
		return nil
	case coupon.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case coupon.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case coupon.FieldValitiy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValitiy(v)
		return nil
	case coupon.FieldActivityID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityID(v)
		return nil
	case coupon.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case coupon.FieldWholeStore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWholeStore(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponMutation) AddedFields() []string {
	var fields []string
	if m.addfull_money != nil {
		fields = append(fields, coupon.FieldFullMoney)
	}
	if m.addminus != nil {
		fields = append(fields, coupon.FieldMinus)
	}
	if m.addrate != nil {
		fields = append(fields, coupon.FieldRate)
	}
	if m.add_type != nil {
		fields = append(fields, coupon.FieldType)
	}
	if m.addvalitiy != nil {
		fields = append(fields, coupon.FieldValitiy)
	}
	if m.addactivity_id != nil {
		fields = append(fields, coupon.FieldActivityID)
	}
	if m.addwhole_store != nil {
		fields = append(fields, coupon.FieldWholeStore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldFullMoney:
		return m.AddedFullMoney()
	case coupon.FieldMinus:
		return m.AddedMinus()
	case coupon.FieldRate:
		return m.AddedRate()
	case coupon.FieldType:
		return m.AddedType()
	case coupon.FieldValitiy:
		return m.AddedValitiy()
	case coupon.FieldActivityID:
		return m.AddedActivityID()
	case coupon.FieldWholeStore:
		return m.AddedWholeStore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldFullMoney:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFullMoney(v)
		return nil
	case coupon.FieldMinus:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinus(v)
		return nil
	case coupon.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRate(v)
		return nil
	case coupon.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case coupon.FieldValitiy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValitiy(v)
		return nil
	case coupon.FieldActivityID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActivityID(v)
		return nil
	case coupon.FieldWholeStore:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWholeStore(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupon.FieldDeleteTime) {
		fields = append(fields, coupon.FieldDeleteTime)
	}
	if m.FieldCleared(coupon.FieldActivityID) {
		fields = append(fields, coupon.FieldActivityID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponMutation) ClearField(name string) error {
	switch name {
	case coupon.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case coupon.FieldActivityID:
		m.ClearActivityID()
		return nil
	}
	return fmt.Errorf("unknown Coupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponMutation) ResetField(name string) error {
	switch name {
	case coupon.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case coupon.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case coupon.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case coupon.FieldTitle:
		m.ResetTitle()
		return nil
	case coupon.FieldStartTime:
		m.ResetStartTime()
		return nil
	case coupon.FieldEndTime:
		m.ResetEndTime()
		return nil
	case coupon.FieldDescription:
		m.ResetDescription()
		return nil
	case coupon.FieldFullMoney:
		m.ResetFullMoney()
		return nil
	case coupon.FieldMinus:
		m.ResetMinus()
		return nil
	case coupon.FieldRate:
		m.ResetRate()
		return nil
	case coupon.FieldType:
		m.ResetType()
		return nil
	case coupon.FieldValitiy:
		m.ResetValitiy()
		return nil
	case coupon.FieldActivityID:
		m.ResetActivityID()
		return nil
	case coupon.FieldRemark:
		m.ResetRemark()
		return nil
	case coupon.FieldWholeStore:
		m.ResetWholeStore()
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.category != nil {
		edges = append(edges, coupon.EdgeCategory)
	}
	if m.activity != nil {
		edges = append(edges, coupon.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coupon.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.category))
		for id := range m.category {
			ids = append(ids, id)
		}
		return ids
	case coupon.EdgeActivity:
		ids := make([]ent.Value, 0, len(m.activity))
		for id := range m.activity {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcategory != nil {
		edges = append(edges, coupon.EdgeCategory)
	}
	if m.removedactivity != nil {
		edges = append(edges, coupon.EdgeActivity)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case coupon.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.removedcategory))
		for id := range m.removedcategory {
			ids = append(ids, id)
		}
		return ids
	case coupon.EdgeActivity:
		ids := make([]ent.Value, 0, len(m.removedactivity))
		for id := range m.removedactivity {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcategory {
		edges = append(edges, coupon.EdgeCategory)
	}
	if m.clearedactivity {
		edges = append(edges, coupon.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponMutation) EdgeCleared(name string) bool {
	switch name {
	case coupon.EdgeCategory:
		return m.clearedcategory
	case coupon.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Coupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponMutation) ResetEdge(name string) error {
	switch name {
	case coupon.EdgeCategory:
		m.ResetCategory()
		return nil
	case coupon.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown Coupon edge %s", name)
}

// CouponTemplateMutation represents an operation that mutates the CouponTemplate nodes in the graph.
type CouponTemplateMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	title         *string
	description   *string
	full_money    *float64
	addfull_money *float64
	minus         *float64
	addminus      *float64
	discount      *float64
	adddiscount   *float64
	_type         *int
	add_type      *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CouponTemplate, error)
	predicates    []predicate.CouponTemplate
}

var _ ent.Mutation = (*CouponTemplateMutation)(nil)

// coupontemplateOption allows management of the mutation configuration using functional options.
type coupontemplateOption func(*CouponTemplateMutation)

// newCouponTemplateMutation creates new mutation for the CouponTemplate entity.
func newCouponTemplateMutation(c config, op Op, opts ...coupontemplateOption) *CouponTemplateMutation {
	m := &CouponTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponTemplateID sets the ID field of the mutation.
func withCouponTemplateID(id int64) coupontemplateOption {
	return func(m *CouponTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponTemplate
		)
		m.oldValue = func(ctx context.Context) (*CouponTemplate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponTemplate sets the old CouponTemplate of the mutation.
func withCouponTemplate(node *CouponTemplate) coupontemplateOption {
	return func(m *CouponTemplateMutation) {
		m.oldValue = func(context.Context) (*CouponTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponTemplateMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *CouponTemplateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CouponTemplateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CouponTemplateMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CouponTemplateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CouponTemplateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CouponTemplateMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *CouponTemplateMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CouponTemplateMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CouponTemplateMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[coupontemplate.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CouponTemplateMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[coupontemplate.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CouponTemplateMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, coupontemplate.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *CouponTemplateMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *CouponTemplateMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *CouponTemplateMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *CouponTemplateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CouponTemplateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CouponTemplateMutation) ResetDescription() {
	m.description = nil
}

// SetFullMoney sets the "full_money" field.
func (m *CouponTemplateMutation) SetFullMoney(f float64) {
	m.full_money = &f
	m.addfull_money = nil
}

// FullMoney returns the value of the "full_money" field in the mutation.
func (m *CouponTemplateMutation) FullMoney() (r float64, exists bool) {
	v := m.full_money
	if v == nil {
		return
	}
	return *v, true
}

// OldFullMoney returns the old "full_money" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldFullMoney(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFullMoney is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFullMoney requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullMoney: %w", err)
	}
	return oldValue.FullMoney, nil
}

// AddFullMoney adds f to the "full_money" field.
func (m *CouponTemplateMutation) AddFullMoney(f float64) {
	if m.addfull_money != nil {
		*m.addfull_money += f
	} else {
		m.addfull_money = &f
	}
}

// AddedFullMoney returns the value that was added to the "full_money" field in this mutation.
func (m *CouponTemplateMutation) AddedFullMoney() (r float64, exists bool) {
	v := m.addfull_money
	if v == nil {
		return
	}
	return *v, true
}

// ResetFullMoney resets all changes to the "full_money" field.
func (m *CouponTemplateMutation) ResetFullMoney() {
	m.full_money = nil
	m.addfull_money = nil
}

// SetMinus sets the "minus" field.
func (m *CouponTemplateMutation) SetMinus(f float64) {
	m.minus = &f
	m.addminus = nil
}

// Minus returns the value of the "minus" field in the mutation.
func (m *CouponTemplateMutation) Minus() (r float64, exists bool) {
	v := m.minus
	if v == nil {
		return
	}
	return *v, true
}

// OldMinus returns the old "minus" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldMinus(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMinus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMinus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinus: %w", err)
	}
	return oldValue.Minus, nil
}

// AddMinus adds f to the "minus" field.
func (m *CouponTemplateMutation) AddMinus(f float64) {
	if m.addminus != nil {
		*m.addminus += f
	} else {
		m.addminus = &f
	}
}

// AddedMinus returns the value that was added to the "minus" field in this mutation.
func (m *CouponTemplateMutation) AddedMinus() (r float64, exists bool) {
	v := m.addminus
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinus resets all changes to the "minus" field.
func (m *CouponTemplateMutation) ResetMinus() {
	m.minus = nil
	m.addminus = nil
}

// SetDiscount sets the "discount" field.
func (m *CouponTemplateMutation) SetDiscount(f float64) {
	m.discount = &f
	m.adddiscount = nil
}

// Discount returns the value of the "discount" field in the mutation.
func (m *CouponTemplateMutation) Discount() (r float64, exists bool) {
	v := m.discount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscount returns the old "discount" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldDiscount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscount: %w", err)
	}
	return oldValue.Discount, nil
}

// AddDiscount adds f to the "discount" field.
func (m *CouponTemplateMutation) AddDiscount(f float64) {
	if m.adddiscount != nil {
		*m.adddiscount += f
	} else {
		m.adddiscount = &f
	}
}

// AddedDiscount returns the value that was added to the "discount" field in this mutation.
func (m *CouponTemplateMutation) AddedDiscount() (r float64, exists bool) {
	v := m.adddiscount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscount resets all changes to the "discount" field.
func (m *CouponTemplateMutation) ResetDiscount() {
	m.discount = nil
	m.adddiscount = nil
}

// SetType sets the "type" field.
func (m *CouponTemplateMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *CouponTemplateMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *CouponTemplateMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *CouponTemplateMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *CouponTemplateMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// Where appends a list predicates to the CouponTemplateMutation builder.
func (m *CouponTemplateMutation) Where(ps ...predicate.CouponTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponTemplateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CouponTemplate).
func (m *CouponTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponTemplateMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.create_time != nil {
		fields = append(fields, coupontemplate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, coupontemplate.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, coupontemplate.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, coupontemplate.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, coupontemplate.FieldDescription)
	}
	if m.full_money != nil {
		fields = append(fields, coupontemplate.FieldFullMoney)
	}
	if m.minus != nil {
		fields = append(fields, coupontemplate.FieldMinus)
	}
	if m.discount != nil {
		fields = append(fields, coupontemplate.FieldDiscount)
	}
	if m._type != nil {
		fields = append(fields, coupontemplate.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupontemplate.FieldCreateTime:
		return m.CreateTime()
	case coupontemplate.FieldUpdateTime:
		return m.UpdateTime()
	case coupontemplate.FieldDeleteTime:
		return m.DeleteTime()
	case coupontemplate.FieldTitle:
		return m.Title()
	case coupontemplate.FieldDescription:
		return m.Description()
	case coupontemplate.FieldFullMoney:
		return m.FullMoney()
	case coupontemplate.FieldMinus:
		return m.Minus()
	case coupontemplate.FieldDiscount:
		return m.Discount()
	case coupontemplate.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupontemplate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case coupontemplate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case coupontemplate.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case coupontemplate.FieldTitle:
		return m.OldTitle(ctx)
	case coupontemplate.FieldDescription:
		return m.OldDescription(ctx)
	case coupontemplate.FieldFullMoney:
		return m.OldFullMoney(ctx)
	case coupontemplate.FieldMinus:
		return m.OldMinus(ctx)
	case coupontemplate.FieldDiscount:
		return m.OldDiscount(ctx)
	case coupontemplate.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown CouponTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupontemplate.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case coupontemplate.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case coupontemplate.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case coupontemplate.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case coupontemplate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case coupontemplate.FieldFullMoney:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullMoney(v)
		return nil
	case coupontemplate.FieldMinus:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinus(v)
		return nil
	case coupontemplate.FieldDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscount(v)
		return nil
	case coupontemplate.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponTemplateMutation) AddedFields() []string {
	var fields []string
	if m.addfull_money != nil {
		fields = append(fields, coupontemplate.FieldFullMoney)
	}
	if m.addminus != nil {
		fields = append(fields, coupontemplate.FieldMinus)
	}
	if m.adddiscount != nil {
		fields = append(fields, coupontemplate.FieldDiscount)
	}
	if m.add_type != nil {
		fields = append(fields, coupontemplate.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponTemplateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupontemplate.FieldFullMoney:
		return m.AddedFullMoney()
	case coupontemplate.FieldMinus:
		return m.AddedMinus()
	case coupontemplate.FieldDiscount:
		return m.AddedDiscount()
	case coupontemplate.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupontemplate.FieldFullMoney:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFullMoney(v)
		return nil
	case coupontemplate.FieldMinus:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinus(v)
		return nil
	case coupontemplate.FieldDiscount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscount(v)
		return nil
	case coupontemplate.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupontemplate.FieldDeleteTime) {
		fields = append(fields, coupontemplate.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponTemplateMutation) ClearField(name string) error {
	switch name {
	case coupontemplate.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponTemplateMutation) ResetField(name string) error {
	switch name {
	case coupontemplate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case coupontemplate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case coupontemplate.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case coupontemplate.FieldTitle:
		m.ResetTitle()
		return nil
	case coupontemplate.FieldDescription:
		m.ResetDescription()
		return nil
	case coupontemplate.FieldFullMoney:
		m.ResetFullMoney()
		return nil
	case coupontemplate.FieldMinus:
		m.ResetMinus()
		return nil
	case coupontemplate.FieldDiscount:
		m.ResetDiscount()
		return nil
	case coupontemplate.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponTemplateMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponTemplateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponTemplateMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponTemplateMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponTemplateMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponTemplate edge %s", name)
}

// CouponTypeMutation represents an operation that mutates the CouponType nodes in the graph.
type CouponTypeMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	name          *string
	code          *int
	addcode       *int
	description   *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*CouponType, error)
	predicates    []predicate.CouponType
}

var _ ent.Mutation = (*CouponTypeMutation)(nil)

// coupontypeOption allows management of the mutation configuration using functional options.
type coupontypeOption func(*CouponTypeMutation)

// newCouponTypeMutation creates new mutation for the CouponType entity.
func newCouponTypeMutation(c config, op Op, opts ...coupontypeOption) *CouponTypeMutation {
	m := &CouponTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponTypeID sets the ID field of the mutation.
func withCouponTypeID(id int64) coupontypeOption {
	return func(m *CouponTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponType
		)
		m.oldValue = func(ctx context.Context) (*CouponType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponType sets the old CouponType of the mutation.
func withCouponType(node *CouponType) coupontypeOption {
	return func(m *CouponTypeMutation) {
		m.oldValue = func(context.Context) (*CouponType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *CouponTypeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CouponTypeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CouponTypeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CouponTypeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CouponTypeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CouponTypeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *CouponTypeMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *CouponTypeMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *CouponTypeMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[coupontype.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *CouponTypeMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[coupontype.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *CouponTypeMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, coupontype.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *CouponTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CouponTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CouponTypeMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *CouponTypeMutation) SetCode(i int) {
	m.code = &i
	m.addcode = nil
}

// Code returns the value of the "code" field in the mutation.
func (m *CouponTypeMutation) Code() (r int, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldCode(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// AddCode adds i to the "code" field.
func (m *CouponTypeMutation) AddCode(i int) {
	if m.addcode != nil {
		*m.addcode += i
	} else {
		m.addcode = &i
	}
}

// AddedCode returns the value that was added to the "code" field in this mutation.
func (m *CouponTypeMutation) AddedCode() (r int, exists bool) {
	v := m.addcode
	if v == nil {
		return
	}
	return *v, true
}

// ResetCode resets all changes to the "code" field.
func (m *CouponTypeMutation) ResetCode() {
	m.code = nil
	m.addcode = nil
}

// SetDescription sets the "description" field.
func (m *CouponTypeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CouponTypeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CouponType entity.
// If the CouponType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTypeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CouponTypeMutation) ResetDescription() {
	m.description = nil
}

// Where appends a list predicates to the CouponTypeMutation builder.
func (m *CouponTypeMutation) Where(ps ...predicate.CouponType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CouponTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CouponType).
func (m *CouponTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponTypeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, coupontype.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, coupontype.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, coupontype.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, coupontype.FieldName)
	}
	if m.code != nil {
		fields = append(fields, coupontype.FieldCode)
	}
	if m.description != nil {
		fields = append(fields, coupontype.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupontype.FieldCreateTime:
		return m.CreateTime()
	case coupontype.FieldUpdateTime:
		return m.UpdateTime()
	case coupontype.FieldDeleteTime:
		return m.DeleteTime()
	case coupontype.FieldName:
		return m.Name()
	case coupontype.FieldCode:
		return m.Code()
	case coupontype.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupontype.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case coupontype.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case coupontype.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case coupontype.FieldName:
		return m.OldName(ctx)
	case coupontype.FieldCode:
		return m.OldCode(ctx)
	case coupontype.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CouponType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupontype.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case coupontype.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case coupontype.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case coupontype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coupontype.FieldCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case coupontype.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CouponType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponTypeMutation) AddedFields() []string {
	var fields []string
	if m.addcode != nil {
		fields = append(fields, coupontype.FieldCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupontype.FieldCode:
		return m.AddedCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupontype.FieldCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCode(v)
		return nil
	}
	return fmt.Errorf("unknown CouponType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupontype.FieldDeleteTime) {
		fields = append(fields, coupontype.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponTypeMutation) ClearField(name string) error {
	switch name {
	case coupontype.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown CouponType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponTypeMutation) ResetField(name string) error {
	switch name {
	case coupontype.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case coupontype.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case coupontype.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case coupontype.FieldName:
		m.ResetName()
		return nil
	case coupontype.FieldCode:
		m.ResetCode()
		return nil
	case coupontype.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CouponType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponTypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponTypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponTypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponTypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CouponType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponTypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CouponType edge %s", name)
}

// GridCategoryMutation represents an operation that mutates the GridCategory nodes in the graph.
type GridCategoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	create_time         *time.Time
	update_time         *time.Time
	delete_time         *time.Time
	title               *string
	img                 *string
	name                *string
	category_id         *int
	addcategory_id      *int
	root_category_id    *int
	addroot_category_id *int
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*GridCategory, error)
	predicates          []predicate.GridCategory
}

var _ ent.Mutation = (*GridCategoryMutation)(nil)

// gridcategoryOption allows management of the mutation configuration using functional options.
type gridcategoryOption func(*GridCategoryMutation)

// newGridCategoryMutation creates new mutation for the GridCategory entity.
func newGridCategoryMutation(c config, op Op, opts ...gridcategoryOption) *GridCategoryMutation {
	m := &GridCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeGridCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGridCategoryID sets the ID field of the mutation.
func withGridCategoryID(id int64) gridcategoryOption {
	return func(m *GridCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *GridCategory
		)
		m.oldValue = func(ctx context.Context) (*GridCategory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GridCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGridCategory sets the old GridCategory of the mutation.
func withGridCategory(node *GridCategory) gridcategoryOption {
	return func(m *GridCategoryMutation) {
		m.oldValue = func(context.Context) (*GridCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GridCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GridCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GridCategoryMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *GridCategoryMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *GridCategoryMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *GridCategoryMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *GridCategoryMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *GridCategoryMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *GridCategoryMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *GridCategoryMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *GridCategoryMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *GridCategoryMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[gridcategory.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *GridCategoryMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[gridcategory.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *GridCategoryMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, gridcategory.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *GridCategoryMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *GridCategoryMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *GridCategoryMutation) ResetTitle() {
	m.title = nil
}

// SetImg sets the "img" field.
func (m *GridCategoryMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *GridCategoryMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *GridCategoryMutation) ResetImg() {
	m.img = nil
}

// SetName sets the "name" field.
func (m *GridCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GridCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GridCategoryMutation) ResetName() {
	m.name = nil
}

// SetCategoryID sets the "category_id" field.
func (m *GridCategoryMutation) SetCategoryID(i int) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *GridCategoryMutation) CategoryID() (r int, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *GridCategoryMutation) AddCategoryID(i int) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *GridCategoryMutation) AddedCategoryID() (r int, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *GridCategoryMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// SetRootCategoryID sets the "root_category_id" field.
func (m *GridCategoryMutation) SetRootCategoryID(i int) {
	m.root_category_id = &i
	m.addroot_category_id = nil
}

// RootCategoryID returns the value of the "root_category_id" field in the mutation.
func (m *GridCategoryMutation) RootCategoryID() (r int, exists bool) {
	v := m.root_category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootCategoryID returns the old "root_category_id" field's value of the GridCategory entity.
// If the GridCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GridCategoryMutation) OldRootCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRootCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRootCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootCategoryID: %w", err)
	}
	return oldValue.RootCategoryID, nil
}

// AddRootCategoryID adds i to the "root_category_id" field.
func (m *GridCategoryMutation) AddRootCategoryID(i int) {
	if m.addroot_category_id != nil {
		*m.addroot_category_id += i
	} else {
		m.addroot_category_id = &i
	}
}

// AddedRootCategoryID returns the value that was added to the "root_category_id" field in this mutation.
func (m *GridCategoryMutation) AddedRootCategoryID() (r int, exists bool) {
	v := m.addroot_category_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRootCategoryID resets all changes to the "root_category_id" field.
func (m *GridCategoryMutation) ResetRootCategoryID() {
	m.root_category_id = nil
	m.addroot_category_id = nil
}

// Where appends a list predicates to the GridCategoryMutation builder.
func (m *GridCategoryMutation) Where(ps ...predicate.GridCategory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *GridCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (GridCategory).
func (m *GridCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GridCategoryMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, gridcategory.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, gridcategory.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, gridcategory.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, gridcategory.FieldTitle)
	}
	if m.img != nil {
		fields = append(fields, gridcategory.FieldImg)
	}
	if m.name != nil {
		fields = append(fields, gridcategory.FieldName)
	}
	if m.category_id != nil {
		fields = append(fields, gridcategory.FieldCategoryID)
	}
	if m.root_category_id != nil {
		fields = append(fields, gridcategory.FieldRootCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GridCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gridcategory.FieldCreateTime:
		return m.CreateTime()
	case gridcategory.FieldUpdateTime:
		return m.UpdateTime()
	case gridcategory.FieldDeleteTime:
		return m.DeleteTime()
	case gridcategory.FieldTitle:
		return m.Title()
	case gridcategory.FieldImg:
		return m.Img()
	case gridcategory.FieldName:
		return m.Name()
	case gridcategory.FieldCategoryID:
		return m.CategoryID()
	case gridcategory.FieldRootCategoryID:
		return m.RootCategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GridCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gridcategory.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case gridcategory.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case gridcategory.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case gridcategory.FieldTitle:
		return m.OldTitle(ctx)
	case gridcategory.FieldImg:
		return m.OldImg(ctx)
	case gridcategory.FieldName:
		return m.OldName(ctx)
	case gridcategory.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case gridcategory.FieldRootCategoryID:
		return m.OldRootCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown GridCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GridCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gridcategory.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case gridcategory.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case gridcategory.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case gridcategory.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case gridcategory.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case gridcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case gridcategory.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case gridcategory.FieldRootCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown GridCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GridCategoryMutation) AddedFields() []string {
	var fields []string
	if m.addcategory_id != nil {
		fields = append(fields, gridcategory.FieldCategoryID)
	}
	if m.addroot_category_id != nil {
		fields = append(fields, gridcategory.FieldRootCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GridCategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gridcategory.FieldCategoryID:
		return m.AddedCategoryID()
	case gridcategory.FieldRootCategoryID:
		return m.AddedRootCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GridCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gridcategory.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	case gridcategory.FieldRootCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRootCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown GridCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GridCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(gridcategory.FieldDeleteTime) {
		fields = append(fields, gridcategory.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GridCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GridCategoryMutation) ClearField(name string) error {
	switch name {
	case gridcategory.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown GridCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GridCategoryMutation) ResetField(name string) error {
	switch name {
	case gridcategory.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case gridcategory.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case gridcategory.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case gridcategory.FieldTitle:
		m.ResetTitle()
		return nil
	case gridcategory.FieldImg:
		m.ResetImg()
		return nil
	case gridcategory.FieldName:
		m.ResetName()
		return nil
	case gridcategory.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case gridcategory.FieldRootCategoryID:
		m.ResetRootCategoryID()
		return nil
	}
	return fmt.Errorf("unknown GridCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GridCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GridCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GridCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GridCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GridCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GridCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GridCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GridCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GridCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GridCategory edge %s", name)
}

// RefundMutation represents an operation that mutates the Refund nodes in the graph.
type RefundMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	create_time     *time.Time
	update_time     *time.Time
	delete_time     *time.Time
	refund_no       *string
	transaction_id  *string
	user_id         *int64
	adduser_id      *int64
	reason          *string
	order_id        *int64
	addorder_id     *int64
	order_sub_id    *int64
	addorder_sub_id *int64
	status          *int
	addstatus       *int
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Refund, error)
	predicates      []predicate.Refund
}

var _ ent.Mutation = (*RefundMutation)(nil)

// refundOption allows management of the mutation configuration using functional options.
type refundOption func(*RefundMutation)

// newRefundMutation creates new mutation for the Refund entity.
func newRefundMutation(c config, op Op, opts ...refundOption) *RefundMutation {
	m := &RefundMutation{
		config:        c,
		op:            op,
		typ:           TypeRefund,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRefundID sets the ID field of the mutation.
func withRefundID(id int64) refundOption {
	return func(m *RefundMutation) {
		var (
			err   error
			once  sync.Once
			value *Refund
		)
		m.oldValue = func(ctx context.Context) (*Refund, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Refund.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRefund sets the old Refund of the mutation.
func withRefund(node *Refund) refundOption {
	return func(m *RefundMutation) {
		m.oldValue = func(context.Context) (*Refund, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RefundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RefundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RefundMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *RefundMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *RefundMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *RefundMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *RefundMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *RefundMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *RefundMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *RefundMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *RefundMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *RefundMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[refund.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *RefundMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[refund.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *RefundMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, refund.FieldDeleteTime)
}

// SetRefundNo sets the "refund_no" field.
func (m *RefundMutation) SetRefundNo(s string) {
	m.refund_no = &s
}

// RefundNo returns the value of the "refund_no" field in the mutation.
func (m *RefundMutation) RefundNo() (r string, exists bool) {
	v := m.refund_no
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundNo returns the old "refund_no" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldRefundNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRefundNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRefundNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundNo: %w", err)
	}
	return oldValue.RefundNo, nil
}

// ResetRefundNo resets all changes to the "refund_no" field.
func (m *RefundMutation) ResetRefundNo() {
	m.refund_no = nil
}

// SetTransactionID sets the "transaction_id" field.
func (m *RefundMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *RefundMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldTransactionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *RefundMutation) ResetTransactionID() {
	m.transaction_id = nil
}

// SetUserID sets the "user_id" field.
func (m *RefundMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RefundMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *RefundMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *RefundMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearUserID clears the value of the "user_id" field.
func (m *RefundMutation) ClearUserID() {
	m.user_id = nil
	m.adduser_id = nil
	m.clearedFields[refund.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *RefundMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[refund.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RefundMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
	delete(m.clearedFields, refund.FieldUserID)
}

// SetReason sets the "reason" field.
func (m *RefundMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *RefundMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *RefundMutation) ResetReason() {
	m.reason = nil
}

// SetOrderID sets the "order_id" field.
func (m *RefundMutation) SetOrderID(i int64) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *RefundMutation) OrderID() (r int64, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *RefundMutation) AddOrderID(i int64) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *RefundMutation) AddedOrderID() (r int64, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderID clears the value of the "order_id" field.
func (m *RefundMutation) ClearOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	m.clearedFields[refund.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *RefundMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[refund.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *RefundMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
	delete(m.clearedFields, refund.FieldOrderID)
}

// SetOrderSubID sets the "order_sub_id" field.
func (m *RefundMutation) SetOrderSubID(i int64) {
	m.order_sub_id = &i
	m.addorder_sub_id = nil
}

// OrderSubID returns the value of the "order_sub_id" field in the mutation.
func (m *RefundMutation) OrderSubID() (r int64, exists bool) {
	v := m.order_sub_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSubID returns the old "order_sub_id" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldOrderSubID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrderSubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrderSubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSubID: %w", err)
	}
	return oldValue.OrderSubID, nil
}

// AddOrderSubID adds i to the "order_sub_id" field.
func (m *RefundMutation) AddOrderSubID(i int64) {
	if m.addorder_sub_id != nil {
		*m.addorder_sub_id += i
	} else {
		m.addorder_sub_id = &i
	}
}

// AddedOrderSubID returns the value that was added to the "order_sub_id" field in this mutation.
func (m *RefundMutation) AddedOrderSubID() (r int64, exists bool) {
	v := m.addorder_sub_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrderSubID clears the value of the "order_sub_id" field.
func (m *RefundMutation) ClearOrderSubID() {
	m.order_sub_id = nil
	m.addorder_sub_id = nil
	m.clearedFields[refund.FieldOrderSubID] = struct{}{}
}

// OrderSubIDCleared returns if the "order_sub_id" field was cleared in this mutation.
func (m *RefundMutation) OrderSubIDCleared() bool {
	_, ok := m.clearedFields[refund.FieldOrderSubID]
	return ok
}

// ResetOrderSubID resets all changes to the "order_sub_id" field.
func (m *RefundMutation) ResetOrderSubID() {
	m.order_sub_id = nil
	m.addorder_sub_id = nil
	delete(m.clearedFields, refund.FieldOrderSubID)
}

// SetStatus sets the "status" field.
func (m *RefundMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *RefundMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Refund entity.
// If the Refund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefundMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *RefundMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *RefundMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *RefundMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the RefundMutation builder.
func (m *RefundMutation) Where(ps ...predicate.Refund) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RefundMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Refund).
func (m *RefundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RefundMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, refund.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, refund.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, refund.FieldDeleteTime)
	}
	if m.refund_no != nil {
		fields = append(fields, refund.FieldRefundNo)
	}
	if m.transaction_id != nil {
		fields = append(fields, refund.FieldTransactionID)
	}
	if m.user_id != nil {
		fields = append(fields, refund.FieldUserID)
	}
	if m.reason != nil {
		fields = append(fields, refund.FieldReason)
	}
	if m.order_id != nil {
		fields = append(fields, refund.FieldOrderID)
	}
	if m.order_sub_id != nil {
		fields = append(fields, refund.FieldOrderSubID)
	}
	if m.status != nil {
		fields = append(fields, refund.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RefundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case refund.FieldCreateTime:
		return m.CreateTime()
	case refund.FieldUpdateTime:
		return m.UpdateTime()
	case refund.FieldDeleteTime:
		return m.DeleteTime()
	case refund.FieldRefundNo:
		return m.RefundNo()
	case refund.FieldTransactionID:
		return m.TransactionID()
	case refund.FieldUserID:
		return m.UserID()
	case refund.FieldReason:
		return m.Reason()
	case refund.FieldOrderID:
		return m.OrderID()
	case refund.FieldOrderSubID:
		return m.OrderSubID()
	case refund.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RefundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case refund.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case refund.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case refund.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case refund.FieldRefundNo:
		return m.OldRefundNo(ctx)
	case refund.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case refund.FieldUserID:
		return m.OldUserID(ctx)
	case refund.FieldReason:
		return m.OldReason(ctx)
	case refund.FieldOrderID:
		return m.OldOrderID(ctx)
	case refund.FieldOrderSubID:
		return m.OldOrderSubID(ctx)
	case refund.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Refund field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case refund.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case refund.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case refund.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case refund.FieldRefundNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundNo(v)
		return nil
	case refund.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case refund.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case refund.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case refund.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case refund.FieldOrderSubID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSubID(v)
		return nil
	case refund.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Refund field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RefundMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, refund.FieldUserID)
	}
	if m.addorder_id != nil {
		fields = append(fields, refund.FieldOrderID)
	}
	if m.addorder_sub_id != nil {
		fields = append(fields, refund.FieldOrderSubID)
	}
	if m.addstatus != nil {
		fields = append(fields, refund.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RefundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case refund.FieldUserID:
		return m.AddedUserID()
	case refund.FieldOrderID:
		return m.AddedOrderID()
	case refund.FieldOrderSubID:
		return m.AddedOrderSubID()
	case refund.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case refund.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case refund.FieldOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case refund.FieldOrderSubID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderSubID(v)
		return nil
	case refund.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Refund numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RefundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(refund.FieldDeleteTime) {
		fields = append(fields, refund.FieldDeleteTime)
	}
	if m.FieldCleared(refund.FieldUserID) {
		fields = append(fields, refund.FieldUserID)
	}
	if m.FieldCleared(refund.FieldOrderID) {
		fields = append(fields, refund.FieldOrderID)
	}
	if m.FieldCleared(refund.FieldOrderSubID) {
		fields = append(fields, refund.FieldOrderSubID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RefundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RefundMutation) ClearField(name string) error {
	switch name {
	case refund.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case refund.FieldUserID:
		m.ClearUserID()
		return nil
	case refund.FieldOrderID:
		m.ClearOrderID()
		return nil
	case refund.FieldOrderSubID:
		m.ClearOrderSubID()
		return nil
	}
	return fmt.Errorf("unknown Refund nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RefundMutation) ResetField(name string) error {
	switch name {
	case refund.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case refund.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case refund.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case refund.FieldRefundNo:
		m.ResetRefundNo()
		return nil
	case refund.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case refund.FieldUserID:
		m.ResetUserID()
		return nil
	case refund.FieldReason:
		m.ResetReason()
		return nil
	case refund.FieldOrderID:
		m.ResetOrderID()
		return nil
	case refund.FieldOrderSubID:
		m.ResetOrderSubID()
		return nil
	case refund.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Refund field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RefundMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RefundMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RefundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RefundMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RefundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RefundMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RefundMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Refund unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RefundMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Refund edge %s", name)
}

// ThemeMutation represents an operation that mutates the Theme nodes in the graph.
type ThemeMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	create_time      *time.Time
	update_time      *time.Time
	delete_time      *time.Time
	title            *string
	description      *string
	name             *string
	tpl_name         *string
	entrance_img     *string
	extend           *string
	internal_top_img *string
	title_img        *string
	online           *int
	addonline        *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Theme, error)
	predicates       []predicate.Theme
}

var _ ent.Mutation = (*ThemeMutation)(nil)

// themeOption allows management of the mutation configuration using functional options.
type themeOption func(*ThemeMutation)

// newThemeMutation creates new mutation for the Theme entity.
func newThemeMutation(c config, op Op, opts ...themeOption) *ThemeMutation {
	m := &ThemeMutation{
		config:        c,
		op:            op,
		typ:           TypeTheme,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withThemeID sets the ID field of the mutation.
func withThemeID(id int64) themeOption {
	return func(m *ThemeMutation) {
		var (
			err   error
			once  sync.Once
			value *Theme
		)
		m.oldValue = func(ctx context.Context) (*Theme, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Theme.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTheme sets the old Theme of the mutation.
func withTheme(node *Theme) themeOption {
	return func(m *ThemeMutation) {
		m.oldValue = func(context.Context) (*Theme, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ThemeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ThemeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ThemeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *ThemeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ThemeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ThemeMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *ThemeMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *ThemeMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *ThemeMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *ThemeMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *ThemeMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *ThemeMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[theme.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *ThemeMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[theme.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *ThemeMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, theme.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *ThemeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ThemeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ThemeMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ThemeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ThemeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ThemeMutation) ResetDescription() {
	m.description = nil
}

// SetName sets the "name" field.
func (m *ThemeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ThemeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ThemeMutation) ResetName() {
	m.name = nil
}

// SetTplName sets the "tpl_name" field.
func (m *ThemeMutation) SetTplName(s string) {
	m.tpl_name = &s
}

// TplName returns the value of the "tpl_name" field in the mutation.
func (m *ThemeMutation) TplName() (r string, exists bool) {
	v := m.tpl_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTplName returns the old "tpl_name" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldTplName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTplName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTplName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTplName: %w", err)
	}
	return oldValue.TplName, nil
}

// ResetTplName resets all changes to the "tpl_name" field.
func (m *ThemeMutation) ResetTplName() {
	m.tpl_name = nil
}

// SetEntranceImg sets the "entrance_img" field.
func (m *ThemeMutation) SetEntranceImg(s string) {
	m.entrance_img = &s
}

// EntranceImg returns the value of the "entrance_img" field in the mutation.
func (m *ThemeMutation) EntranceImg() (r string, exists bool) {
	v := m.entrance_img
	if v == nil {
		return
	}
	return *v, true
}

// OldEntranceImg returns the old "entrance_img" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldEntranceImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEntranceImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEntranceImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEntranceImg: %w", err)
	}
	return oldValue.EntranceImg, nil
}

// ResetEntranceImg resets all changes to the "entrance_img" field.
func (m *ThemeMutation) ResetEntranceImg() {
	m.entrance_img = nil
}

// SetExtend sets the "extend" field.
func (m *ThemeMutation) SetExtend(s string) {
	m.extend = &s
}

// Extend returns the value of the "extend" field in the mutation.
func (m *ThemeMutation) Extend() (r string, exists bool) {
	v := m.extend
	if v == nil {
		return
	}
	return *v, true
}

// OldExtend returns the old "extend" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldExtend(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExtend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExtend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtend: %w", err)
	}
	return oldValue.Extend, nil
}

// ResetExtend resets all changes to the "extend" field.
func (m *ThemeMutation) ResetExtend() {
	m.extend = nil
}

// SetInternalTopImg sets the "internal_top_img" field.
func (m *ThemeMutation) SetInternalTopImg(s string) {
	m.internal_top_img = &s
}

// InternalTopImg returns the value of the "internal_top_img" field in the mutation.
func (m *ThemeMutation) InternalTopImg() (r string, exists bool) {
	v := m.internal_top_img
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalTopImg returns the old "internal_top_img" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldInternalTopImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInternalTopImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInternalTopImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalTopImg: %w", err)
	}
	return oldValue.InternalTopImg, nil
}

// ResetInternalTopImg resets all changes to the "internal_top_img" field.
func (m *ThemeMutation) ResetInternalTopImg() {
	m.internal_top_img = nil
}

// SetTitleImg sets the "title_img" field.
func (m *ThemeMutation) SetTitleImg(s string) {
	m.title_img = &s
}

// TitleImg returns the value of the "title_img" field in the mutation.
func (m *ThemeMutation) TitleImg() (r string, exists bool) {
	v := m.title_img
	if v == nil {
		return
	}
	return *v, true
}

// OldTitleImg returns the old "title_img" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldTitleImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitleImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitleImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitleImg: %w", err)
	}
	return oldValue.TitleImg, nil
}

// ResetTitleImg resets all changes to the "title_img" field.
func (m *ThemeMutation) ResetTitleImg() {
	m.title_img = nil
}

// SetOnline sets the "online" field.
func (m *ThemeMutation) SetOnline(i int) {
	m.online = &i
	m.addonline = nil
}

// Online returns the value of the "online" field in the mutation.
func (m *ThemeMutation) Online() (r int, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Theme entity.
// If the Theme object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ThemeMutation) OldOnline(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// AddOnline adds i to the "online" field.
func (m *ThemeMutation) AddOnline(i int) {
	if m.addonline != nil {
		*m.addonline += i
	} else {
		m.addonline = &i
	}
}

// AddedOnline returns the value that was added to the "online" field in this mutation.
func (m *ThemeMutation) AddedOnline() (r int, exists bool) {
	v := m.addonline
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnline resets all changes to the "online" field.
func (m *ThemeMutation) ResetOnline() {
	m.online = nil
	m.addonline = nil
}

// Where appends a list predicates to the ThemeMutation builder.
func (m *ThemeMutation) Where(ps ...predicate.Theme) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ThemeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Theme).
func (m *ThemeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ThemeMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.create_time != nil {
		fields = append(fields, theme.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, theme.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, theme.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, theme.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, theme.FieldDescription)
	}
	if m.name != nil {
		fields = append(fields, theme.FieldName)
	}
	if m.tpl_name != nil {
		fields = append(fields, theme.FieldTplName)
	}
	if m.entrance_img != nil {
		fields = append(fields, theme.FieldEntranceImg)
	}
	if m.extend != nil {
		fields = append(fields, theme.FieldExtend)
	}
	if m.internal_top_img != nil {
		fields = append(fields, theme.FieldInternalTopImg)
	}
	if m.title_img != nil {
		fields = append(fields, theme.FieldTitleImg)
	}
	if m.online != nil {
		fields = append(fields, theme.FieldOnline)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ThemeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case theme.FieldCreateTime:
		return m.CreateTime()
	case theme.FieldUpdateTime:
		return m.UpdateTime()
	case theme.FieldDeleteTime:
		return m.DeleteTime()
	case theme.FieldTitle:
		return m.Title()
	case theme.FieldDescription:
		return m.Description()
	case theme.FieldName:
		return m.Name()
	case theme.FieldTplName:
		return m.TplName()
	case theme.FieldEntranceImg:
		return m.EntranceImg()
	case theme.FieldExtend:
		return m.Extend()
	case theme.FieldInternalTopImg:
		return m.InternalTopImg()
	case theme.FieldTitleImg:
		return m.TitleImg()
	case theme.FieldOnline:
		return m.Online()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ThemeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case theme.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case theme.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case theme.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case theme.FieldTitle:
		return m.OldTitle(ctx)
	case theme.FieldDescription:
		return m.OldDescription(ctx)
	case theme.FieldName:
		return m.OldName(ctx)
	case theme.FieldTplName:
		return m.OldTplName(ctx)
	case theme.FieldEntranceImg:
		return m.OldEntranceImg(ctx)
	case theme.FieldExtend:
		return m.OldExtend(ctx)
	case theme.FieldInternalTopImg:
		return m.OldInternalTopImg(ctx)
	case theme.FieldTitleImg:
		return m.OldTitleImg(ctx)
	case theme.FieldOnline:
		return m.OldOnline(ctx)
	}
	return nil, fmt.Errorf("unknown Theme field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThemeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case theme.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case theme.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case theme.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case theme.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case theme.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case theme.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case theme.FieldTplName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTplName(v)
		return nil
	case theme.FieldEntranceImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEntranceImg(v)
		return nil
	case theme.FieldExtend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtend(v)
		return nil
	case theme.FieldInternalTopImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalTopImg(v)
		return nil
	case theme.FieldTitleImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitleImg(v)
		return nil
	case theme.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	}
	return fmt.Errorf("unknown Theme field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ThemeMutation) AddedFields() []string {
	var fields []string
	if m.addonline != nil {
		fields = append(fields, theme.FieldOnline)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ThemeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case theme.FieldOnline:
		return m.AddedOnline()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ThemeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case theme.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnline(v)
		return nil
	}
	return fmt.Errorf("unknown Theme numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ThemeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(theme.FieldDeleteTime) {
		fields = append(fields, theme.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ThemeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ThemeMutation) ClearField(name string) error {
	switch name {
	case theme.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Theme nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ThemeMutation) ResetField(name string) error {
	switch name {
	case theme.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case theme.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case theme.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case theme.FieldTitle:
		m.ResetTitle()
		return nil
	case theme.FieldDescription:
		m.ResetDescription()
		return nil
	case theme.FieldName:
		m.ResetName()
		return nil
	case theme.FieldTplName:
		m.ResetTplName()
		return nil
	case theme.FieldEntranceImg:
		m.ResetEntranceImg()
		return nil
	case theme.FieldExtend:
		m.ResetExtend()
		return nil
	case theme.FieldInternalTopImg:
		m.ResetInternalTopImg()
		return nil
	case theme.FieldTitleImg:
		m.ResetTitleImg()
		return nil
	case theme.FieldOnline:
		m.ResetOnline()
		return nil
	}
	return fmt.Errorf("unknown Theme field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ThemeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ThemeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ThemeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ThemeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ThemeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ThemeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ThemeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Theme unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ThemeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Theme edge %s", name)
}
