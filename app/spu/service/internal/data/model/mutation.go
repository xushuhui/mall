// Code generated by entc, DO NOT EDIT.

package model

import (
	"context"
	"fmt"
	"mall-go/app/spu/service/internal/data/ent/schema"
	"mall-go/app/spu/service/internal/data/model/brand"
	"mall-go/app/spu/service/internal/data/model/predicate"
	"mall-go/app/spu/service/internal/data/model/saleexplain"
	"mall-go/app/spu/service/internal/data/model/sku"
	"mall-go/app/spu/service/internal/data/model/skuspec"
	"mall-go/app/spu/service/internal/data/model/speckey"
	"mall-go/app/spu/service/internal/data/model/specvalue"
	"mall-go/app/spu/service/internal/data/model/spu"
	"mall-go/app/spu/service/internal/data/model/spudetailimg"
	"mall-go/app/spu/service/internal/data/model/spuimg"
	"mall-go/app/spu/service/internal/data/model/tag"
	"mall-go/app/spu/service/internal/data/model/userfavor"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBrand        = "Brand"
	TypeSaleExplain  = "SaleExplain"
	TypeSku          = "Sku"
	TypeSkuSpec      = "SkuSpec"
	TypeSpecKey      = "SpecKey"
	TypeSpecValue    = "SpecValue"
	TypeSpu          = "Spu"
	TypeSpuDetailImg = "SpuDetailImg"
	TypeSpuImg       = "SpuImg"
	TypeTag          = "Tag"
	TypeUserFavor    = "UserFavor"
)

// BrandMutation represents an operation that mutates the Brand nodes in the graph.
type BrandMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	name          *string
	description   *string
	clearedFields map[string]struct{}
	spu           map[int64]struct{}
	removedspu    map[int64]struct{}
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*Brand, error)
	predicates    []predicate.Brand
}

var _ ent.Mutation = (*BrandMutation)(nil)

// brandOption allows management of the mutation configuration using functional options.
type brandOption func(*BrandMutation)

// newBrandMutation creates new mutation for the Brand entity.
func newBrandMutation(c config, op Op, opts ...brandOption) *BrandMutation {
	m := &BrandMutation{
		config:        c,
		op:            op,
		typ:           TypeBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBrandID sets the ID field of the mutation.
func withBrandID(id int64) brandOption {
	return func(m *BrandMutation) {
		var (
			err   error
			once  sync.Once
			value *Brand
		)
		m.oldValue = func(ctx context.Context) (*Brand, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Brand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBrand sets the old Brand of the mutation.
func withBrand(node *Brand) brandOption {
	return func(m *BrandMutation) {
		m.oldValue = func(context.Context) (*Brand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BrandMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *BrandMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BrandMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BrandMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *BrandMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *BrandMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *BrandMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *BrandMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *BrandMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *BrandMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[brand.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *BrandMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[brand.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *BrandMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, brand.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *BrandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BrandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BrandMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *BrandMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *BrandMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Brand entity.
// If the Brand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BrandMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *BrandMutation) ResetDescription() {
	m.description = nil
}

// AddSpuIDs adds the "spu" edge to the Spu entity by ids.
func (m *BrandMutation) AddSpuIDs(ids ...int64) {
	if m.spu == nil {
		m.spu = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu[ids[i]] = struct{}{}
	}
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *BrandMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *BrandMutation) SpuCleared() bool {
	return m.clearedspu
}

// RemoveSpuIDs removes the "spu" edge to the Spu entity by IDs.
func (m *BrandMutation) RemoveSpuIDs(ids ...int64) {
	if m.removedspu == nil {
		m.removedspu = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu, ids[i])
		m.removedspu[ids[i]] = struct{}{}
	}
}

// RemovedSpu returns the removed IDs of the "spu" edge to the Spu entity.
func (m *BrandMutation) RemovedSpuIDs() (ids []int64) {
	for id := range m.removedspu {
		ids = append(ids, id)
	}
	return
}

// SpuIDs returns the "spu" edge IDs in the mutation.
func (m *BrandMutation) SpuIDs() (ids []int64) {
	for id := range m.spu {
		ids = append(ids, id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *BrandMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
	m.removedspu = nil
}

// Where appends a list predicates to the BrandMutation builder.
func (m *BrandMutation) Where(ps ...predicate.Brand) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BrandMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Brand).
func (m *BrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BrandMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, brand.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, brand.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, brand.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, brand.FieldName)
	}
	if m.description != nil {
		fields = append(fields, brand.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case brand.FieldCreateTime:
		return m.CreateTime()
	case brand.FieldUpdateTime:
		return m.UpdateTime()
	case brand.FieldDeleteTime:
		return m.DeleteTime()
	case brand.FieldName:
		return m.Name()
	case brand.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case brand.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case brand.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case brand.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case brand.FieldName:
		return m.OldName(ctx)
	case brand.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Brand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case brand.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case brand.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case brand.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case brand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case brand.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BrandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BrandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BrandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(brand.FieldDeleteTime) {
		fields = append(fields, brand.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BrandMutation) ClearField(name string) error {
	switch name {
	case brand.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Brand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BrandMutation) ResetField(name string) error {
	switch name {
	case brand.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case brand.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case brand.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case brand.FieldName:
		m.ResetName()
		return nil
	case brand.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Brand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, brand.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BrandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.spu))
		for id := range m.spu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedspu != nil {
		edges = append(edges, brand.EdgeSpu)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BrandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case brand.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.removedspu))
		for id := range m.removedspu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, brand.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BrandMutation) EdgeCleared(name string) bool {
	switch name {
	case brand.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BrandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Brand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BrandMutation) ResetEdge(name string) error {
	switch name {
	case brand.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown Brand edge %s", name)
}

// SaleExplainMutation represents an operation that mutates the SaleExplain nodes in the graph.
type SaleExplainMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	fixed         *int
	addfixed      *int
	text          *string
	index         *int
	addindex      *int
	replace_id    *int64
	addreplace_id *int64
	clearedFields map[string]struct{}
	spu           *int64
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*SaleExplain, error)
	predicates    []predicate.SaleExplain
}

var _ ent.Mutation = (*SaleExplainMutation)(nil)

// saleexplainOption allows management of the mutation configuration using functional options.
type saleexplainOption func(*SaleExplainMutation)

// newSaleExplainMutation creates new mutation for the SaleExplain entity.
func newSaleExplainMutation(c config, op Op, opts ...saleexplainOption) *SaleExplainMutation {
	m := &SaleExplainMutation{
		config:        c,
		op:            op,
		typ:           TypeSaleExplain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSaleExplainID sets the ID field of the mutation.
func withSaleExplainID(id int64) saleexplainOption {
	return func(m *SaleExplainMutation) {
		var (
			err   error
			once  sync.Once
			value *SaleExplain
		)
		m.oldValue = func(ctx context.Context) (*SaleExplain, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SaleExplain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSaleExplain sets the old SaleExplain of the mutation.
func withSaleExplain(node *SaleExplain) saleexplainOption {
	return func(m *SaleExplainMutation) {
		m.oldValue = func(context.Context) (*SaleExplain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SaleExplainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SaleExplainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SaleExplainMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SaleExplainMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SaleExplainMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SaleExplainMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SaleExplainMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SaleExplainMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SaleExplainMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SaleExplainMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SaleExplainMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SaleExplainMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[saleexplain.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SaleExplainMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[saleexplain.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SaleExplainMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, saleexplain.FieldDeleteTime)
}

// SetFixed sets the "fixed" field.
func (m *SaleExplainMutation) SetFixed(i int) {
	m.fixed = &i
	m.addfixed = nil
}

// Fixed returns the value of the "fixed" field in the mutation.
func (m *SaleExplainMutation) Fixed() (r int, exists bool) {
	v := m.fixed
	if v == nil {
		return
	}
	return *v, true
}

// OldFixed returns the old "fixed" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldFixed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFixed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFixed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFixed: %w", err)
	}
	return oldValue.Fixed, nil
}

// AddFixed adds i to the "fixed" field.
func (m *SaleExplainMutation) AddFixed(i int) {
	if m.addfixed != nil {
		*m.addfixed += i
	} else {
		m.addfixed = &i
	}
}

// AddedFixed returns the value that was added to the "fixed" field in this mutation.
func (m *SaleExplainMutation) AddedFixed() (r int, exists bool) {
	v := m.addfixed
	if v == nil {
		return
	}
	return *v, true
}

// ResetFixed resets all changes to the "fixed" field.
func (m *SaleExplainMutation) ResetFixed() {
	m.fixed = nil
	m.addfixed = nil
}

// SetText sets the "text" field.
func (m *SaleExplainMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *SaleExplainMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *SaleExplainMutation) ResetText() {
	m.text = nil
}

// SetSpuID sets the "spu_id" field.
func (m *SaleExplainMutation) SetSpuID(i int64) {
	m.spu = &i
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *SaleExplainMutation) SpuID() (r int64, exists bool) {
	v := m.spu
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// ClearSpuID clears the value of the "spu_id" field.
func (m *SaleExplainMutation) ClearSpuID() {
	m.spu = nil
	m.clearedFields[saleexplain.FieldSpuID] = struct{}{}
}

// SpuIDCleared returns if the "spu_id" field was cleared in this mutation.
func (m *SaleExplainMutation) SpuIDCleared() bool {
	_, ok := m.clearedFields[saleexplain.FieldSpuID]
	return ok
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *SaleExplainMutation) ResetSpuID() {
	m.spu = nil
	delete(m.clearedFields, saleexplain.FieldSpuID)
}

// SetIndex sets the "index" field.
func (m *SaleExplainMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *SaleExplainMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *SaleExplainMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *SaleExplainMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *SaleExplainMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// SetReplaceID sets the "replace_id" field.
func (m *SaleExplainMutation) SetReplaceID(i int64) {
	m.replace_id = &i
	m.addreplace_id = nil
}

// ReplaceID returns the value of the "replace_id" field in the mutation.
func (m *SaleExplainMutation) ReplaceID() (r int64, exists bool) {
	v := m.replace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReplaceID returns the old "replace_id" field's value of the SaleExplain entity.
// If the SaleExplain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SaleExplainMutation) OldReplaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReplaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReplaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReplaceID: %w", err)
	}
	return oldValue.ReplaceID, nil
}

// AddReplaceID adds i to the "replace_id" field.
func (m *SaleExplainMutation) AddReplaceID(i int64) {
	if m.addreplace_id != nil {
		*m.addreplace_id += i
	} else {
		m.addreplace_id = &i
	}
}

// AddedReplaceID returns the value that was added to the "replace_id" field in this mutation.
func (m *SaleExplainMutation) AddedReplaceID() (r int64, exists bool) {
	v := m.addreplace_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetReplaceID resets all changes to the "replace_id" field.
func (m *SaleExplainMutation) ResetReplaceID() {
	m.replace_id = nil
	m.addreplace_id = nil
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *SaleExplainMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *SaleExplainMutation) SpuCleared() bool {
	return m.SpuIDCleared() || m.clearedspu
}

// SpuIDs returns the "spu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpuID instead. It exists only for internal usage by the builders.
func (m *SaleExplainMutation) SpuIDs() (ids []int64) {
	if id := m.spu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *SaleExplainMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
}

// Where appends a list predicates to the SaleExplainMutation builder.
func (m *SaleExplainMutation) Where(ps ...predicate.SaleExplain) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SaleExplainMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SaleExplain).
func (m *SaleExplainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SaleExplainMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.create_time != nil {
		fields = append(fields, saleexplain.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, saleexplain.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, saleexplain.FieldDeleteTime)
	}
	if m.fixed != nil {
		fields = append(fields, saleexplain.FieldFixed)
	}
	if m.text != nil {
		fields = append(fields, saleexplain.FieldText)
	}
	if m.spu != nil {
		fields = append(fields, saleexplain.FieldSpuID)
	}
	if m.index != nil {
		fields = append(fields, saleexplain.FieldIndex)
	}
	if m.replace_id != nil {
		fields = append(fields, saleexplain.FieldReplaceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SaleExplainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case saleexplain.FieldCreateTime:
		return m.CreateTime()
	case saleexplain.FieldUpdateTime:
		return m.UpdateTime()
	case saleexplain.FieldDeleteTime:
		return m.DeleteTime()
	case saleexplain.FieldFixed:
		return m.Fixed()
	case saleexplain.FieldText:
		return m.Text()
	case saleexplain.FieldSpuID:
		return m.SpuID()
	case saleexplain.FieldIndex:
		return m.Index()
	case saleexplain.FieldReplaceID:
		return m.ReplaceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SaleExplainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case saleexplain.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case saleexplain.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case saleexplain.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case saleexplain.FieldFixed:
		return m.OldFixed(ctx)
	case saleexplain.FieldText:
		return m.OldText(ctx)
	case saleexplain.FieldSpuID:
		return m.OldSpuID(ctx)
	case saleexplain.FieldIndex:
		return m.OldIndex(ctx)
	case saleexplain.FieldReplaceID:
		return m.OldReplaceID(ctx)
	}
	return nil, fmt.Errorf("unknown SaleExplain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaleExplainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case saleexplain.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case saleexplain.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case saleexplain.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case saleexplain.FieldFixed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFixed(v)
		return nil
	case saleexplain.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case saleexplain.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case saleexplain.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	case saleexplain.FieldReplaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReplaceID(v)
		return nil
	}
	return fmt.Errorf("unknown SaleExplain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SaleExplainMutation) AddedFields() []string {
	var fields []string
	if m.addfixed != nil {
		fields = append(fields, saleexplain.FieldFixed)
	}
	if m.addindex != nil {
		fields = append(fields, saleexplain.FieldIndex)
	}
	if m.addreplace_id != nil {
		fields = append(fields, saleexplain.FieldReplaceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SaleExplainMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case saleexplain.FieldFixed:
		return m.AddedFixed()
	case saleexplain.FieldIndex:
		return m.AddedIndex()
	case saleexplain.FieldReplaceID:
		return m.AddedReplaceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SaleExplainMutation) AddField(name string, value ent.Value) error {
	switch name {
	case saleexplain.FieldFixed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFixed(v)
		return nil
	case saleexplain.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	case saleexplain.FieldReplaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReplaceID(v)
		return nil
	}
	return fmt.Errorf("unknown SaleExplain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SaleExplainMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(saleexplain.FieldDeleteTime) {
		fields = append(fields, saleexplain.FieldDeleteTime)
	}
	if m.FieldCleared(saleexplain.FieldSpuID) {
		fields = append(fields, saleexplain.FieldSpuID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SaleExplainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SaleExplainMutation) ClearField(name string) error {
	switch name {
	case saleexplain.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case saleexplain.FieldSpuID:
		m.ClearSpuID()
		return nil
	}
	return fmt.Errorf("unknown SaleExplain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SaleExplainMutation) ResetField(name string) error {
	switch name {
	case saleexplain.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case saleexplain.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case saleexplain.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case saleexplain.FieldFixed:
		m.ResetFixed()
		return nil
	case saleexplain.FieldText:
		m.ResetText()
		return nil
	case saleexplain.FieldSpuID:
		m.ResetSpuID()
		return nil
	case saleexplain.FieldIndex:
		m.ResetIndex()
		return nil
	case saleexplain.FieldReplaceID:
		m.ResetReplaceID()
		return nil
	}
	return fmt.Errorf("unknown SaleExplain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SaleExplainMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, saleexplain.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SaleExplainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case saleexplain.EdgeSpu:
		if id := m.spu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SaleExplainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SaleExplainMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SaleExplainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, saleexplain.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SaleExplainMutation) EdgeCleared(name string) bool {
	switch name {
	case saleexplain.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SaleExplainMutation) ClearEdge(name string) error {
	switch name {
	case saleexplain.EdgeSpu:
		m.ClearSpu()
		return nil
	}
	return fmt.Errorf("unknown SaleExplain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SaleExplainMutation) ResetEdge(name string) error {
	switch name {
	case saleexplain.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown SaleExplain edge %s", name)
}

// SkuMutation represents an operation that mutates the Sku nodes in the graph.
type SkuMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	create_time         *time.Time
	update_time         *time.Time
	delete_time         *time.Time
	price               *float64
	addprice            *float64
	discount_price      *float64
	adddiscount_price   *float64
	online              *int
	addonline           *int
	img                 *string
	title               *string
	spu_id              *int64
	addspu_id           *int64
	specs               *[]schema.Spec
	code                *string
	stock               *int
	addstock            *int
	category_id         *int64
	addcategory_id      *int64
	root_category_id    *int64
	addroot_category_id *int64
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*Sku, error)
	predicates          []predicate.Sku
}

var _ ent.Mutation = (*SkuMutation)(nil)

// skuOption allows management of the mutation configuration using functional options.
type skuOption func(*SkuMutation)

// newSkuMutation creates new mutation for the Sku entity.
func newSkuMutation(c config, op Op, opts ...skuOption) *SkuMutation {
	m := &SkuMutation{
		config:        c,
		op:            op,
		typ:           TypeSku,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkuID sets the ID field of the mutation.
func withSkuID(id int64) skuOption {
	return func(m *SkuMutation) {
		var (
			err   error
			once  sync.Once
			value *Sku
		)
		m.oldValue = func(ctx context.Context) (*Sku, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sku.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSku sets the old Sku of the mutation.
func withSku(node *Sku) skuOption {
	return func(m *SkuMutation) {
		m.oldValue = func(context.Context) (*Sku, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SkuMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SkuMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SkuMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SkuMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SkuMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SkuMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SkuMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SkuMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SkuMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[sku.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SkuMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[sku.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SkuMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, sku.FieldDeleteTime)
}

// SetPrice sets the "price" field.
func (m *SkuMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *SkuMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *SkuMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *SkuMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *SkuMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDiscountPrice sets the "discount_price" field.
func (m *SkuMutation) SetDiscountPrice(f float64) {
	m.discount_price = &f
	m.adddiscount_price = nil
}

// DiscountPrice returns the value of the "discount_price" field in the mutation.
func (m *SkuMutation) DiscountPrice() (r float64, exists bool) {
	v := m.discount_price
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountPrice returns the old "discount_price" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldDiscountPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscountPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscountPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountPrice: %w", err)
	}
	return oldValue.DiscountPrice, nil
}

// AddDiscountPrice adds f to the "discount_price" field.
func (m *SkuMutation) AddDiscountPrice(f float64) {
	if m.adddiscount_price != nil {
		*m.adddiscount_price += f
	} else {
		m.adddiscount_price = &f
	}
}

// AddedDiscountPrice returns the value that was added to the "discount_price" field in this mutation.
func (m *SkuMutation) AddedDiscountPrice() (r float64, exists bool) {
	v := m.adddiscount_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountPrice resets all changes to the "discount_price" field.
func (m *SkuMutation) ResetDiscountPrice() {
	m.discount_price = nil
	m.adddiscount_price = nil
}

// SetOnline sets the "online" field.
func (m *SkuMutation) SetOnline(i int) {
	m.online = &i
	m.addonline = nil
}

// Online returns the value of the "online" field in the mutation.
func (m *SkuMutation) Online() (r int, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldOnline(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// AddOnline adds i to the "online" field.
func (m *SkuMutation) AddOnline(i int) {
	if m.addonline != nil {
		*m.addonline += i
	} else {
		m.addonline = &i
	}
}

// AddedOnline returns the value that was added to the "online" field in this mutation.
func (m *SkuMutation) AddedOnline() (r int, exists bool) {
	v := m.addonline
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnline resets all changes to the "online" field.
func (m *SkuMutation) ResetOnline() {
	m.online = nil
	m.addonline = nil
}

// SetImg sets the "img" field.
func (m *SkuMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *SkuMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *SkuMutation) ResetImg() {
	m.img = nil
}

// SetTitle sets the "title" field.
func (m *SkuMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SkuMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SkuMutation) ResetTitle() {
	m.title = nil
}

// SetSpuID sets the "spu_id" field.
func (m *SkuMutation) SetSpuID(i int64) {
	m.spu_id = &i
	m.addspu_id = nil
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *SkuMutation) SpuID() (r int64, exists bool) {
	v := m.spu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// AddSpuID adds i to the "spu_id" field.
func (m *SkuMutation) AddSpuID(i int64) {
	if m.addspu_id != nil {
		*m.addspu_id += i
	} else {
		m.addspu_id = &i
	}
}

// AddedSpuID returns the value that was added to the "spu_id" field in this mutation.
func (m *SkuMutation) AddedSpuID() (r int64, exists bool) {
	v := m.addspu_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSpuID clears the value of the "spu_id" field.
func (m *SkuMutation) ClearSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
	m.clearedFields[sku.FieldSpuID] = struct{}{}
}

// SpuIDCleared returns if the "spu_id" field was cleared in this mutation.
func (m *SkuMutation) SpuIDCleared() bool {
	_, ok := m.clearedFields[sku.FieldSpuID]
	return ok
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *SkuMutation) ResetSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
	delete(m.clearedFields, sku.FieldSpuID)
}

// SetSpecs sets the "specs" field.
func (m *SkuMutation) SetSpecs(s []schema.Spec) {
	m.specs = &s
}

// Specs returns the value of the "specs" field in the mutation.
func (m *SkuMutation) Specs() (r []schema.Spec, exists bool) {
	v := m.specs
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecs returns the old "specs" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldSpecs(ctx context.Context) (v []schema.Spec, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecs: %w", err)
	}
	return oldValue.Specs, nil
}

// ResetSpecs resets all changes to the "specs" field.
func (m *SkuMutation) ResetSpecs() {
	m.specs = nil
}

// SetCode sets the "code" field.
func (m *SkuMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *SkuMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *SkuMutation) ResetCode() {
	m.code = nil
}

// SetStock sets the "stock" field.
func (m *SkuMutation) SetStock(i int) {
	m.stock = &i
	m.addstock = nil
}

// Stock returns the value of the "stock" field in the mutation.
func (m *SkuMutation) Stock() (r int, exists bool) {
	v := m.stock
	if v == nil {
		return
	}
	return *v, true
}

// OldStock returns the old "stock" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStock: %w", err)
	}
	return oldValue.Stock, nil
}

// AddStock adds i to the "stock" field.
func (m *SkuMutation) AddStock(i int) {
	if m.addstock != nil {
		*m.addstock += i
	} else {
		m.addstock = &i
	}
}

// AddedStock returns the value that was added to the "stock" field in this mutation.
func (m *SkuMutation) AddedStock() (r int, exists bool) {
	v := m.addstock
	if v == nil {
		return
	}
	return *v, true
}

// ResetStock resets all changes to the "stock" field.
func (m *SkuMutation) ResetStock() {
	m.stock = nil
	m.addstock = nil
}

// SetCategoryID sets the "category_id" field.
func (m *SkuMutation) SetCategoryID(i int64) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *SkuMutation) CategoryID() (r int64, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldCategoryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *SkuMutation) AddCategoryID(i int64) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *SkuMutation) AddedCategoryID() (r int64, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *SkuMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// SetRootCategoryID sets the "root_category_id" field.
func (m *SkuMutation) SetRootCategoryID(i int64) {
	m.root_category_id = &i
	m.addroot_category_id = nil
}

// RootCategoryID returns the value of the "root_category_id" field in the mutation.
func (m *SkuMutation) RootCategoryID() (r int64, exists bool) {
	v := m.root_category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootCategoryID returns the old "root_category_id" field's value of the Sku entity.
// If the Sku object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuMutation) OldRootCategoryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRootCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRootCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootCategoryID: %w", err)
	}
	return oldValue.RootCategoryID, nil
}

// AddRootCategoryID adds i to the "root_category_id" field.
func (m *SkuMutation) AddRootCategoryID(i int64) {
	if m.addroot_category_id != nil {
		*m.addroot_category_id += i
	} else {
		m.addroot_category_id = &i
	}
}

// AddedRootCategoryID returns the value that was added to the "root_category_id" field in this mutation.
func (m *SkuMutation) AddedRootCategoryID() (r int64, exists bool) {
	v := m.addroot_category_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRootCategoryID resets all changes to the "root_category_id" field.
func (m *SkuMutation) ResetRootCategoryID() {
	m.root_category_id = nil
	m.addroot_category_id = nil
}

// Where appends a list predicates to the SkuMutation builder.
func (m *SkuMutation) Where(ps ...predicate.Sku) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SkuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Sku).
func (m *SkuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkuMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.create_time != nil {
		fields = append(fields, sku.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, sku.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, sku.FieldDeleteTime)
	}
	if m.price != nil {
		fields = append(fields, sku.FieldPrice)
	}
	if m.discount_price != nil {
		fields = append(fields, sku.FieldDiscountPrice)
	}
	if m.online != nil {
		fields = append(fields, sku.FieldOnline)
	}
	if m.img != nil {
		fields = append(fields, sku.FieldImg)
	}
	if m.title != nil {
		fields = append(fields, sku.FieldTitle)
	}
	if m.spu_id != nil {
		fields = append(fields, sku.FieldSpuID)
	}
	if m.specs != nil {
		fields = append(fields, sku.FieldSpecs)
	}
	if m.code != nil {
		fields = append(fields, sku.FieldCode)
	}
	if m.stock != nil {
		fields = append(fields, sku.FieldStock)
	}
	if m.category_id != nil {
		fields = append(fields, sku.FieldCategoryID)
	}
	if m.root_category_id != nil {
		fields = append(fields, sku.FieldRootCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sku.FieldCreateTime:
		return m.CreateTime()
	case sku.FieldUpdateTime:
		return m.UpdateTime()
	case sku.FieldDeleteTime:
		return m.DeleteTime()
	case sku.FieldPrice:
		return m.Price()
	case sku.FieldDiscountPrice:
		return m.DiscountPrice()
	case sku.FieldOnline:
		return m.Online()
	case sku.FieldImg:
		return m.Img()
	case sku.FieldTitle:
		return m.Title()
	case sku.FieldSpuID:
		return m.SpuID()
	case sku.FieldSpecs:
		return m.Specs()
	case sku.FieldCode:
		return m.Code()
	case sku.FieldStock:
		return m.Stock()
	case sku.FieldCategoryID:
		return m.CategoryID()
	case sku.FieldRootCategoryID:
		return m.RootCategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sku.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case sku.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case sku.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case sku.FieldPrice:
		return m.OldPrice(ctx)
	case sku.FieldDiscountPrice:
		return m.OldDiscountPrice(ctx)
	case sku.FieldOnline:
		return m.OldOnline(ctx)
	case sku.FieldImg:
		return m.OldImg(ctx)
	case sku.FieldTitle:
		return m.OldTitle(ctx)
	case sku.FieldSpuID:
		return m.OldSpuID(ctx)
	case sku.FieldSpecs:
		return m.OldSpecs(ctx)
	case sku.FieldCode:
		return m.OldCode(ctx)
	case sku.FieldStock:
		return m.OldStock(ctx)
	case sku.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case sku.FieldRootCategoryID:
		return m.OldRootCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown Sku field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sku.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case sku.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case sku.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case sku.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case sku.FieldDiscountPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountPrice(v)
		return nil
	case sku.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case sku.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case sku.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case sku.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case sku.FieldSpecs:
		v, ok := value.([]schema.Spec)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecs(v)
		return nil
	case sku.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case sku.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStock(v)
		return nil
	case sku.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case sku.FieldRootCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Sku field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkuMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, sku.FieldPrice)
	}
	if m.adddiscount_price != nil {
		fields = append(fields, sku.FieldDiscountPrice)
	}
	if m.addonline != nil {
		fields = append(fields, sku.FieldOnline)
	}
	if m.addspu_id != nil {
		fields = append(fields, sku.FieldSpuID)
	}
	if m.addstock != nil {
		fields = append(fields, sku.FieldStock)
	}
	if m.addcategory_id != nil {
		fields = append(fields, sku.FieldCategoryID)
	}
	if m.addroot_category_id != nil {
		fields = append(fields, sku.FieldRootCategoryID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case sku.FieldPrice:
		return m.AddedPrice()
	case sku.FieldDiscountPrice:
		return m.AddedDiscountPrice()
	case sku.FieldOnline:
		return m.AddedOnline()
	case sku.FieldSpuID:
		return m.AddedSpuID()
	case sku.FieldStock:
		return m.AddedStock()
	case sku.FieldCategoryID:
		return m.AddedCategoryID()
	case sku.FieldRootCategoryID:
		return m.AddedRootCategoryID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case sku.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case sku.FieldDiscountPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountPrice(v)
		return nil
	case sku.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnline(v)
		return nil
	case sku.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpuID(v)
		return nil
	case sku.FieldStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStock(v)
		return nil
	case sku.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	case sku.FieldRootCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRootCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Sku numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sku.FieldDeleteTime) {
		fields = append(fields, sku.FieldDeleteTime)
	}
	if m.FieldCleared(sku.FieldSpuID) {
		fields = append(fields, sku.FieldSpuID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkuMutation) ClearField(name string) error {
	switch name {
	case sku.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case sku.FieldSpuID:
		m.ClearSpuID()
		return nil
	}
	return fmt.Errorf("unknown Sku nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkuMutation) ResetField(name string) error {
	switch name {
	case sku.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case sku.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case sku.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case sku.FieldPrice:
		m.ResetPrice()
		return nil
	case sku.FieldDiscountPrice:
		m.ResetDiscountPrice()
		return nil
	case sku.FieldOnline:
		m.ResetOnline()
		return nil
	case sku.FieldImg:
		m.ResetImg()
		return nil
	case sku.FieldTitle:
		m.ResetTitle()
		return nil
	case sku.FieldSpuID:
		m.ResetSpuID()
		return nil
	case sku.FieldSpecs:
		m.ResetSpecs()
		return nil
	case sku.FieldCode:
		m.ResetCode()
		return nil
	case sku.FieldStock:
		m.ResetStock()
		return nil
	case sku.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case sku.FieldRootCategoryID:
		m.ResetRootCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Sku field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkuMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkuMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkuMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkuMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Sku unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkuMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Sku edge %s", name)
}

// SkuSpecMutation represents an operation that mutates the SkuSpec nodes in the graph.
type SkuSpecMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	spu_id        *int64
	addspu_id     *int64
	sku_id        *int64
	addsku_id     *int64
	key_id        *int64
	addkey_id     *int64
	value_id      *int64
	addvalue_id   *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SkuSpec, error)
	predicates    []predicate.SkuSpec
}

var _ ent.Mutation = (*SkuSpecMutation)(nil)

// skuspecOption allows management of the mutation configuration using functional options.
type skuspecOption func(*SkuSpecMutation)

// newSkuSpecMutation creates new mutation for the SkuSpec entity.
func newSkuSpecMutation(c config, op Op, opts ...skuspecOption) *SkuSpecMutation {
	m := &SkuSpecMutation{
		config:        c,
		op:            op,
		typ:           TypeSkuSpec,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkuSpecID sets the ID field of the mutation.
func withSkuSpecID(id int64) skuspecOption {
	return func(m *SkuSpecMutation) {
		var (
			err   error
			once  sync.Once
			value *SkuSpec
		)
		m.oldValue = func(ctx context.Context) (*SkuSpec, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SkuSpec.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkuSpec sets the old SkuSpec of the mutation.
func withSkuSpec(node *SkuSpec) skuspecOption {
	return func(m *SkuSpecMutation) {
		m.oldValue = func(context.Context) (*SkuSpec, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkuSpecMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkuSpecMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkuSpecMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSpuID sets the "spu_id" field.
func (m *SkuSpecMutation) SetSpuID(i int64) {
	m.spu_id = &i
	m.addspu_id = nil
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *SkuSpecMutation) SpuID() (r int64, exists bool) {
	v := m.spu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the SkuSpec entity.
// If the SkuSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuSpecMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// AddSpuID adds i to the "spu_id" field.
func (m *SkuSpecMutation) AddSpuID(i int64) {
	if m.addspu_id != nil {
		*m.addspu_id += i
	} else {
		m.addspu_id = &i
	}
}

// AddedSpuID returns the value that was added to the "spu_id" field in this mutation.
func (m *SkuSpecMutation) AddedSpuID() (r int64, exists bool) {
	v := m.addspu_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *SkuSpecMutation) ResetSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
}

// SetSkuID sets the "sku_id" field.
func (m *SkuSpecMutation) SetSkuID(i int64) {
	m.sku_id = &i
	m.addsku_id = nil
}

// SkuID returns the value of the "sku_id" field in the mutation.
func (m *SkuSpecMutation) SkuID() (r int64, exists bool) {
	v := m.sku_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSkuID returns the old "sku_id" field's value of the SkuSpec entity.
// If the SkuSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuSpecMutation) OldSkuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSkuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSkuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkuID: %w", err)
	}
	return oldValue.SkuID, nil
}

// AddSkuID adds i to the "sku_id" field.
func (m *SkuSpecMutation) AddSkuID(i int64) {
	if m.addsku_id != nil {
		*m.addsku_id += i
	} else {
		m.addsku_id = &i
	}
}

// AddedSkuID returns the value that was added to the "sku_id" field in this mutation.
func (m *SkuSpecMutation) AddedSkuID() (r int64, exists bool) {
	v := m.addsku_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSkuID resets all changes to the "sku_id" field.
func (m *SkuSpecMutation) ResetSkuID() {
	m.sku_id = nil
	m.addsku_id = nil
}

// SetKeyID sets the "key_id" field.
func (m *SkuSpecMutation) SetKeyID(i int64) {
	m.key_id = &i
	m.addkey_id = nil
}

// KeyID returns the value of the "key_id" field in the mutation.
func (m *SkuSpecMutation) KeyID() (r int64, exists bool) {
	v := m.key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldKeyID returns the old "key_id" field's value of the SkuSpec entity.
// If the SkuSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuSpecMutation) OldKeyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeyID: %w", err)
	}
	return oldValue.KeyID, nil
}

// AddKeyID adds i to the "key_id" field.
func (m *SkuSpecMutation) AddKeyID(i int64) {
	if m.addkey_id != nil {
		*m.addkey_id += i
	} else {
		m.addkey_id = &i
	}
}

// AddedKeyID returns the value that was added to the "key_id" field in this mutation.
func (m *SkuSpecMutation) AddedKeyID() (r int64, exists bool) {
	v := m.addkey_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetKeyID resets all changes to the "key_id" field.
func (m *SkuSpecMutation) ResetKeyID() {
	m.key_id = nil
	m.addkey_id = nil
}

// SetValueID sets the "value_id" field.
func (m *SkuSpecMutation) SetValueID(i int64) {
	m.value_id = &i
	m.addvalue_id = nil
}

// ValueID returns the value of the "value_id" field in the mutation.
func (m *SkuSpecMutation) ValueID() (r int64, exists bool) {
	v := m.value_id
	if v == nil {
		return
	}
	return *v, true
}

// OldValueID returns the old "value_id" field's value of the SkuSpec entity.
// If the SkuSpec object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkuSpecMutation) OldValueID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValueID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValueID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValueID: %w", err)
	}
	return oldValue.ValueID, nil
}

// AddValueID adds i to the "value_id" field.
func (m *SkuSpecMutation) AddValueID(i int64) {
	if m.addvalue_id != nil {
		*m.addvalue_id += i
	} else {
		m.addvalue_id = &i
	}
}

// AddedValueID returns the value that was added to the "value_id" field in this mutation.
func (m *SkuSpecMutation) AddedValueID() (r int64, exists bool) {
	v := m.addvalue_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetValueID resets all changes to the "value_id" field.
func (m *SkuSpecMutation) ResetValueID() {
	m.value_id = nil
	m.addvalue_id = nil
}

// Where appends a list predicates to the SkuSpecMutation builder.
func (m *SkuSpecMutation) Where(ps ...predicate.SkuSpec) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SkuSpecMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SkuSpec).
func (m *SkuSpecMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkuSpecMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.spu_id != nil {
		fields = append(fields, skuspec.FieldSpuID)
	}
	if m.sku_id != nil {
		fields = append(fields, skuspec.FieldSkuID)
	}
	if m.key_id != nil {
		fields = append(fields, skuspec.FieldKeyID)
	}
	if m.value_id != nil {
		fields = append(fields, skuspec.FieldValueID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkuSpecMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skuspec.FieldSpuID:
		return m.SpuID()
	case skuspec.FieldSkuID:
		return m.SkuID()
	case skuspec.FieldKeyID:
		return m.KeyID()
	case skuspec.FieldValueID:
		return m.ValueID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkuSpecMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skuspec.FieldSpuID:
		return m.OldSpuID(ctx)
	case skuspec.FieldSkuID:
		return m.OldSkuID(ctx)
	case skuspec.FieldKeyID:
		return m.OldKeyID(ctx)
	case skuspec.FieldValueID:
		return m.OldValueID(ctx)
	}
	return nil, fmt.Errorf("unknown SkuSpec field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkuSpecMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skuspec.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case skuspec.FieldSkuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkuID(v)
		return nil
	case skuspec.FieldKeyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeyID(v)
		return nil
	case skuspec.FieldValueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValueID(v)
		return nil
	}
	return fmt.Errorf("unknown SkuSpec field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkuSpecMutation) AddedFields() []string {
	var fields []string
	if m.addspu_id != nil {
		fields = append(fields, skuspec.FieldSpuID)
	}
	if m.addsku_id != nil {
		fields = append(fields, skuspec.FieldSkuID)
	}
	if m.addkey_id != nil {
		fields = append(fields, skuspec.FieldKeyID)
	}
	if m.addvalue_id != nil {
		fields = append(fields, skuspec.FieldValueID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkuSpecMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case skuspec.FieldSpuID:
		return m.AddedSpuID()
	case skuspec.FieldSkuID:
		return m.AddedSkuID()
	case skuspec.FieldKeyID:
		return m.AddedKeyID()
	case skuspec.FieldValueID:
		return m.AddedValueID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkuSpecMutation) AddField(name string, value ent.Value) error {
	switch name {
	case skuspec.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpuID(v)
		return nil
	case skuspec.FieldSkuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSkuID(v)
		return nil
	case skuspec.FieldKeyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKeyID(v)
		return nil
	case skuspec.FieldValueID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValueID(v)
		return nil
	}
	return fmt.Errorf("unknown SkuSpec numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkuSpecMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkuSpecMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkuSpecMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SkuSpec nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkuSpecMutation) ResetField(name string) error {
	switch name {
	case skuspec.FieldSpuID:
		m.ResetSpuID()
		return nil
	case skuspec.FieldSkuID:
		m.ResetSkuID()
		return nil
	case skuspec.FieldKeyID:
		m.ResetKeyID()
		return nil
	case skuspec.FieldValueID:
		m.ResetValueID()
		return nil
	}
	return fmt.Errorf("unknown SkuSpec field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkuSpecMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkuSpecMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkuSpecMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkuSpecMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkuSpecMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkuSpecMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkuSpecMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SkuSpec unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkuSpecMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SkuSpec edge %s", name)
}

// SpecKeyMutation represents an operation that mutates the SpecKey nodes in the graph.
type SpecKeyMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	name          *string
	unit          *string
	standard      *int
	addstandard   *int
	description   *string
	clearedFields map[string]struct{}
	spu           map[int64]struct{}
	removedspu    map[int64]struct{}
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*SpecKey, error)
	predicates    []predicate.SpecKey
}

var _ ent.Mutation = (*SpecKeyMutation)(nil)

// speckeyOption allows management of the mutation configuration using functional options.
type speckeyOption func(*SpecKeyMutation)

// newSpecKeyMutation creates new mutation for the SpecKey entity.
func newSpecKeyMutation(c config, op Op, opts ...speckeyOption) *SpecKeyMutation {
	m := &SpecKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeSpecKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpecKeyID sets the ID field of the mutation.
func withSpecKeyID(id int64) speckeyOption {
	return func(m *SpecKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *SpecKey
		)
		m.oldValue = func(ctx context.Context) (*SpecKey, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpecKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpecKey sets the old SpecKey of the mutation.
func withSpecKey(node *SpecKey) speckeyOption {
	return func(m *SpecKeyMutation) {
		m.oldValue = func(context.Context) (*SpecKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpecKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpecKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpecKeyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SpecKeyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SpecKeyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SpecKeyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SpecKeyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SpecKeyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SpecKeyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SpecKeyMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SpecKeyMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SpecKeyMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[speckey.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SpecKeyMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[speckey.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SpecKeyMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, speckey.FieldDeleteTime)
}

// SetName sets the "name" field.
func (m *SpecKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SpecKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SpecKeyMutation) ResetName() {
	m.name = nil
}

// SetUnit sets the "unit" field.
func (m *SpecKeyMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *SpecKeyMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *SpecKeyMutation) ResetUnit() {
	m.unit = nil
}

// SetStandard sets the "standard" field.
func (m *SpecKeyMutation) SetStandard(i int) {
	m.standard = &i
	m.addstandard = nil
}

// Standard returns the value of the "standard" field in the mutation.
func (m *SpecKeyMutation) Standard() (r int, exists bool) {
	v := m.standard
	if v == nil {
		return
	}
	return *v, true
}

// OldStandard returns the old "standard" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldStandard(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStandard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStandard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStandard: %w", err)
	}
	return oldValue.Standard, nil
}

// AddStandard adds i to the "standard" field.
func (m *SpecKeyMutation) AddStandard(i int) {
	if m.addstandard != nil {
		*m.addstandard += i
	} else {
		m.addstandard = &i
	}
}

// AddedStandard returns the value that was added to the "standard" field in this mutation.
func (m *SpecKeyMutation) AddedStandard() (r int, exists bool) {
	v := m.addstandard
	if v == nil {
		return
	}
	return *v, true
}

// ResetStandard resets all changes to the "standard" field.
func (m *SpecKeyMutation) ResetStandard() {
	m.standard = nil
	m.addstandard = nil
}

// SetDescription sets the "description" field.
func (m *SpecKeyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SpecKeyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SpecKey entity.
// If the SpecKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecKeyMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SpecKeyMutation) ResetDescription() {
	m.description = nil
}

// AddSpuIDs adds the "spu" edge to the Spu entity by ids.
func (m *SpecKeyMutation) AddSpuIDs(ids ...int64) {
	if m.spu == nil {
		m.spu = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu[ids[i]] = struct{}{}
	}
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *SpecKeyMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *SpecKeyMutation) SpuCleared() bool {
	return m.clearedspu
}

// RemoveSpuIDs removes the "spu" edge to the Spu entity by IDs.
func (m *SpecKeyMutation) RemoveSpuIDs(ids ...int64) {
	if m.removedspu == nil {
		m.removedspu = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu, ids[i])
		m.removedspu[ids[i]] = struct{}{}
	}
}

// RemovedSpu returns the removed IDs of the "spu" edge to the Spu entity.
func (m *SpecKeyMutation) RemovedSpuIDs() (ids []int64) {
	for id := range m.removedspu {
		ids = append(ids, id)
	}
	return
}

// SpuIDs returns the "spu" edge IDs in the mutation.
func (m *SpecKeyMutation) SpuIDs() (ids []int64) {
	for id := range m.spu {
		ids = append(ids, id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *SpecKeyMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
	m.removedspu = nil
}

// Where appends a list predicates to the SpecKeyMutation builder.
func (m *SpecKeyMutation) Where(ps ...predicate.SpecKey) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SpecKeyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SpecKey).
func (m *SpecKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpecKeyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, speckey.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, speckey.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, speckey.FieldDeleteTime)
	}
	if m.name != nil {
		fields = append(fields, speckey.FieldName)
	}
	if m.unit != nil {
		fields = append(fields, speckey.FieldUnit)
	}
	if m.standard != nil {
		fields = append(fields, speckey.FieldStandard)
	}
	if m.description != nil {
		fields = append(fields, speckey.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpecKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case speckey.FieldCreateTime:
		return m.CreateTime()
	case speckey.FieldUpdateTime:
		return m.UpdateTime()
	case speckey.FieldDeleteTime:
		return m.DeleteTime()
	case speckey.FieldName:
		return m.Name()
	case speckey.FieldUnit:
		return m.Unit()
	case speckey.FieldStandard:
		return m.Standard()
	case speckey.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpecKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case speckey.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case speckey.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case speckey.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case speckey.FieldName:
		return m.OldName(ctx)
	case speckey.FieldUnit:
		return m.OldUnit(ctx)
	case speckey.FieldStandard:
		return m.OldStandard(ctx)
	case speckey.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown SpecKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpecKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case speckey.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case speckey.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case speckey.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case speckey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case speckey.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	case speckey.FieldStandard:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStandard(v)
		return nil
	case speckey.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown SpecKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpecKeyMutation) AddedFields() []string {
	var fields []string
	if m.addstandard != nil {
		fields = append(fields, speckey.FieldStandard)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpecKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case speckey.FieldStandard:
		return m.AddedStandard()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpecKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case speckey.FieldStandard:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStandard(v)
		return nil
	}
	return fmt.Errorf("unknown SpecKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpecKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(speckey.FieldDeleteTime) {
		fields = append(fields, speckey.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpecKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpecKeyMutation) ClearField(name string) error {
	switch name {
	case speckey.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown SpecKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpecKeyMutation) ResetField(name string) error {
	switch name {
	case speckey.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case speckey.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case speckey.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case speckey.FieldName:
		m.ResetName()
		return nil
	case speckey.FieldUnit:
		m.ResetUnit()
		return nil
	case speckey.FieldStandard:
		m.ResetStandard()
		return nil
	case speckey.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown SpecKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpecKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, speckey.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpecKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case speckey.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.spu))
		for id := range m.spu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpecKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedspu != nil {
		edges = append(edges, speckey.EdgeSpu)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpecKeyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case speckey.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.removedspu))
		for id := range m.removedspu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpecKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, speckey.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpecKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case speckey.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpecKeyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SpecKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpecKeyMutation) ResetEdge(name string) error {
	switch name {
	case speckey.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown SpecKey edge %s", name)
}

// SpecValueMutation represents an operation that mutates the SpecValue nodes in the graph.
type SpecValueMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	value         *string
	spec_id       *int64
	addspec_id    *int64
	extend        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*SpecValue, error)
	predicates    []predicate.SpecValue
}

var _ ent.Mutation = (*SpecValueMutation)(nil)

// specvalueOption allows management of the mutation configuration using functional options.
type specvalueOption func(*SpecValueMutation)

// newSpecValueMutation creates new mutation for the SpecValue entity.
func newSpecValueMutation(c config, op Op, opts ...specvalueOption) *SpecValueMutation {
	m := &SpecValueMutation{
		config:        c,
		op:            op,
		typ:           TypeSpecValue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpecValueID sets the ID field of the mutation.
func withSpecValueID(id int64) specvalueOption {
	return func(m *SpecValueMutation) {
		var (
			err   error
			once  sync.Once
			value *SpecValue
		)
		m.oldValue = func(ctx context.Context) (*SpecValue, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpecValue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpecValue sets the old SpecValue of the mutation.
func withSpecValue(node *SpecValue) specvalueOption {
	return func(m *SpecValueMutation) {
		m.oldValue = func(context.Context) (*SpecValue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpecValueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpecValueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpecValueMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SpecValueMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SpecValueMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SpecValueMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SpecValueMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SpecValueMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SpecValueMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SpecValueMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SpecValueMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SpecValueMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[specvalue.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SpecValueMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[specvalue.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SpecValueMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, specvalue.FieldDeleteTime)
}

// SetValue sets the "value" field.
func (m *SpecValueMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SpecValueMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SpecValueMutation) ResetValue() {
	m.value = nil
}

// SetSpecID sets the "spec_id" field.
func (m *SpecValueMutation) SetSpecID(i int64) {
	m.spec_id = &i
	m.addspec_id = nil
}

// SpecID returns the value of the "spec_id" field in the mutation.
func (m *SpecValueMutation) SpecID() (r int64, exists bool) {
	v := m.spec_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecID returns the old "spec_id" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldSpecID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecID: %w", err)
	}
	return oldValue.SpecID, nil
}

// AddSpecID adds i to the "spec_id" field.
func (m *SpecValueMutation) AddSpecID(i int64) {
	if m.addspec_id != nil {
		*m.addspec_id += i
	} else {
		m.addspec_id = &i
	}
}

// AddedSpecID returns the value that was added to the "spec_id" field in this mutation.
func (m *SpecValueMutation) AddedSpecID() (r int64, exists bool) {
	v := m.addspec_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpecID resets all changes to the "spec_id" field.
func (m *SpecValueMutation) ResetSpecID() {
	m.spec_id = nil
	m.addspec_id = nil
}

// SetExtend sets the "extend" field.
func (m *SpecValueMutation) SetExtend(s string) {
	m.extend = &s
}

// Extend returns the value of the "extend" field in the mutation.
func (m *SpecValueMutation) Extend() (r string, exists bool) {
	v := m.extend
	if v == nil {
		return
	}
	return *v, true
}

// OldExtend returns the old "extend" field's value of the SpecValue entity.
// If the SpecValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpecValueMutation) OldExtend(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExtend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExtend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtend: %w", err)
	}
	return oldValue.Extend, nil
}

// ResetExtend resets all changes to the "extend" field.
func (m *SpecValueMutation) ResetExtend() {
	m.extend = nil
}

// Where appends a list predicates to the SpecValueMutation builder.
func (m *SpecValueMutation) Where(ps ...predicate.SpecValue) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SpecValueMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SpecValue).
func (m *SpecValueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpecValueMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, specvalue.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, specvalue.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, specvalue.FieldDeleteTime)
	}
	if m.value != nil {
		fields = append(fields, specvalue.FieldValue)
	}
	if m.spec_id != nil {
		fields = append(fields, specvalue.FieldSpecID)
	}
	if m.extend != nil {
		fields = append(fields, specvalue.FieldExtend)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpecValueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case specvalue.FieldCreateTime:
		return m.CreateTime()
	case specvalue.FieldUpdateTime:
		return m.UpdateTime()
	case specvalue.FieldDeleteTime:
		return m.DeleteTime()
	case specvalue.FieldValue:
		return m.Value()
	case specvalue.FieldSpecID:
		return m.SpecID()
	case specvalue.FieldExtend:
		return m.Extend()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpecValueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case specvalue.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case specvalue.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case specvalue.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case specvalue.FieldValue:
		return m.OldValue(ctx)
	case specvalue.FieldSpecID:
		return m.OldSpecID(ctx)
	case specvalue.FieldExtend:
		return m.OldExtend(ctx)
	}
	return nil, fmt.Errorf("unknown SpecValue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpecValueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case specvalue.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case specvalue.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case specvalue.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case specvalue.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case specvalue.FieldSpecID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecID(v)
		return nil
	case specvalue.FieldExtend:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtend(v)
		return nil
	}
	return fmt.Errorf("unknown SpecValue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpecValueMutation) AddedFields() []string {
	var fields []string
	if m.addspec_id != nil {
		fields = append(fields, specvalue.FieldSpecID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpecValueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case specvalue.FieldSpecID:
		return m.AddedSpecID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpecValueMutation) AddField(name string, value ent.Value) error {
	switch name {
	case specvalue.FieldSpecID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpecID(v)
		return nil
	}
	return fmt.Errorf("unknown SpecValue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpecValueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(specvalue.FieldDeleteTime) {
		fields = append(fields, specvalue.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpecValueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpecValueMutation) ClearField(name string) error {
	switch name {
	case specvalue.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown SpecValue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpecValueMutation) ResetField(name string) error {
	switch name {
	case specvalue.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case specvalue.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case specvalue.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case specvalue.FieldValue:
		m.ResetValue()
		return nil
	case specvalue.FieldSpecID:
		m.ResetSpecID()
		return nil
	case specvalue.FieldExtend:
		m.ResetExtend()
		return nil
	}
	return fmt.Errorf("unknown SpecValue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpecValueMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpecValueMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpecValueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpecValueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpecValueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpecValueMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpecValueMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SpecValue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpecValueMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SpecValue edge %s", name)
}

// SpuMutation represents an operation that mutates the Spu nodes in the graph.
type SpuMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	create_time           *time.Time
	update_time           *time.Time
	delete_time           *time.Time
	title                 *string
	subtitle              *string
	category_id           *int64
	addcategory_id        *int64
	root_category_id      *int64
	addroot_category_id   *int64
	online                *int
	addonline             *int
	price                 *string
	sketch_spec_id        *int
	addsketch_spec_id     *int
	default_sku_id        *int
	adddefault_sku_id     *int
	img                   *string
	discount_price        *string
	description           *string
	tags                  *string
	spu_theme_img         *string
	for_theme_img         *string
	clearedFields         map[string]struct{}
	sale_explain          map[int64]struct{}
	removedsale_explain   map[int64]struct{}
	clearedsale_explain   bool
	spu_img               map[int64]struct{}
	removedspu_img        map[int64]struct{}
	clearedspu_img        bool
	spu_detail_img        map[int64]struct{}
	removedspu_detail_img map[int64]struct{}
	clearedspu_detail_img bool
	spec_key              map[int64]struct{}
	removedspec_key       map[int64]struct{}
	clearedspec_key       bool
	tag                   map[int64]struct{}
	removedtag            map[int64]struct{}
	clearedtag            bool
	done                  bool
	oldValue              func(context.Context) (*Spu, error)
	predicates            []predicate.Spu
}

var _ ent.Mutation = (*SpuMutation)(nil)

// spuOption allows management of the mutation configuration using functional options.
type spuOption func(*SpuMutation)

// newSpuMutation creates new mutation for the Spu entity.
func newSpuMutation(c config, op Op, opts ...spuOption) *SpuMutation {
	m := &SpuMutation{
		config:        c,
		op:            op,
		typ:           TypeSpu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpuID sets the ID field of the mutation.
func withSpuID(id int64) spuOption {
	return func(m *SpuMutation) {
		var (
			err   error
			once  sync.Once
			value *Spu
		)
		m.oldValue = func(ctx context.Context) (*Spu, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Spu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpu sets the old Spu of the mutation.
func withSpu(node *Spu) spuOption {
	return func(m *SpuMutation) {
		m.oldValue = func(context.Context) (*Spu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpuMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SpuMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SpuMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SpuMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SpuMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SpuMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SpuMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SpuMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SpuMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SpuMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[spu.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SpuMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[spu.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SpuMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, spu.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *SpuMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SpuMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SpuMutation) ResetTitle() {
	m.title = nil
}

// SetSubtitle sets the "subtitle" field.
func (m *SpuMutation) SetSubtitle(s string) {
	m.subtitle = &s
}

// Subtitle returns the value of the "subtitle" field in the mutation.
func (m *SpuMutation) Subtitle() (r string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old "subtitle" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldSubtitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubtitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ResetSubtitle resets all changes to the "subtitle" field.
func (m *SpuMutation) ResetSubtitle() {
	m.subtitle = nil
}

// SetCategoryID sets the "category_id" field.
func (m *SpuMutation) SetCategoryID(i int64) {
	m.category_id = &i
	m.addcategory_id = nil
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *SpuMutation) CategoryID() (r int64, exists bool) {
	v := m.category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldCategoryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// AddCategoryID adds i to the "category_id" field.
func (m *SpuMutation) AddCategoryID(i int64) {
	if m.addcategory_id != nil {
		*m.addcategory_id += i
	} else {
		m.addcategory_id = &i
	}
}

// AddedCategoryID returns the value that was added to the "category_id" field in this mutation.
func (m *SpuMutation) AddedCategoryID() (r int64, exists bool) {
	v := m.addcategory_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *SpuMutation) ResetCategoryID() {
	m.category_id = nil
	m.addcategory_id = nil
}

// SetRootCategoryID sets the "root_category_id" field.
func (m *SpuMutation) SetRootCategoryID(i int64) {
	m.root_category_id = &i
	m.addroot_category_id = nil
}

// RootCategoryID returns the value of the "root_category_id" field in the mutation.
func (m *SpuMutation) RootCategoryID() (r int64, exists bool) {
	v := m.root_category_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRootCategoryID returns the old "root_category_id" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldRootCategoryID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRootCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRootCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootCategoryID: %w", err)
	}
	return oldValue.RootCategoryID, nil
}

// AddRootCategoryID adds i to the "root_category_id" field.
func (m *SpuMutation) AddRootCategoryID(i int64) {
	if m.addroot_category_id != nil {
		*m.addroot_category_id += i
	} else {
		m.addroot_category_id = &i
	}
}

// AddedRootCategoryID returns the value that was added to the "root_category_id" field in this mutation.
func (m *SpuMutation) AddedRootCategoryID() (r int64, exists bool) {
	v := m.addroot_category_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRootCategoryID resets all changes to the "root_category_id" field.
func (m *SpuMutation) ResetRootCategoryID() {
	m.root_category_id = nil
	m.addroot_category_id = nil
}

// SetOnline sets the "online" field.
func (m *SpuMutation) SetOnline(i int) {
	m.online = &i
	m.addonline = nil
}

// Online returns the value of the "online" field in the mutation.
func (m *SpuMutation) Online() (r int, exists bool) {
	v := m.online
	if v == nil {
		return
	}
	return *v, true
}

// OldOnline returns the old "online" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldOnline(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOnline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOnline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOnline: %w", err)
	}
	return oldValue.Online, nil
}

// AddOnline adds i to the "online" field.
func (m *SpuMutation) AddOnline(i int) {
	if m.addonline != nil {
		*m.addonline += i
	} else {
		m.addonline = &i
	}
}

// AddedOnline returns the value that was added to the "online" field in this mutation.
func (m *SpuMutation) AddedOnline() (r int, exists bool) {
	v := m.addonline
	if v == nil {
		return
	}
	return *v, true
}

// ResetOnline resets all changes to the "online" field.
func (m *SpuMutation) ResetOnline() {
	m.online = nil
	m.addonline = nil
}

// SetPrice sets the "price" field.
func (m *SpuMutation) SetPrice(s string) {
	m.price = &s
}

// Price returns the value of the "price" field in the mutation.
func (m *SpuMutation) Price() (r string, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// ResetPrice resets all changes to the "price" field.
func (m *SpuMutation) ResetPrice() {
	m.price = nil
}

// SetSketchSpecID sets the "sketch_spec_id" field.
func (m *SpuMutation) SetSketchSpecID(i int) {
	m.sketch_spec_id = &i
	m.addsketch_spec_id = nil
}

// SketchSpecID returns the value of the "sketch_spec_id" field in the mutation.
func (m *SpuMutation) SketchSpecID() (r int, exists bool) {
	v := m.sketch_spec_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSketchSpecID returns the old "sketch_spec_id" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldSketchSpecID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSketchSpecID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSketchSpecID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSketchSpecID: %w", err)
	}
	return oldValue.SketchSpecID, nil
}

// AddSketchSpecID adds i to the "sketch_spec_id" field.
func (m *SpuMutation) AddSketchSpecID(i int) {
	if m.addsketch_spec_id != nil {
		*m.addsketch_spec_id += i
	} else {
		m.addsketch_spec_id = &i
	}
}

// AddedSketchSpecID returns the value that was added to the "sketch_spec_id" field in this mutation.
func (m *SpuMutation) AddedSketchSpecID() (r int, exists bool) {
	v := m.addsketch_spec_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSketchSpecID resets all changes to the "sketch_spec_id" field.
func (m *SpuMutation) ResetSketchSpecID() {
	m.sketch_spec_id = nil
	m.addsketch_spec_id = nil
}

// SetDefaultSkuID sets the "default_sku_id" field.
func (m *SpuMutation) SetDefaultSkuID(i int) {
	m.default_sku_id = &i
	m.adddefault_sku_id = nil
}

// DefaultSkuID returns the value of the "default_sku_id" field in the mutation.
func (m *SpuMutation) DefaultSkuID() (r int, exists bool) {
	v := m.default_sku_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultSkuID returns the old "default_sku_id" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldDefaultSkuID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDefaultSkuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDefaultSkuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultSkuID: %w", err)
	}
	return oldValue.DefaultSkuID, nil
}

// AddDefaultSkuID adds i to the "default_sku_id" field.
func (m *SpuMutation) AddDefaultSkuID(i int) {
	if m.adddefault_sku_id != nil {
		*m.adddefault_sku_id += i
	} else {
		m.adddefault_sku_id = &i
	}
}

// AddedDefaultSkuID returns the value that was added to the "default_sku_id" field in this mutation.
func (m *SpuMutation) AddedDefaultSkuID() (r int, exists bool) {
	v := m.adddefault_sku_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultSkuID resets all changes to the "default_sku_id" field.
func (m *SpuMutation) ResetDefaultSkuID() {
	m.default_sku_id = nil
	m.adddefault_sku_id = nil
}

// SetImg sets the "img" field.
func (m *SpuMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *SpuMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *SpuMutation) ResetImg() {
	m.img = nil
}

// SetDiscountPrice sets the "discount_price" field.
func (m *SpuMutation) SetDiscountPrice(s string) {
	m.discount_price = &s
}

// DiscountPrice returns the value of the "discount_price" field in the mutation.
func (m *SpuMutation) DiscountPrice() (r string, exists bool) {
	v := m.discount_price
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountPrice returns the old "discount_price" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldDiscountPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiscountPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiscountPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountPrice: %w", err)
	}
	return oldValue.DiscountPrice, nil
}

// ResetDiscountPrice resets all changes to the "discount_price" field.
func (m *SpuMutation) ResetDiscountPrice() {
	m.discount_price = nil
}

// SetDescription sets the "description" field.
func (m *SpuMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SpuMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SpuMutation) ResetDescription() {
	m.description = nil
}

// SetTags sets the "tags" field.
func (m *SpuMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *SpuMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *SpuMutation) ResetTags() {
	m.tags = nil
}

// SetSpuThemeImg sets the "spu_theme_img" field.
func (m *SpuMutation) SetSpuThemeImg(s string) {
	m.spu_theme_img = &s
}

// SpuThemeImg returns the value of the "spu_theme_img" field in the mutation.
func (m *SpuMutation) SpuThemeImg() (r string, exists bool) {
	v := m.spu_theme_img
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuThemeImg returns the old "spu_theme_img" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldSpuThemeImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuThemeImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuThemeImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuThemeImg: %w", err)
	}
	return oldValue.SpuThemeImg, nil
}

// ResetSpuThemeImg resets all changes to the "spu_theme_img" field.
func (m *SpuMutation) ResetSpuThemeImg() {
	m.spu_theme_img = nil
}

// SetForThemeImg sets the "for_theme_img" field.
func (m *SpuMutation) SetForThemeImg(s string) {
	m.for_theme_img = &s
}

// ForThemeImg returns the value of the "for_theme_img" field in the mutation.
func (m *SpuMutation) ForThemeImg() (r string, exists bool) {
	v := m.for_theme_img
	if v == nil {
		return
	}
	return *v, true
}

// OldForThemeImg returns the old "for_theme_img" field's value of the Spu entity.
// If the Spu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuMutation) OldForThemeImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldForThemeImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldForThemeImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForThemeImg: %w", err)
	}
	return oldValue.ForThemeImg, nil
}

// ResetForThemeImg resets all changes to the "for_theme_img" field.
func (m *SpuMutation) ResetForThemeImg() {
	m.for_theme_img = nil
}

// AddSaleExplainIDs adds the "sale_explain" edge to the SaleExplain entity by ids.
func (m *SpuMutation) AddSaleExplainIDs(ids ...int64) {
	if m.sale_explain == nil {
		m.sale_explain = make(map[int64]struct{})
	}
	for i := range ids {
		m.sale_explain[ids[i]] = struct{}{}
	}
}

// ClearSaleExplain clears the "sale_explain" edge to the SaleExplain entity.
func (m *SpuMutation) ClearSaleExplain() {
	m.clearedsale_explain = true
}

// SaleExplainCleared reports if the "sale_explain" edge to the SaleExplain entity was cleared.
func (m *SpuMutation) SaleExplainCleared() bool {
	return m.clearedsale_explain
}

// RemoveSaleExplainIDs removes the "sale_explain" edge to the SaleExplain entity by IDs.
func (m *SpuMutation) RemoveSaleExplainIDs(ids ...int64) {
	if m.removedsale_explain == nil {
		m.removedsale_explain = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sale_explain, ids[i])
		m.removedsale_explain[ids[i]] = struct{}{}
	}
}

// RemovedSaleExplain returns the removed IDs of the "sale_explain" edge to the SaleExplain entity.
func (m *SpuMutation) RemovedSaleExplainIDs() (ids []int64) {
	for id := range m.removedsale_explain {
		ids = append(ids, id)
	}
	return
}

// SaleExplainIDs returns the "sale_explain" edge IDs in the mutation.
func (m *SpuMutation) SaleExplainIDs() (ids []int64) {
	for id := range m.sale_explain {
		ids = append(ids, id)
	}
	return
}

// ResetSaleExplain resets all changes to the "sale_explain" edge.
func (m *SpuMutation) ResetSaleExplain() {
	m.sale_explain = nil
	m.clearedsale_explain = false
	m.removedsale_explain = nil
}

// AddSpuImgIDs adds the "spu_img" edge to the SpuImg entity by ids.
func (m *SpuMutation) AddSpuImgIDs(ids ...int64) {
	if m.spu_img == nil {
		m.spu_img = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu_img[ids[i]] = struct{}{}
	}
}

// ClearSpuImg clears the "spu_img" edge to the SpuImg entity.
func (m *SpuMutation) ClearSpuImg() {
	m.clearedspu_img = true
}

// SpuImgCleared reports if the "spu_img" edge to the SpuImg entity was cleared.
func (m *SpuMutation) SpuImgCleared() bool {
	return m.clearedspu_img
}

// RemoveSpuImgIDs removes the "spu_img" edge to the SpuImg entity by IDs.
func (m *SpuMutation) RemoveSpuImgIDs(ids ...int64) {
	if m.removedspu_img == nil {
		m.removedspu_img = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu_img, ids[i])
		m.removedspu_img[ids[i]] = struct{}{}
	}
}

// RemovedSpuImg returns the removed IDs of the "spu_img" edge to the SpuImg entity.
func (m *SpuMutation) RemovedSpuImgIDs() (ids []int64) {
	for id := range m.removedspu_img {
		ids = append(ids, id)
	}
	return
}

// SpuImgIDs returns the "spu_img" edge IDs in the mutation.
func (m *SpuMutation) SpuImgIDs() (ids []int64) {
	for id := range m.spu_img {
		ids = append(ids, id)
	}
	return
}

// ResetSpuImg resets all changes to the "spu_img" edge.
func (m *SpuMutation) ResetSpuImg() {
	m.spu_img = nil
	m.clearedspu_img = false
	m.removedspu_img = nil
}

// AddSpuDetailImgIDs adds the "spu_detail_img" edge to the SpuDetailImg entity by ids.
func (m *SpuMutation) AddSpuDetailImgIDs(ids ...int64) {
	if m.spu_detail_img == nil {
		m.spu_detail_img = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu_detail_img[ids[i]] = struct{}{}
	}
}

// ClearSpuDetailImg clears the "spu_detail_img" edge to the SpuDetailImg entity.
func (m *SpuMutation) ClearSpuDetailImg() {
	m.clearedspu_detail_img = true
}

// SpuDetailImgCleared reports if the "spu_detail_img" edge to the SpuDetailImg entity was cleared.
func (m *SpuMutation) SpuDetailImgCleared() bool {
	return m.clearedspu_detail_img
}

// RemoveSpuDetailImgIDs removes the "spu_detail_img" edge to the SpuDetailImg entity by IDs.
func (m *SpuMutation) RemoveSpuDetailImgIDs(ids ...int64) {
	if m.removedspu_detail_img == nil {
		m.removedspu_detail_img = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu_detail_img, ids[i])
		m.removedspu_detail_img[ids[i]] = struct{}{}
	}
}

// RemovedSpuDetailImg returns the removed IDs of the "spu_detail_img" edge to the SpuDetailImg entity.
func (m *SpuMutation) RemovedSpuDetailImgIDs() (ids []int64) {
	for id := range m.removedspu_detail_img {
		ids = append(ids, id)
	}
	return
}

// SpuDetailImgIDs returns the "spu_detail_img" edge IDs in the mutation.
func (m *SpuMutation) SpuDetailImgIDs() (ids []int64) {
	for id := range m.spu_detail_img {
		ids = append(ids, id)
	}
	return
}

// ResetSpuDetailImg resets all changes to the "spu_detail_img" edge.
func (m *SpuMutation) ResetSpuDetailImg() {
	m.spu_detail_img = nil
	m.clearedspu_detail_img = false
	m.removedspu_detail_img = nil
}

// AddSpecKeyIDs adds the "spec_key" edge to the SpecKey entity by ids.
func (m *SpuMutation) AddSpecKeyIDs(ids ...int64) {
	if m.spec_key == nil {
		m.spec_key = make(map[int64]struct{})
	}
	for i := range ids {
		m.spec_key[ids[i]] = struct{}{}
	}
}

// ClearSpecKey clears the "spec_key" edge to the SpecKey entity.
func (m *SpuMutation) ClearSpecKey() {
	m.clearedspec_key = true
}

// SpecKeyCleared reports if the "spec_key" edge to the SpecKey entity was cleared.
func (m *SpuMutation) SpecKeyCleared() bool {
	return m.clearedspec_key
}

// RemoveSpecKeyIDs removes the "spec_key" edge to the SpecKey entity by IDs.
func (m *SpuMutation) RemoveSpecKeyIDs(ids ...int64) {
	if m.removedspec_key == nil {
		m.removedspec_key = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spec_key, ids[i])
		m.removedspec_key[ids[i]] = struct{}{}
	}
}

// RemovedSpecKey returns the removed IDs of the "spec_key" edge to the SpecKey entity.
func (m *SpuMutation) RemovedSpecKeyIDs() (ids []int64) {
	for id := range m.removedspec_key {
		ids = append(ids, id)
	}
	return
}

// SpecKeyIDs returns the "spec_key" edge IDs in the mutation.
func (m *SpuMutation) SpecKeyIDs() (ids []int64) {
	for id := range m.spec_key {
		ids = append(ids, id)
	}
	return
}

// ResetSpecKey resets all changes to the "spec_key" edge.
func (m *SpuMutation) ResetSpecKey() {
	m.spec_key = nil
	m.clearedspec_key = false
	m.removedspec_key = nil
}

// AddTagIDs adds the "tag" edge to the Tag entity by ids.
func (m *SpuMutation) AddTagIDs(ids ...int64) {
	if m.tag == nil {
		m.tag = make(map[int64]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *SpuMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *SpuMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the "tag" edge to the Tag entity by IDs.
func (m *SpuMutation) RemoveTagIDs(ids ...int64) {
	if m.removedtag == nil {
		m.removedtag = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tag, ids[i])
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "tag" edge to the Tag entity.
func (m *SpuMutation) RemovedTagIDs() (ids []int64) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
func (m *SpuMutation) TagIDs() (ids []int64) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *SpuMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Where appends a list predicates to the SpuMutation builder.
func (m *SpuMutation) Where(ps ...predicate.Spu) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SpuMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Spu).
func (m *SpuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpuMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.create_time != nil {
		fields = append(fields, spu.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, spu.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, spu.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, spu.FieldTitle)
	}
	if m.subtitle != nil {
		fields = append(fields, spu.FieldSubtitle)
	}
	if m.category_id != nil {
		fields = append(fields, spu.FieldCategoryID)
	}
	if m.root_category_id != nil {
		fields = append(fields, spu.FieldRootCategoryID)
	}
	if m.online != nil {
		fields = append(fields, spu.FieldOnline)
	}
	if m.price != nil {
		fields = append(fields, spu.FieldPrice)
	}
	if m.sketch_spec_id != nil {
		fields = append(fields, spu.FieldSketchSpecID)
	}
	if m.default_sku_id != nil {
		fields = append(fields, spu.FieldDefaultSkuID)
	}
	if m.img != nil {
		fields = append(fields, spu.FieldImg)
	}
	if m.discount_price != nil {
		fields = append(fields, spu.FieldDiscountPrice)
	}
	if m.description != nil {
		fields = append(fields, spu.FieldDescription)
	}
	if m.tags != nil {
		fields = append(fields, spu.FieldTags)
	}
	if m.spu_theme_img != nil {
		fields = append(fields, spu.FieldSpuThemeImg)
	}
	if m.for_theme_img != nil {
		fields = append(fields, spu.FieldForThemeImg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spu.FieldCreateTime:
		return m.CreateTime()
	case spu.FieldUpdateTime:
		return m.UpdateTime()
	case spu.FieldDeleteTime:
		return m.DeleteTime()
	case spu.FieldTitle:
		return m.Title()
	case spu.FieldSubtitle:
		return m.Subtitle()
	case spu.FieldCategoryID:
		return m.CategoryID()
	case spu.FieldRootCategoryID:
		return m.RootCategoryID()
	case spu.FieldOnline:
		return m.Online()
	case spu.FieldPrice:
		return m.Price()
	case spu.FieldSketchSpecID:
		return m.SketchSpecID()
	case spu.FieldDefaultSkuID:
		return m.DefaultSkuID()
	case spu.FieldImg:
		return m.Img()
	case spu.FieldDiscountPrice:
		return m.DiscountPrice()
	case spu.FieldDescription:
		return m.Description()
	case spu.FieldTags:
		return m.Tags()
	case spu.FieldSpuThemeImg:
		return m.SpuThemeImg()
	case spu.FieldForThemeImg:
		return m.ForThemeImg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spu.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case spu.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case spu.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case spu.FieldTitle:
		return m.OldTitle(ctx)
	case spu.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case spu.FieldCategoryID:
		return m.OldCategoryID(ctx)
	case spu.FieldRootCategoryID:
		return m.OldRootCategoryID(ctx)
	case spu.FieldOnline:
		return m.OldOnline(ctx)
	case spu.FieldPrice:
		return m.OldPrice(ctx)
	case spu.FieldSketchSpecID:
		return m.OldSketchSpecID(ctx)
	case spu.FieldDefaultSkuID:
		return m.OldDefaultSkuID(ctx)
	case spu.FieldImg:
		return m.OldImg(ctx)
	case spu.FieldDiscountPrice:
		return m.OldDiscountPrice(ctx)
	case spu.FieldDescription:
		return m.OldDescription(ctx)
	case spu.FieldTags:
		return m.OldTags(ctx)
	case spu.FieldSpuThemeImg:
		return m.OldSpuThemeImg(ctx)
	case spu.FieldForThemeImg:
		return m.OldForThemeImg(ctx)
	}
	return nil, fmt.Errorf("unknown Spu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spu.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case spu.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case spu.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case spu.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case spu.FieldSubtitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case spu.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	case spu.FieldRootCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootCategoryID(v)
		return nil
	case spu.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOnline(v)
		return nil
	case spu.FieldPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case spu.FieldSketchSpecID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSketchSpecID(v)
		return nil
	case spu.FieldDefaultSkuID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultSkuID(v)
		return nil
	case spu.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case spu.FieldDiscountPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountPrice(v)
		return nil
	case spu.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case spu.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case spu.FieldSpuThemeImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuThemeImg(v)
		return nil
	case spu.FieldForThemeImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForThemeImg(v)
		return nil
	}
	return fmt.Errorf("unknown Spu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpuMutation) AddedFields() []string {
	var fields []string
	if m.addcategory_id != nil {
		fields = append(fields, spu.FieldCategoryID)
	}
	if m.addroot_category_id != nil {
		fields = append(fields, spu.FieldRootCategoryID)
	}
	if m.addonline != nil {
		fields = append(fields, spu.FieldOnline)
	}
	if m.addsketch_spec_id != nil {
		fields = append(fields, spu.FieldSketchSpecID)
	}
	if m.adddefault_sku_id != nil {
		fields = append(fields, spu.FieldDefaultSkuID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case spu.FieldCategoryID:
		return m.AddedCategoryID()
	case spu.FieldRootCategoryID:
		return m.AddedRootCategoryID()
	case spu.FieldOnline:
		return m.AddedOnline()
	case spu.FieldSketchSpecID:
		return m.AddedSketchSpecID()
	case spu.FieldDefaultSkuID:
		return m.AddedDefaultSkuID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case spu.FieldCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCategoryID(v)
		return nil
	case spu.FieldRootCategoryID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRootCategoryID(v)
		return nil
	case spu.FieldOnline:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOnline(v)
		return nil
	case spu.FieldSketchSpecID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSketchSpecID(v)
		return nil
	case spu.FieldDefaultSkuID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultSkuID(v)
		return nil
	}
	return fmt.Errorf("unknown Spu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spu.FieldDeleteTime) {
		fields = append(fields, spu.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpuMutation) ClearField(name string) error {
	switch name {
	case spu.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Spu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpuMutation) ResetField(name string) error {
	switch name {
	case spu.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case spu.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case spu.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case spu.FieldTitle:
		m.ResetTitle()
		return nil
	case spu.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case spu.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	case spu.FieldRootCategoryID:
		m.ResetRootCategoryID()
		return nil
	case spu.FieldOnline:
		m.ResetOnline()
		return nil
	case spu.FieldPrice:
		m.ResetPrice()
		return nil
	case spu.FieldSketchSpecID:
		m.ResetSketchSpecID()
		return nil
	case spu.FieldDefaultSkuID:
		m.ResetDefaultSkuID()
		return nil
	case spu.FieldImg:
		m.ResetImg()
		return nil
	case spu.FieldDiscountPrice:
		m.ResetDiscountPrice()
		return nil
	case spu.FieldDescription:
		m.ResetDescription()
		return nil
	case spu.FieldTags:
		m.ResetTags()
		return nil
	case spu.FieldSpuThemeImg:
		m.ResetSpuThemeImg()
		return nil
	case spu.FieldForThemeImg:
		m.ResetForThemeImg()
		return nil
	}
	return fmt.Errorf("unknown Spu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpuMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.sale_explain != nil {
		edges = append(edges, spu.EdgeSaleExplain)
	}
	if m.spu_img != nil {
		edges = append(edges, spu.EdgeSpuImg)
	}
	if m.spu_detail_img != nil {
		edges = append(edges, spu.EdgeSpuDetailImg)
	}
	if m.spec_key != nil {
		edges = append(edges, spu.EdgeSpecKey)
	}
	if m.tag != nil {
		edges = append(edges, spu.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spu.EdgeSaleExplain:
		ids := make([]ent.Value, 0, len(m.sale_explain))
		for id := range m.sale_explain {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpuImg:
		ids := make([]ent.Value, 0, len(m.spu_img))
		for id := range m.spu_img {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpuDetailImg:
		ids := make([]ent.Value, 0, len(m.spu_detail_img))
		for id := range m.spu_detail_img {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpecKey:
		ids := make([]ent.Value, 0, len(m.spec_key))
		for id := range m.spec_key {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedsale_explain != nil {
		edges = append(edges, spu.EdgeSaleExplain)
	}
	if m.removedspu_img != nil {
		edges = append(edges, spu.EdgeSpuImg)
	}
	if m.removedspu_detail_img != nil {
		edges = append(edges, spu.EdgeSpuDetailImg)
	}
	if m.removedspec_key != nil {
		edges = append(edges, spu.EdgeSpecKey)
	}
	if m.removedtag != nil {
		edges = append(edges, spu.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case spu.EdgeSaleExplain:
		ids := make([]ent.Value, 0, len(m.removedsale_explain))
		for id := range m.removedsale_explain {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpuImg:
		ids := make([]ent.Value, 0, len(m.removedspu_img))
		for id := range m.removedspu_img {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpuDetailImg:
		ids := make([]ent.Value, 0, len(m.removedspu_detail_img))
		for id := range m.removedspu_detail_img {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeSpecKey:
		ids := make([]ent.Value, 0, len(m.removedspec_key))
		for id := range m.removedspec_key {
			ids = append(ids, id)
		}
		return ids
	case spu.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedsale_explain {
		edges = append(edges, spu.EdgeSaleExplain)
	}
	if m.clearedspu_img {
		edges = append(edges, spu.EdgeSpuImg)
	}
	if m.clearedspu_detail_img {
		edges = append(edges, spu.EdgeSpuDetailImg)
	}
	if m.clearedspec_key {
		edges = append(edges, spu.EdgeSpecKey)
	}
	if m.clearedtag {
		edges = append(edges, spu.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpuMutation) EdgeCleared(name string) bool {
	switch name {
	case spu.EdgeSaleExplain:
		return m.clearedsale_explain
	case spu.EdgeSpuImg:
		return m.clearedspu_img
	case spu.EdgeSpuDetailImg:
		return m.clearedspu_detail_img
	case spu.EdgeSpecKey:
		return m.clearedspec_key
	case spu.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpuMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Spu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpuMutation) ResetEdge(name string) error {
	switch name {
	case spu.EdgeSaleExplain:
		m.ResetSaleExplain()
		return nil
	case spu.EdgeSpuImg:
		m.ResetSpuImg()
		return nil
	case spu.EdgeSpuDetailImg:
		m.ResetSpuDetailImg()
		return nil
	case spu.EdgeSpecKey:
		m.ResetSpecKey()
		return nil
	case spu.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown Spu edge %s", name)
}

// SpuDetailImgMutation represents an operation that mutates the SpuDetailImg nodes in the graph.
type SpuDetailImgMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	img           *string
	index         *int
	addindex      *int
	clearedFields map[string]struct{}
	spu           *int64
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*SpuDetailImg, error)
	predicates    []predicate.SpuDetailImg
}

var _ ent.Mutation = (*SpuDetailImgMutation)(nil)

// spudetailimgOption allows management of the mutation configuration using functional options.
type spudetailimgOption func(*SpuDetailImgMutation)

// newSpuDetailImgMutation creates new mutation for the SpuDetailImg entity.
func newSpuDetailImgMutation(c config, op Op, opts ...spudetailimgOption) *SpuDetailImgMutation {
	m := &SpuDetailImgMutation{
		config:        c,
		op:            op,
		typ:           TypeSpuDetailImg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpuDetailImgID sets the ID field of the mutation.
func withSpuDetailImgID(id int64) spudetailimgOption {
	return func(m *SpuDetailImgMutation) {
		var (
			err   error
			once  sync.Once
			value *SpuDetailImg
		)
		m.oldValue = func(ctx context.Context) (*SpuDetailImg, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpuDetailImg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpuDetailImg sets the old SpuDetailImg of the mutation.
func withSpuDetailImg(node *SpuDetailImg) spudetailimgOption {
	return func(m *SpuDetailImgMutation) {
		m.oldValue = func(context.Context) (*SpuDetailImg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpuDetailImgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpuDetailImgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpuDetailImgMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SpuDetailImgMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SpuDetailImgMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SpuDetailImgMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SpuDetailImgMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SpuDetailImgMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SpuDetailImgMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SpuDetailImgMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SpuDetailImgMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SpuDetailImgMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[spudetailimg.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SpuDetailImgMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[spudetailimg.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SpuDetailImgMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, spudetailimg.FieldDeleteTime)
}

// SetImg sets the "img" field.
func (m *SpuDetailImgMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *SpuDetailImgMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *SpuDetailImgMutation) ResetImg() {
	m.img = nil
}

// SetSpuID sets the "spu_id" field.
func (m *SpuDetailImgMutation) SetSpuID(i int64) {
	m.spu = &i
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *SpuDetailImgMutation) SpuID() (r int64, exists bool) {
	v := m.spu
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// ClearSpuID clears the value of the "spu_id" field.
func (m *SpuDetailImgMutation) ClearSpuID() {
	m.spu = nil
	m.clearedFields[spudetailimg.FieldSpuID] = struct{}{}
}

// SpuIDCleared returns if the "spu_id" field was cleared in this mutation.
func (m *SpuDetailImgMutation) SpuIDCleared() bool {
	_, ok := m.clearedFields[spudetailimg.FieldSpuID]
	return ok
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *SpuDetailImgMutation) ResetSpuID() {
	m.spu = nil
	delete(m.clearedFields, spudetailimg.FieldSpuID)
}

// SetIndex sets the "index" field.
func (m *SpuDetailImgMutation) SetIndex(i int) {
	m.index = &i
	m.addindex = nil
}

// Index returns the value of the "index" field in the mutation.
func (m *SpuDetailImgMutation) Index() (r int, exists bool) {
	v := m.index
	if v == nil {
		return
	}
	return *v, true
}

// OldIndex returns the old "index" field's value of the SpuDetailImg entity.
// If the SpuDetailImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuDetailImgMutation) OldIndex(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndex: %w", err)
	}
	return oldValue.Index, nil
}

// AddIndex adds i to the "index" field.
func (m *SpuDetailImgMutation) AddIndex(i int) {
	if m.addindex != nil {
		*m.addindex += i
	} else {
		m.addindex = &i
	}
}

// AddedIndex returns the value that was added to the "index" field in this mutation.
func (m *SpuDetailImgMutation) AddedIndex() (r int, exists bool) {
	v := m.addindex
	if v == nil {
		return
	}
	return *v, true
}

// ResetIndex resets all changes to the "index" field.
func (m *SpuDetailImgMutation) ResetIndex() {
	m.index = nil
	m.addindex = nil
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *SpuDetailImgMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *SpuDetailImgMutation) SpuCleared() bool {
	return m.SpuIDCleared() || m.clearedspu
}

// SpuIDs returns the "spu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpuID instead. It exists only for internal usage by the builders.
func (m *SpuDetailImgMutation) SpuIDs() (ids []int64) {
	if id := m.spu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *SpuDetailImgMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
}

// Where appends a list predicates to the SpuDetailImgMutation builder.
func (m *SpuDetailImgMutation) Where(ps ...predicate.SpuDetailImg) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SpuDetailImgMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SpuDetailImg).
func (m *SpuDetailImgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpuDetailImgMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, spudetailimg.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, spudetailimg.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, spudetailimg.FieldDeleteTime)
	}
	if m.img != nil {
		fields = append(fields, spudetailimg.FieldImg)
	}
	if m.spu != nil {
		fields = append(fields, spudetailimg.FieldSpuID)
	}
	if m.index != nil {
		fields = append(fields, spudetailimg.FieldIndex)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpuDetailImgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spudetailimg.FieldCreateTime:
		return m.CreateTime()
	case spudetailimg.FieldUpdateTime:
		return m.UpdateTime()
	case spudetailimg.FieldDeleteTime:
		return m.DeleteTime()
	case spudetailimg.FieldImg:
		return m.Img()
	case spudetailimg.FieldSpuID:
		return m.SpuID()
	case spudetailimg.FieldIndex:
		return m.Index()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpuDetailImgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spudetailimg.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case spudetailimg.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case spudetailimg.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case spudetailimg.FieldImg:
		return m.OldImg(ctx)
	case spudetailimg.FieldSpuID:
		return m.OldSpuID(ctx)
	case spudetailimg.FieldIndex:
		return m.OldIndex(ctx)
	}
	return nil, fmt.Errorf("unknown SpuDetailImg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuDetailImgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spudetailimg.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case spudetailimg.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case spudetailimg.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case spudetailimg.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case spudetailimg.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case spudetailimg.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpuDetailImgMutation) AddedFields() []string {
	var fields []string
	if m.addindex != nil {
		fields = append(fields, spudetailimg.FieldIndex)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpuDetailImgMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case spudetailimg.FieldIndex:
		return m.AddedIndex()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuDetailImgMutation) AddField(name string, value ent.Value) error {
	switch name {
	case spudetailimg.FieldIndex:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndex(v)
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpuDetailImgMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spudetailimg.FieldDeleteTime) {
		fields = append(fields, spudetailimg.FieldDeleteTime)
	}
	if m.FieldCleared(spudetailimg.FieldSpuID) {
		fields = append(fields, spudetailimg.FieldSpuID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpuDetailImgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpuDetailImgMutation) ClearField(name string) error {
	switch name {
	case spudetailimg.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case spudetailimg.FieldSpuID:
		m.ClearSpuID()
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpuDetailImgMutation) ResetField(name string) error {
	switch name {
	case spudetailimg.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case spudetailimg.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case spudetailimg.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case spudetailimg.FieldImg:
		m.ResetImg()
		return nil
	case spudetailimg.FieldSpuID:
		m.ResetSpuID()
		return nil
	case spudetailimg.FieldIndex:
		m.ResetIndex()
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpuDetailImgMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, spudetailimg.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpuDetailImgMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spudetailimg.EdgeSpu:
		if id := m.spu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpuDetailImgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpuDetailImgMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpuDetailImgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, spudetailimg.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpuDetailImgMutation) EdgeCleared(name string) bool {
	switch name {
	case spudetailimg.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpuDetailImgMutation) ClearEdge(name string) error {
	switch name {
	case spudetailimg.EdgeSpu:
		m.ClearSpu()
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpuDetailImgMutation) ResetEdge(name string) error {
	switch name {
	case spudetailimg.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown SpuDetailImg edge %s", name)
}

// SpuImgMutation represents an operation that mutates the SpuImg nodes in the graph.
type SpuImgMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	img           *string
	clearedFields map[string]struct{}
	spu           *int64
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*SpuImg, error)
	predicates    []predicate.SpuImg
}

var _ ent.Mutation = (*SpuImgMutation)(nil)

// spuimgOption allows management of the mutation configuration using functional options.
type spuimgOption func(*SpuImgMutation)

// newSpuImgMutation creates new mutation for the SpuImg entity.
func newSpuImgMutation(c config, op Op, opts ...spuimgOption) *SpuImgMutation {
	m := &SpuImgMutation{
		config:        c,
		op:            op,
		typ:           TypeSpuImg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpuImgID sets the ID field of the mutation.
func withSpuImgID(id int64) spuimgOption {
	return func(m *SpuImgMutation) {
		var (
			err   error
			once  sync.Once
			value *SpuImg
		)
		m.oldValue = func(ctx context.Context) (*SpuImg, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpuImg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpuImg sets the old SpuImg of the mutation.
func withSpuImg(node *SpuImg) spuimgOption {
	return func(m *SpuImgMutation) {
		m.oldValue = func(context.Context) (*SpuImg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpuImgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpuImgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpuImgMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *SpuImgMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *SpuImgMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the SpuImg entity.
// If the SpuImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuImgMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *SpuImgMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *SpuImgMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *SpuImgMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the SpuImg entity.
// If the SpuImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuImgMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *SpuImgMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *SpuImgMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *SpuImgMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the SpuImg entity.
// If the SpuImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuImgMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *SpuImgMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[spuimg.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *SpuImgMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[spuimg.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *SpuImgMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, spuimg.FieldDeleteTime)
}

// SetImg sets the "img" field.
func (m *SpuImgMutation) SetImg(s string) {
	m.img = &s
}

// Img returns the value of the "img" field in the mutation.
func (m *SpuImgMutation) Img() (r string, exists bool) {
	v := m.img
	if v == nil {
		return
	}
	return *v, true
}

// OldImg returns the old "img" field's value of the SpuImg entity.
// If the SpuImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuImgMutation) OldImg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImg: %w", err)
	}
	return oldValue.Img, nil
}

// ResetImg resets all changes to the "img" field.
func (m *SpuImgMutation) ResetImg() {
	m.img = nil
}

// SetSpuID sets the "spu_id" field.
func (m *SpuImgMutation) SetSpuID(i int64) {
	m.spu = &i
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *SpuImgMutation) SpuID() (r int64, exists bool) {
	v := m.spu
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the SpuImg entity.
// If the SpuImg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpuImgMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// ClearSpuID clears the value of the "spu_id" field.
func (m *SpuImgMutation) ClearSpuID() {
	m.spu = nil
	m.clearedFields[spuimg.FieldSpuID] = struct{}{}
}

// SpuIDCleared returns if the "spu_id" field was cleared in this mutation.
func (m *SpuImgMutation) SpuIDCleared() bool {
	_, ok := m.clearedFields[spuimg.FieldSpuID]
	return ok
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *SpuImgMutation) ResetSpuID() {
	m.spu = nil
	delete(m.clearedFields, spuimg.FieldSpuID)
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *SpuImgMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *SpuImgMutation) SpuCleared() bool {
	return m.SpuIDCleared() || m.clearedspu
}

// SpuIDs returns the "spu" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpuID instead. It exists only for internal usage by the builders.
func (m *SpuImgMutation) SpuIDs() (ids []int64) {
	if id := m.spu; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *SpuImgMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
}

// Where appends a list predicates to the SpuImgMutation builder.
func (m *SpuImgMutation) Where(ps ...predicate.SpuImg) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SpuImgMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SpuImg).
func (m *SpuImgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpuImgMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.create_time != nil {
		fields = append(fields, spuimg.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, spuimg.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, spuimg.FieldDeleteTime)
	}
	if m.img != nil {
		fields = append(fields, spuimg.FieldImg)
	}
	if m.spu != nil {
		fields = append(fields, spuimg.FieldSpuID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpuImgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spuimg.FieldCreateTime:
		return m.CreateTime()
	case spuimg.FieldUpdateTime:
		return m.UpdateTime()
	case spuimg.FieldDeleteTime:
		return m.DeleteTime()
	case spuimg.FieldImg:
		return m.Img()
	case spuimg.FieldSpuID:
		return m.SpuID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpuImgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spuimg.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case spuimg.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case spuimg.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case spuimg.FieldImg:
		return m.OldImg(ctx)
	case spuimg.FieldSpuID:
		return m.OldSpuID(ctx)
	}
	return nil, fmt.Errorf("unknown SpuImg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuImgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spuimg.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case spuimg.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case spuimg.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case spuimg.FieldImg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImg(v)
		return nil
	case spuimg.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	}
	return fmt.Errorf("unknown SpuImg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpuImgMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpuImgMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpuImgMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SpuImg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpuImgMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spuimg.FieldDeleteTime) {
		fields = append(fields, spuimg.FieldDeleteTime)
	}
	if m.FieldCleared(spuimg.FieldSpuID) {
		fields = append(fields, spuimg.FieldSpuID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpuImgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpuImgMutation) ClearField(name string) error {
	switch name {
	case spuimg.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	case spuimg.FieldSpuID:
		m.ClearSpuID()
		return nil
	}
	return fmt.Errorf("unknown SpuImg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpuImgMutation) ResetField(name string) error {
	switch name {
	case spuimg.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case spuimg.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case spuimg.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case spuimg.FieldImg:
		m.ResetImg()
		return nil
	case spuimg.FieldSpuID:
		m.ResetSpuID()
		return nil
	}
	return fmt.Errorf("unknown SpuImg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpuImgMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, spuimg.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpuImgMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spuimg.EdgeSpu:
		if id := m.spu; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpuImgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpuImgMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpuImgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, spuimg.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpuImgMutation) EdgeCleared(name string) bool {
	switch name {
	case spuimg.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpuImgMutation) ClearEdge(name string) error {
	switch name {
	case spuimg.EdgeSpu:
		m.ClearSpu()
		return nil
	}
	return fmt.Errorf("unknown SpuImg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpuImgMutation) ResetEdge(name string) error {
	switch name {
	case spuimg.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown SpuImg edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	title         *string
	description   *string
	highlight     *int
	addhighlight  *int
	_type         *int
	add_type      *int
	clearedFields map[string]struct{}
	spu           map[int64]struct{}
	removedspu    map[int64]struct{}
	clearedspu    bool
	done          bool
	oldValue      func(context.Context) (*Tag, error)
	predicates    []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int64) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *TagMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *TagMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *TagMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *TagMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *TagMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *TagMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *TagMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *TagMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *TagMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[tag.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *TagMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[tag.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *TagMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, tag.FieldDeleteTime)
}

// SetTitle sets the "title" field.
func (m *TagMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TagMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TagMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TagMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TagMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TagMutation) ResetDescription() {
	m.description = nil
}

// SetHighlight sets the "highlight" field.
func (m *TagMutation) SetHighlight(i int) {
	m.highlight = &i
	m.addhighlight = nil
}

// Highlight returns the value of the "highlight" field in the mutation.
func (m *TagMutation) Highlight() (r int, exists bool) {
	v := m.highlight
	if v == nil {
		return
	}
	return *v, true
}

// OldHighlight returns the old "highlight" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldHighlight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHighlight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHighlight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighlight: %w", err)
	}
	return oldValue.Highlight, nil
}

// AddHighlight adds i to the "highlight" field.
func (m *TagMutation) AddHighlight(i int) {
	if m.addhighlight != nil {
		*m.addhighlight += i
	} else {
		m.addhighlight = &i
	}
}

// AddedHighlight returns the value that was added to the "highlight" field in this mutation.
func (m *TagMutation) AddedHighlight() (r int, exists bool) {
	v := m.addhighlight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHighlight resets all changes to the "highlight" field.
func (m *TagMutation) ResetHighlight() {
	m.highlight = nil
	m.addhighlight = nil
}

// SetType sets the "type" field.
func (m *TagMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *TagMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *TagMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *TagMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *TagMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// AddSpuIDs adds the "spu" edge to the Spu entity by ids.
func (m *TagMutation) AddSpuIDs(ids ...int64) {
	if m.spu == nil {
		m.spu = make(map[int64]struct{})
	}
	for i := range ids {
		m.spu[ids[i]] = struct{}{}
	}
}

// ClearSpu clears the "spu" edge to the Spu entity.
func (m *TagMutation) ClearSpu() {
	m.clearedspu = true
}

// SpuCleared reports if the "spu" edge to the Spu entity was cleared.
func (m *TagMutation) SpuCleared() bool {
	return m.clearedspu
}

// RemoveSpuIDs removes the "spu" edge to the Spu entity by IDs.
func (m *TagMutation) RemoveSpuIDs(ids ...int64) {
	if m.removedspu == nil {
		m.removedspu = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spu, ids[i])
		m.removedspu[ids[i]] = struct{}{}
	}
}

// RemovedSpu returns the removed IDs of the "spu" edge to the Spu entity.
func (m *TagMutation) RemovedSpuIDs() (ids []int64) {
	for id := range m.removedspu {
		ids = append(ids, id)
	}
	return
}

// SpuIDs returns the "spu" edge IDs in the mutation.
func (m *TagMutation) SpuIDs() (ids []int64) {
	for id := range m.spu {
		ids = append(ids, id)
	}
	return
}

// ResetSpu resets all changes to the "spu" edge.
func (m *TagMutation) ResetSpu() {
	m.spu = nil
	m.clearedspu = false
	m.removedspu = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, tag.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, tag.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, tag.FieldDeleteTime)
	}
	if m.title != nil {
		fields = append(fields, tag.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, tag.FieldDescription)
	}
	if m.highlight != nil {
		fields = append(fields, tag.FieldHighlight)
	}
	if m._type != nil {
		fields = append(fields, tag.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCreateTime:
		return m.CreateTime()
	case tag.FieldUpdateTime:
		return m.UpdateTime()
	case tag.FieldDeleteTime:
		return m.DeleteTime()
	case tag.FieldTitle:
		return m.Title()
	case tag.FieldDescription:
		return m.Description()
	case tag.FieldHighlight:
		return m.Highlight()
	case tag.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case tag.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case tag.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case tag.FieldTitle:
		return m.OldTitle(ctx)
	case tag.FieldDescription:
		return m.OldDescription(ctx)
	case tag.FieldHighlight:
		return m.OldHighlight(ctx)
	case tag.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case tag.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case tag.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case tag.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case tag.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case tag.FieldHighlight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighlight(v)
		return nil
	case tag.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	if m.addhighlight != nil {
		fields = append(fields, tag.FieldHighlight)
	}
	if m.add_type != nil {
		fields = append(fields, tag.FieldType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldHighlight:
		return m.AddedHighlight()
	case tag.FieldType:
		return m.AddedType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	case tag.FieldHighlight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHighlight(v)
		return nil
	case tag.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldDeleteTime) {
		fields = append(fields, tag.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case tag.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case tag.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case tag.FieldTitle:
		m.ResetTitle()
		return nil
	case tag.FieldDescription:
		m.ResetDescription()
		return nil
	case tag.FieldHighlight:
		m.ResetHighlight()
		return nil
	case tag.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.spu != nil {
		edges = append(edges, tag.EdgeSpu)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.spu))
		for id := range m.spu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedspu != nil {
		edges = append(edges, tag.EdgeSpu)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeSpu:
		ids := make([]ent.Value, 0, len(m.removedspu))
		for id := range m.removedspu {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedspu {
		edges = append(edges, tag.EdgeSpu)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeSpu:
		return m.clearedspu
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeSpu:
		m.ResetSpu()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserFavorMutation represents an operation that mutates the UserFavor nodes in the graph.
type UserFavorMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	create_time   *time.Time
	update_time   *time.Time
	delete_time   *time.Time
	user_id       *int64
	adduser_id    *int64
	spu_id        *int64
	addspu_id     *int64
	status        *int
	addstatus     *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UserFavor, error)
	predicates    []predicate.UserFavor
}

var _ ent.Mutation = (*UserFavorMutation)(nil)

// userfavorOption allows management of the mutation configuration using functional options.
type userfavorOption func(*UserFavorMutation)

// newUserFavorMutation creates new mutation for the UserFavor entity.
func newUserFavorMutation(c config, op Op, opts ...userfavorOption) *UserFavorMutation {
	m := &UserFavorMutation{
		config:        c,
		op:            op,
		typ:           TypeUserFavor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserFavorID sets the ID field of the mutation.
func withUserFavorID(id int64) userfavorOption {
	return func(m *UserFavorMutation) {
		var (
			err   error
			once  sync.Once
			value *UserFavor
		)
		m.oldValue = func(ctx context.Context) (*UserFavor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserFavor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserFavor sets the old UserFavor of the mutation.
func withUserFavor(node *UserFavor) userfavorOption {
	return func(m *UserFavorMutation) {
		m.oldValue = func(context.Context) (*UserFavor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserFavorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserFavorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("model: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserFavorMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *UserFavorMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserFavorMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserFavorMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserFavorMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserFavorMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserFavorMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetDeleteTime sets the "delete_time" field.
func (m *UserFavorMutation) SetDeleteTime(t time.Time) {
	m.delete_time = &t
}

// DeleteTime returns the value of the "delete_time" field in the mutation.
func (m *UserFavorMutation) DeleteTime() (r time.Time, exists bool) {
	v := m.delete_time
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteTime returns the old "delete_time" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldDeleteTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeleteTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeleteTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteTime: %w", err)
	}
	return oldValue.DeleteTime, nil
}

// ClearDeleteTime clears the value of the "delete_time" field.
func (m *UserFavorMutation) ClearDeleteTime() {
	m.delete_time = nil
	m.clearedFields[userfavor.FieldDeleteTime] = struct{}{}
}

// DeleteTimeCleared returns if the "delete_time" field was cleared in this mutation.
func (m *UserFavorMutation) DeleteTimeCleared() bool {
	_, ok := m.clearedFields[userfavor.FieldDeleteTime]
	return ok
}

// ResetDeleteTime resets all changes to the "delete_time" field.
func (m *UserFavorMutation) ResetDeleteTime() {
	m.delete_time = nil
	delete(m.clearedFields, userfavor.FieldDeleteTime)
}

// SetUserID sets the "user_id" field.
func (m *UserFavorMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserFavorMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserFavorMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserFavorMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserFavorMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetSpuID sets the "spu_id" field.
func (m *UserFavorMutation) SetSpuID(i int64) {
	m.spu_id = &i
	m.addspu_id = nil
}

// SpuID returns the value of the "spu_id" field in the mutation.
func (m *UserFavorMutation) SpuID() (r int64, exists bool) {
	v := m.spu_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSpuID returns the old "spu_id" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldSpuID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSpuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSpuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpuID: %w", err)
	}
	return oldValue.SpuID, nil
}

// AddSpuID adds i to the "spu_id" field.
func (m *UserFavorMutation) AddSpuID(i int64) {
	if m.addspu_id != nil {
		*m.addspu_id += i
	} else {
		m.addspu_id = &i
	}
}

// AddedSpuID returns the value that was added to the "spu_id" field in this mutation.
func (m *UserFavorMutation) AddedSpuID() (r int64, exists bool) {
	v := m.addspu_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSpuID resets all changes to the "spu_id" field.
func (m *UserFavorMutation) ResetSpuID() {
	m.spu_id = nil
	m.addspu_id = nil
}

// SetStatus sets the "status" field.
func (m *UserFavorMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *UserFavorMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserFavor entity.
// If the UserFavor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserFavorMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *UserFavorMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *UserFavorMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *UserFavorMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// Where appends a list predicates to the UserFavorMutation builder.
func (m *UserFavorMutation) Where(ps ...predicate.UserFavor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserFavorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserFavor).
func (m *UserFavorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserFavorMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, userfavor.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, userfavor.FieldUpdateTime)
	}
	if m.delete_time != nil {
		fields = append(fields, userfavor.FieldDeleteTime)
	}
	if m.user_id != nil {
		fields = append(fields, userfavor.FieldUserID)
	}
	if m.spu_id != nil {
		fields = append(fields, userfavor.FieldSpuID)
	}
	if m.status != nil {
		fields = append(fields, userfavor.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserFavorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userfavor.FieldCreateTime:
		return m.CreateTime()
	case userfavor.FieldUpdateTime:
		return m.UpdateTime()
	case userfavor.FieldDeleteTime:
		return m.DeleteTime()
	case userfavor.FieldUserID:
		return m.UserID()
	case userfavor.FieldSpuID:
		return m.SpuID()
	case userfavor.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserFavorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userfavor.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case userfavor.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case userfavor.FieldDeleteTime:
		return m.OldDeleteTime(ctx)
	case userfavor.FieldUserID:
		return m.OldUserID(ctx)
	case userfavor.FieldSpuID:
		return m.OldSpuID(ctx)
	case userfavor.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown UserFavor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userfavor.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case userfavor.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case userfavor.FieldDeleteTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteTime(v)
		return nil
	case userfavor.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userfavor.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpuID(v)
		return nil
	case userfavor.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserFavor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserFavorMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userfavor.FieldUserID)
	}
	if m.addspu_id != nil {
		fields = append(fields, userfavor.FieldSpuID)
	}
	if m.addstatus != nil {
		fields = append(fields, userfavor.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserFavorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userfavor.FieldUserID:
		return m.AddedUserID()
	case userfavor.FieldSpuID:
		return m.AddedSpuID()
	case userfavor.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserFavorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userfavor.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userfavor.FieldSpuID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSpuID(v)
		return nil
	case userfavor.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown UserFavor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserFavorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userfavor.FieldDeleteTime) {
		fields = append(fields, userfavor.FieldDeleteTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserFavorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserFavorMutation) ClearField(name string) error {
	switch name {
	case userfavor.FieldDeleteTime:
		m.ClearDeleteTime()
		return nil
	}
	return fmt.Errorf("unknown UserFavor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserFavorMutation) ResetField(name string) error {
	switch name {
	case userfavor.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case userfavor.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case userfavor.FieldDeleteTime:
		m.ResetDeleteTime()
		return nil
	case userfavor.FieldUserID:
		m.ResetUserID()
		return nil
	case userfavor.FieldSpuID:
		m.ResetSpuID()
		return nil
	case userfavor.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown UserFavor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserFavorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserFavorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserFavorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserFavorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserFavorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserFavorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserFavorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserFavor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserFavorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserFavor edge %s", name)
}
