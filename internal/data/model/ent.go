// Code generated by entc, DO NOT EDIT.

package model

import (
	"errors"
	"fmt"
	"mall-go/internal/data/model/activity"
	"mall-go/internal/data/model/banner"
	"mall-go/internal/data/model/banneritem"
	"mall-go/internal/data/model/brand"
	"mall-go/internal/data/model/category"
	"mall-go/internal/data/model/charge"
	"mall-go/internal/data/model/coupon"
	"mall-go/internal/data/model/coupontemplate"
	"mall-go/internal/data/model/coupontype"
	"mall-go/internal/data/model/gridcategory"
	"mall-go/internal/data/model/order"
	"mall-go/internal/data/model/orderdetail"
	"mall-go/internal/data/model/ordersnap"
	"mall-go/internal/data/model/ordersub"
	"mall-go/internal/data/model/refund"
	"mall-go/internal/data/model/saleexplain"
	"mall-go/internal/data/model/sku"
	"mall-go/internal/data/model/skuspec"
	"mall-go/internal/data/model/speckey"
	"mall-go/internal/data/model/specvalue"
	"mall-go/internal/data/model/spu"
	"mall-go/internal/data/model/spudetailimg"
	"mall-go/internal/data/model/spuimg"
	"mall-go/internal/data/model/tag"
	"mall-go/internal/data/model/theme"
	"mall-go/internal/data/model/user"
	"mall-go/internal/data/model/usercoupon"
	"mall-go/internal/data/model/userfavor"
	"mall-go/internal/data/model/userinfo"
	"mall-go/internal/data/model/userpoint"
	"mall-go/internal/data/model/userpointdetail"
	"mall-go/internal/data/model/userwallet"
	"mall-go/internal/data/model/userwalletdetail"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// ent aliases to avoid import conflicts in user's code.
type (
	Op         = ent.Op
	Hook       = ent.Hook
	Value      = ent.Value
	Query      = ent.Query
	Policy     = ent.Policy
	Mutator    = ent.Mutator
	Mutation   = ent.Mutation
	MutateFunc = ent.MutateFunc
)

// OrderFunc applies an ordering on the sql selector.
type OrderFunc func(*sql.Selector)

// columnChecker returns a function indicates if the column exists in the given column.
func columnChecker(table string) func(string) error {
	checks := map[string]func(string) bool{
		activity.Table:         activity.ValidColumn,
		banner.Table:           banner.ValidColumn,
		banneritem.Table:       banneritem.ValidColumn,
		brand.Table:            brand.ValidColumn,
		category.Table:         category.ValidColumn,
		charge.Table:           charge.ValidColumn,
		coupon.Table:           coupon.ValidColumn,
		coupontemplate.Table:   coupontemplate.ValidColumn,
		coupontype.Table:       coupontype.ValidColumn,
		gridcategory.Table:     gridcategory.ValidColumn,
		order.Table:            order.ValidColumn,
		orderdetail.Table:      orderdetail.ValidColumn,
		ordersnap.Table:        ordersnap.ValidColumn,
		ordersub.Table:         ordersub.ValidColumn,
		refund.Table:           refund.ValidColumn,
		saleexplain.Table:      saleexplain.ValidColumn,
		sku.Table:              sku.ValidColumn,
		skuspec.Table:          skuspec.ValidColumn,
		speckey.Table:          speckey.ValidColumn,
		specvalue.Table:        specvalue.ValidColumn,
		spu.Table:              spu.ValidColumn,
		spudetailimg.Table:     spudetailimg.ValidColumn,
		spuimg.Table:           spuimg.ValidColumn,
		tag.Table:              tag.ValidColumn,
		theme.Table:            theme.ValidColumn,
		user.Table:             user.ValidColumn,
		usercoupon.Table:       usercoupon.ValidColumn,
		userfavor.Table:        userfavor.ValidColumn,
		userinfo.Table:         userinfo.ValidColumn,
		userpoint.Table:        userpoint.ValidColumn,
		userpointdetail.Table:  userpointdetail.ValidColumn,
		userwallet.Table:       userwallet.ValidColumn,
		userwalletdetail.Table: userwalletdetail.ValidColumn,
	}
	check, ok := checks[table]
	if !ok {
		return func(string) error {
			return fmt.Errorf("unknown table %q", table)
		}
	}
	return func(column string) error {
		if !check(column) {
			return fmt.Errorf("unknown column %q for table %q", column, table)
		}
		return nil
	}
}

// Asc applies the given fields in ASC order.
func Asc(fields ...string) OrderFunc {
	return func(s *sql.Selector) {
		check := columnChecker(s.TableName())
		for _, f := range fields {
			if err := check(f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("model: %w", err)})
			}
			s.OrderBy(sql.Asc(s.C(f)))
		}
	}
}

// Desc applies the given fields in DESC order.
func Desc(fields ...string) OrderFunc {
	return func(s *sql.Selector) {
		check := columnChecker(s.TableName())
		for _, f := range fields {
			if err := check(f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("model: %w", err)})
			}
			s.OrderBy(sql.Desc(s.C(f)))
		}
	}
}

// AggregateFunc applies an aggregation step on the group-by traversal/selector.
type AggregateFunc func(*sql.Selector) string

// As is a pseudo aggregation function for renaming another other functions with custom names. For example:
//
//	GroupBy(field1, field2).
//	Aggregate(model.As(model.Sum(field1), "sum_field1"), (model.As(model.Sum(field2), "sum_field2")).
//	Scan(ctx, &v)
//
func As(fn AggregateFunc, end string) AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.As(fn(s), end)
	}
}

// Count applies the "count" aggregation function on each group.
func Count() AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.Count("*")
	}
}

// Max applies the "max" aggregation function on the given field of each group.
func Max(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("model: %w", err)})
			return ""
		}
		return sql.Max(s.C(field))
	}
}

// Mean applies the "mean" aggregation function on the given field of each group.
func Mean(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("model: %w", err)})
			return ""
		}
		return sql.Avg(s.C(field))
	}
}

// Min applies the "min" aggregation function on the given field of each group.
func Min(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("model: %w", err)})
			return ""
		}
		return sql.Min(s.C(field))
	}
}

// Sum applies the "sum" aggregation function on the given field of each group.
func Sum(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("model: %w", err)})
			return ""
		}
		return sql.Sum(s.C(field))
	}
}

// ValidationError returns when validating a field fails.
type ValidationError struct {
	Name string // Field or edge name.
	err  error
}

// Error implements the error interface.
func (e *ValidationError) Error() string {
	return e.err.Error()
}

// Unwrap implements the errors.Wrapper interface.
func (e *ValidationError) Unwrap() error {
	return e.err
}

// IsValidationError returns a boolean indicating whether the error is a validation error.
func IsValidationError(err error) bool {
	if err == nil {
		return false
	}
	var e *ValidationError
	return errors.As(err, &e)
}

// NotFoundError returns when trying to fetch a specific entity and it was not found in the database.
type NotFoundError struct {
	label string
}

// Error implements the error interface.
func (e *NotFoundError) Error() string {
	return "model: " + e.label + " not found"
}

// IsNotFound returns a boolean indicating whether the error is a not found error.
func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	var e *NotFoundError
	return errors.As(err, &e)
}

// MaskNotFound masks not found error.
func MaskNotFound(err error) error {
	if IsNotFound(err) {
		return nil
	}
	return err
}

// NotSingularError returns when trying to fetch a singular entity and more then one was found in the database.
type NotSingularError struct {
	label string
}

// Error implements the error interface.
func (e *NotSingularError) Error() string {
	return "model: " + e.label + " not singular"
}

// IsNotSingular returns a boolean indicating whether the error is a not singular error.
func IsNotSingular(err error) bool {
	if err == nil {
		return false
	}
	var e *NotSingularError
	return errors.As(err, &e)
}

// NotLoadedError returns when trying to get a node that was not loaded by the query.
type NotLoadedError struct {
	edge string
}

// Error implements the error interface.
func (e *NotLoadedError) Error() string {
	return "model: " + e.edge + " edge was not loaded"
}

// IsNotLoaded returns a boolean indicating whether the error is a not loaded error.
func IsNotLoaded(err error) bool {
	if err == nil {
		return false
	}
	var e *NotLoadedError
	return errors.As(err, &e)
}

// ConstraintError returns when trying to create/update one or more entities and
// one or more of their constraints failed. For example, violation of edge or
// field uniqueness.
type ConstraintError struct {
	msg  string
	wrap error
}

// Error implements the error interface.
func (e ConstraintError) Error() string {
	return "model: constraint failed: " + e.msg
}

// Unwrap implements the errors.Wrapper interface.
func (e *ConstraintError) Unwrap() error {
	return e.wrap
}

// IsConstraintError returns a boolean indicating whether the error is a constraint failure.
func IsConstraintError(err error) bool {
	if err == nil {
		return false
	}
	var e *ConstraintError
	return errors.As(err, &e)
}
